"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[760],{57149:function(t,e,r){let a,n,i,s,o,c;r.d(e,{a$:function(){return o},aE:function(){return nN},aF:function(){return nJ},aJ:function(){return nV},aM:function(){return nY},aN:function(){return n1},aO:function(){return n2},aQ:function(){return nS},aR:function(){return im},aS:function(){return ig},aT:function(){return iy},aV:function(){return iw},aZ:function(){return i},af:function(){return az},ag:function(){return aO},ah:function(){return aB},ai:function(){return a_},aj:function(){return aF},ak:function(){return aL},al:function(){return nm},am:function(){return ng},an:function(){return ny},ar:function(){return nT},as:function(){return nW},au:function(){return nk},av:function(){return nx},ay:function(){return nM},bV:function(){return tK},bf:function(){return eM},br:function(){return rk},c4:function(){return ia},cA:function(){return r_},cB:function(){return aD},cC:function(){return tU},cD:function(){return tG},cE:function(){return t$},cF:function(){return tH},cG:function(){return e7},cH:function(){return rt},cI:function(){return nt},cJ:function(){return n6},cK:function(){return rn},cL:function(){return rw},cl:function(){return iT},cm:function(){return a6},cn:function(){return eK},co:function(){return ru},cp:function(){return e0},cq:function(){return n0},cr:function(){return a8},cs:function(){return it},ct:function(){return a9},cu:function(){return aN},cv:function(){return a4},cw:function(){return na},cx:function(){return nQ},cy:function(){return rc},cz:function(){return eV}});var l,d,p,u,h,m,g=r(1604),y=r(2508),f=r(2593),w=r(19485),b=r(16441),v=r(29251),C=r(9279),W=r(5325),A=r(6881),T=r(37707),k=r(99448),E=r(90967),S=r(36945),P=r(35553),I=r(38197),z=r(31886),O=r(32046),B=r(48088),_=r(81556),F=r(64146),R=r(84243),M=r(67827),x=r(21046),N=r(25025),D=r(70332),$=r(8455),L=r(2177),j=r(26729),q=r.n(j),U=r(54098),G=r.n(U),H=r(62555),Z=r(26219),V=r(61303),J=r(49242),Y=r(94317),Q=r(13670),K=r(79120),X=r(97604),tt=r(8187),te=r(19362),tr=r(54730),ta=r(36250),tn=r(85725),ti=r(38730),ts=r(237),to=r(65609),tc=r(77208),tl=r(86841),td=r(49561),tp=r(40553),tu=r(26),th=r(69392),tm=r(62822),tg=r.n(tm),ty=r(24234),tf=r(82037),tw=r(2162),tb=r(64063),tv=r.n(tb),tC=r(35922),tW=r(34161),tA=r(50266),tT=r(98839);r(96200);var tk=r(24601),tE=r(46878),tS=r(20583),tP=r(92355),tI=r(84194),tz=r(51121),tO=r(32484),tB=r(78435),t_=r(4779).lW,tF=r(34155);let tR="undefined"!=typeof window?g.z.instanceof(File):g.z.instanceof(t_),tM=g.z.union([tR,g.z.object({data:g.z.union([tR,g.z.string()]),name:g.z.string()})]),tx=g.z.union([tM,g.z.string()]),tN=g.z.union([g.z.array(g.z.number()),g.z.string()]),tD=g.z.union([g.z.string(),g.z.number(),g.z.bigint(),g.z.custom(t=>f.O$.isBigNumber(t))]).transform(t=>f.O$.from(t)),t$=tD.transform(t=>t.toString()),tL=g.z.union([g.z.bigint(),g.z.custom(t=>f.O$.isBigNumber(t))]).transform(t=>f.O$.from(t).toString()),tj=g.z.number().max(1e4,"Cannot exeed 100%").min(0,"Cannot be below 0%"),tq=g.z.number().max(100,"Cannot exeed 100%").min(0,"Cannot be below 0%"),tU=g.z.string().refine(t=>w.isAddress(t),t=>({message:`${t} is not a valid address`})),tG=g.z.union([g.z.string().regex(/^([0-9]+\.?[0-9]*|\.[0-9]+)$/,"Invalid amount"),g.z.number().min(0,"Amount cannot be negative")]).transform(t=>"number"==typeof t?t.toString():t),tH=g.z.date().transform(t=>f.O$.from(Math.floor(t.getTime()/1e3))),tZ=tH.default(new Date(0)),tV=tH.default(new Date(Date.now()+31536e7)),tJ=g.z.object({gasLimit:t$.optional(),gasPrice:t$.optional(),maxFeePerGas:t$.optional(),maxPriorityFeePerGas:t$.optional(),nonce:t$.optional(),value:t$.optional(),blockTag:g.z.union([g.z.string(),g.z.number()]).optional(),from:tU.optional(),type:g.z.number().optional()}).strict();(l=a||(a={}))[l.Mainnet=1]="Mainnet",l[l.Goerli=5]="Goerli",l[l.Polygon=137]="Polygon",l[l.Mumbai=80001]="Mumbai",l[l.Harmony=16666e5]="Harmony",l[l.Localhost=1337]="Localhost",l[l.Hardhat=31337]="Hardhat",l[l.Fantom=250]="Fantom",l[l.FantomTestnet=4002]="FantomTestnet",l[l.Avalanche=43114]="Avalanche",l[l.AvalancheFujiTestnet=43113]="AvalancheFujiTestnet",l[l.Optimism=10]="Optimism",l[l.OptimismGoerli=420]="OptimismGoerli",l[l.Arbitrum=42161]="Arbitrum",l[l.ArbitrumGoerli=421613]="ArbitrumGoerli",l[l.BinanceSmartChainMainnet=56]="BinanceSmartChainMainnet",l[l.BinanceSmartChainTestnet=97]="BinanceSmartChainTestnet";let tY=[a.Mainnet,a.Goerli,a.Polygon,a.Mumbai,a.Fantom,a.FantomTestnet,a.Avalanche,a.AvalancheFujiTestnet,a.Optimism,a.OptimismGoerli,a.Arbitrum,a.ArbitrumGoerli,a.BinanceSmartChainMainnet,a.BinanceSmartChainTestnet],tQ="0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",tK={[a.Mainnet]:{name:"Ether",symbol:"ETH",decimals:18,wrapped:{address:"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",name:"Wrapped Ether",symbol:"WETH"}},[a.Goerli]:{name:"G\xf6rli Ether",symbol:"GOR",decimals:18,wrapped:{address:"0xb4fbf271143f4fbf7b91a5ded31805e42b2208d6",name:"Wrapped Ether",symbol:"WETH"}},[a.Polygon]:{name:"Matic",symbol:"MATIC",decimals:18,wrapped:{address:"0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270",name:"Wrapped Matic",symbol:"WMATIC"}},[a.Mumbai]:{name:"Matic",symbol:"MATIC",decimals:18,wrapped:{address:"0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889",name:"Wrapped Matic",symbol:"WMATIC"}},[a.Avalanche]:{name:"Avalanche",symbol:"AVAX",decimals:18,wrapped:{address:"0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7",name:"Wrapped AVAX",symbol:"WAVAX"}},[a.AvalancheFujiTestnet]:{name:"Avalanche",symbol:"AVAX",decimals:18,wrapped:{address:"0xd00ae08403B9bbb9124bB305C09058E32C39A48c",name:"Wrapped AVAX",symbol:"WAVAX"}},[a.Fantom]:{name:"Fantom",symbol:"FTM",decimals:18,wrapped:{address:"0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83",name:"Wrapped Fantom",symbol:"WFTM"}},[a.FantomTestnet]:{name:"Fantom",symbol:"FTM",decimals:18,wrapped:{address:"0xf1277d1Ed8AD466beddF92ef448A132661956621",name:"Wrapped Fantom",symbol:"WFTM"}},[a.Arbitrum]:{name:"Ether",symbol:"ETH",decimals:18,wrapped:{address:"0x82af49447d8a07e3bd95bd0d56f35241523fbab1",name:"Wrapped Ether",symbol:"WETH"}},[a.ArbitrumGoerli]:{name:"Arbitrum Goerli Ether",symbol:"AGOR",decimals:18,wrapped:{address:"0xe39Ab88f8A4777030A534146A9Ca3B52bd5D43A3",name:"Wrapped Ether",symbol:"WETH"}},[a.Optimism]:{name:"Ether",symbol:"ETH",decimals:18,wrapped:{address:"0x4200000000000000000000000000000000000006",name:"Wrapped Ether",symbol:"WETH"}},[a.OptimismGoerli]:{name:"Goerli Ether",symbol:"ETH",decimals:18,wrapped:{address:"0x4200000000000000000000000000000000000006",name:"Wrapped Ether",symbol:"WETH"}},[a.Hardhat]:{name:"Ether",symbol:"ETH",decimals:18,wrapped:{address:"0x5FbDB2315678afecb367f032d93F642f64180aa3",name:"Wrapped Ether",symbol:"WETH"}},[a.BinanceSmartChainMainnet]:{name:"Binance Chain Native Token",symbol:"BNB",decimals:18,wrapped:{address:"0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",name:"Wrapped Binance Chain Token",symbol:"WBNB"}},[a.BinanceSmartChainTestnet]:{name:"Binance Chain Native Token",symbol:"TBNB",decimals:18,wrapped:{address:"0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd",name:"Wrapped Binance Chain Testnet Token",symbol:"WBNB"}}},tX=g.z.object({name:g.z.string(),symbol:g.z.string(),decimals:g.z.number()}),t0=tX.extend({value:tD,displayValue:g.z.string()}),t1=g.z.object({merkle:g.z.record(g.z.string()).default({})}),t2=g.z.object({address:tU,maxClaimable:tG.default(0)}),t5=g.z.union([g.z.array(g.z.string()).transform(t=>t.map(t=>t2.parse({address:t}))),g.z.array(t2)]),t7=t2.extend({proof:g.z.array(g.z.string())}),t3=g.z.object({merkleRoot:g.z.string(),claims:g.z.array(t7)});g.z.object({merkleRoot:g.z.string(),snapshotUri:g.z.string()});let t6=g.z.object({startTime:tZ,currencyAddress:g.z.string().default(tQ),price:tG.default(0),maxQuantity:y.Q,quantityLimitPerTransaction:y.Q,waitInSeconds:t$.default(0),merkleRootHash:tN.default(b.hexZeroPad([0],32)),snapshot:g.z.optional(t5).nullable()}),t8=g.z.array(t6);t6.partial();let t4=t6.extend({availableSupply:y.Q,currentMintSupply:y.Q,currencyMetadata:t0.default({value:f.O$.from("0"),displayValue:"0",symbol:"",decimals:18,name:""}),price:tD,waitInSeconds:tD,startTime:tD.transform(t=>new Date(1e3*t.toNumber())),snapshot:t5.optional().nullable()}),t9=g.z.object({to:g.z.string().default(C.d),price:tG.default(0),currencyAddress:g.z.string().default(tQ),mintStartTime:tZ,mintEndTime:tV,uid:g.z.string().optional().transform(t=>(function(t){if(void 0!==t)return b.hexlify(t);{let e=t_.alloc(16);return(0,tC.Z)({},e),b.hexlify(v.Y0(e.toString("hex")))}})(t)),primarySaleRecipient:g.z.string().default(C.d)}),et=t9.extend({quantity:tG}),ee=et.extend({mintStartTime:tD,mintEndTime:tD}),er=t9.extend({metadata:y.N,royaltyRecipient:g.z.string().default(C.d),royaltyBps:tj.default(0)}),ea=er.extend({uri:g.z.string(),royaltyBps:tD,mintStartTime:tD,mintEndTime:tD}),en=er.extend({metadata:y.N.default(""),quantity:t$}),ei=en.extend({tokenId:t$}),es=ea.extend({tokenId:tD,quantity:tD}),eo=er.extend({metadata:y.N.default(""),quantity:tD.default(1)}),ec=ea.extend({quantity:tD.default(1)}),el=[{name:"to",type:"address"},{name:"primarySaleRecipient",type:"address"},{name:"quantity",type:"uint256"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],ed=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],ep=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"tokenId",type:"uint256"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],eu=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],eh=g.z.object({name:g.z.string(),description:g.z.string().optional(),image:tx.optional(),external_link:g.z.string().url().optional()}),em=eh.extend({image:g.z.string().optional()}).catchall(g.z.unknown()),eg=g.z.object({seller_fee_basis_points:tj.default(0),fee_recipient:tU.default(C.d)}),ey=g.z.object({primary_sale_recipient:tU}),ef=g.z.object({platform_fee_basis_points:tj.default(0),platform_fee_recipient:tU.default(C.d)}),ew=g.z.object({trusted_forwarders:g.z.array(tU).default([])}),eb=g.z.object({symbol:g.z.string().optional().default("")}),ev=g.z.object({}).catchall(g.z.union([tL,g.z.unknown()]));g.z.union([g.z.array(ev),ev]).optional(),g.z.object({toAddress:tU,amount:tG});let eC=g.z.object({supply:tD,metadata:y.C});eC.extend({owner:g.z.string(),quantityOwned:tD}),g.z.object({supply:t$,metadata:y.a}),g.z.object({supply:t$,metadata:y.N});let eW="0xc82BbE41f2cF04e3a8efA18F7032BDD7f6d98a81",eA="0x7c487845f98938Bb955B1D5AD069d9a30e4131fd",eT="0x5DBC7B840baa9daBcBe9D2492E45D7244B54A2A0",ek={[a.Mainnet]:{openzeppelinForwarder:eW,openzeppelinForwarderEOA:"0x76ce2CB1Ae48Fa067f4fb8c5f803111AE0B24BEA",biconomyForwarder:"0x84a0856b038eaAd1cC7E297cF34A7e72685A8693",twFactory:eT,twRegistry:eA,twBYOCRegistry:C.d},[a.Goerli]:{openzeppelinForwarder:"0x5001A14CA6163143316a7C614e30e6041033Ac20",openzeppelinForwarderEOA:"0xe73c50cB9c5B378627ff625BB6e6725A4A5D65d2",biconomyForwarder:"0xE041608922d06a4F26C0d4c27d8bCD01daf1f792",twFactory:eT,twRegistry:eA,twBYOCRegistry:"0xB1Bd9d7942A250BA2Dce27DD601F2ED4211A60C4"},[a.Polygon]:{openzeppelinForwarder:eW,openzeppelinForwarderEOA:"0x4f247c69184ad61036EC2Bb3213b69F10FbEDe1F",biconomyForwarder:"0x86C80a8aa58e0A4fa09A69624c31Ab2a6CAD56b8",twFactory:eT,twRegistry:eA,twBYOCRegistry:"0x308473Be900F4185A56587dE54bDFF5E8f7a6AE7"},[a.Mumbai]:{openzeppelinForwarder:eW,openzeppelinForwarderEOA:"0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",biconomyForwarder:"0x9399BB24DBB5C4b782C70c2969F58716Ebbd6a3b",twFactory:eT,twRegistry:eA,twBYOCRegistry:"0x3F17972CB27506eb4a6a3D59659e0B57a43fd16C"},[a.Avalanche]:{openzeppelinForwarder:eW,openzeppelinForwarderEOA:"0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",biconomyForwarder:"0x64CD353384109423a966dCd3Aa30D884C9b2E057",twFactory:eT,twRegistry:eA,twBYOCRegistry:C.d},[a.AvalancheFujiTestnet]:{openzeppelinForwarder:eW,openzeppelinForwarderEOA:"0xe73c50cB9c5B378627ff625BB6e6725A4A5D65d2",biconomyForwarder:"0x6271Ca63D30507f2Dcbf99B52787032506D75BBF",twFactory:eT,twRegistry:eA,twBYOCRegistry:"0x3E6eE864f850F5e5A98bc950B68E181Cf4010F23"},[a.Fantom]:{openzeppelinForwarder:eW,openzeppelinForwarderEOA:"0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",biconomyForwarder:"0x64CD353384109423a966dCd3Aa30D884C9b2E057",twFactory:"0x97EA0Fcc552D5A8Fb5e9101316AAd0D62Ea0876B",twRegistry:eA,twBYOCRegistry:C.d},[a.FantomTestnet]:{openzeppelinForwarder:eW,openzeppelinForwarderEOA:"0x42D3048b595B6e1c28a588d70366CcC2AA4dB47b",biconomyForwarder:"0x69FB8Dca8067A5D38703b9e8b39cf2D51473E4b4",twFactory:eT,twRegistry:eA,twBYOCRegistry:"0x3E6eE864f850F5e5A98bc950B68E181Cf4010F23"},[a.Arbitrum]:{openzeppelinForwarder:eW,openzeppelinForwarderEOA:"0x4f247c69184ad61036EC2Bb3213b69F10FbEDe1F",biconomyForwarder:"0xfe0fa3C06d03bDC7fb49c892BbB39113B534fB57",twFactory:"0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",twRegistry:"0x7c487845f98938Bb955B1D5AD069d9a30e4131fd",twBYOCRegistry:C.d},[a.ArbitrumGoerli]:{openzeppelinForwarder:"0x8cbc8B5d71702032904750A66AEfE8B603eBC538",openzeppelinForwarderEOA:"0x119704314Ef304EaAAE4b3c7C9ABd59272A28310",biconomyForwarder:C.d,twFactory:"0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",twRegistry:"0x7c487845f98938Bb955B1D5AD069d9a30e4131fd",twBYOCRegistry:C.d},[a.Optimism]:{openzeppelinForwarder:eW,openzeppelinForwarderEOA:"0x7e80648EB2071E26937F9D42A513ccf4815fc702",biconomyForwarder:"0xefba8a2a82ec1fb1273806174f5e28fbb917cf95",twFactory:"0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",twRegistry:"0x7c487845f98938Bb955B1D5AD069d9a30e4131fd",twBYOCRegistry:C.d},[a.OptimismGoerli]:{openzeppelinForwarder:"0x8cbc8B5d71702032904750A66AEfE8B603eBC538",openzeppelinForwarderEOA:"0x119704314Ef304EaAAE4b3c7C9ABd59272A28310",biconomyForwarder:C.d,twFactory:"0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",twRegistry:"0x7c487845f98938Bb955B1D5AD069d9a30e4131fd",twBYOCRegistry:C.d},[a.BinanceSmartChainMainnet]:{openzeppelinForwarder:"0x8cbc8B5d71702032904750A66AEfE8B603eBC538",openzeppelinForwarderEOA:"0xE8dd2Ff0212F86d3197b4AfDC6dAC6ac47eb10aC",biconomyForwarder:"0x86C80a8aa58e0A4fa09A69624c31Ab2a6CAD56b8",twBYOCRegistry:C.d,twFactory:"0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",twRegistry:"0x7c487845f98938Bb955B1D5AD069d9a30e4131fd"},[a.BinanceSmartChainTestnet]:{openzeppelinForwarder:"0x8cbc8B5d71702032904750A66AEfE8B603eBC538",openzeppelinForwarderEOA:"0x7e80648EB2071E26937F9D42A513ccf4815fc702",biconomyForwarder:"0x61456BF1715C1415730076BB79ae118E806E74d2",twBYOCRegistry:C.d,twFactory:"0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",twRegistry:"0x7c487845f98938Bb955B1D5AD069d9a30e4131fd"}},eE=b.arrayify("0x80ac58cd"),eS=b.arrayify("0xd9b67a26");(d=n||(n={})).Transaction="transaction",d.Signature="signature";class eP extends W.c{constructor(t,e){super(t,e),(0,y._)(this,"_pendingBatchAggregator",void 0),(0,y._)(this,"_pendingBatch",void 0),this._pendingBatchAggregator=null,this._pendingBatch=null}send(t,e){let r={method:t,params:e,id:this._nextId++,jsonrpc:"2.0"};null===this._pendingBatch&&(this._pendingBatch=[]);let a={request:r,resolve:null,reject:null},n=new Promise((t,e)=>{a.resolve=t,a.reject=e});return this._pendingBatch.push(a),this._pendingBatchAggregator||(this._pendingBatchAggregator=setTimeout(()=>{let t=this._pendingBatch||[];this._pendingBatch=null,this._pendingBatchAggregator=null;let e=t.map(t=>t.request);return this.emit("debug",{action:"requestBatch",request:A.deepCopy(r),provider:this}),T.fetchJson(this.connection,JSON.stringify(e)).then(r=>{this.emit("debug",{action:"response",request:e,response:r,provider:this}),t.forEach((t,e)=>{let a=r[e];if(a.error){let n=Error(a.error.message);n.code=a.error.code,n.data=a.error.data,t.reject(n)}else t.resolve(a.result)})},e=>{this.emit("debug",{action:"response",error:e,request:r,provider:this}),t.forEach(t=>{t.reject(e)})})},10)),n}}let eI={"avalanche-fuji":a.AvalancheFujiTestnet,"avalanche-testnet":a.AvalancheFujiTestnet,"fantom-testnet":a.FantomTestnet,ethereum:a.Mainnet,matic:a.Polygon,mumbai:a.Mumbai,goerli:a.Goerli,polygon:a.Polygon,mainnet:a.Mainnet,optimism:a.Optimism,"optimism-goerli":a.OptimismGoerli,arbitrum:a.Arbitrum,"arbitrum-goerli":a.ArbitrumGoerli,fantom:a.Fantom,avalanche:a.Avalanche,binance:a.BinanceSmartChainMainnet,"binance-testnet":a.BinanceSmartChainTestnet},ez=Object.fromEntries(Object.entries(eI).map(t=>{let[e,r]=t;return[r,e]}));function eO(t,e){try{let r=t.match(/^(ws|http)s?:/i);if(!r)return S.yl(t);switch(r[1]){case"http":return e?new eP(t,e):new k.I(t,e);case"ws":return new E.q(t,e);default:return S.yl(t)}}catch(a){return S.yl(t)}}tY.reduce((t,e)=>(t[e]=function(t){if("string"!=typeof t)return t;switch(t){case"mainnet":case"ethereum":return(0,y.g)("ethereum");case"goerli":return(0,y.g)("goerli");case"polygon":case"matic":return(0,y.g)("polygon");case"mumbai":return(0,y.g)("mumbai");case"optimism":return(0,y.g)("optimism");case"optimism-goerli":return(0,y.g)("optimism-goerli");case"arbitrum":return(0,y.g)("arbitrum");case"arbitrum-goerli":return(0,y.g)("arbitrum-goerli");case"fantom":return(0,y.g)("fantom");case"fantom-testnet":return(0,y.g)("fantom-testnet");case"avalanche":return(0,y.g)("avalanche");case"avalanche-testnet":case"avalanche-fuji":return(0,y.g)("avalanche-fuji");case"binance":return(0,y.g)("binance");case"binance-testnet":return(0,y.g)("binance-testnet");default:if(t.startsWith("http")||t.startsWith("ws"))return t;throw Error(`Unrecognized chain name or RPC url: ${t}`)}}(ez[e]),t),{});class eB extends Error{constructor(t){super(t?`Object with id ${t} NOT FOUND`:"NOT_FOUND")}}class e_ extends Error{constructor(t,e){super(`MISSING ROLE: ${t} does not have the '${e}' role`)}}class eF extends Error{constructor(t){super(`DUPLICATE_LEAFS${t?` : ${t}`:""}`)}}class eR extends Error{constructor(t){super(`Auction already started with existing bid${t?`, id: ${t}`:""}`)}}class eM extends Error{constructor(t,e){super(`Could not find listing.${t?` marketplace address: ${t}`:""}${e?` listing id: ${e}`:""}`)}}class ex extends Error{constructor(t,e,r,a){super(`Incorrect listing type. Are you sure you're using the right method?.${t?` marketplace address: ${t}`:""}${e?` listing id: ${e}`:""}${a?` expected type: ${a}`:""}${r?` actual type: ${r}`:""}`)}}class eN extends Error{constructor(t,e){super(`Auction has not ended yet${t?`, id: ${t}`:""}${e?`, end time: ${e.toString()}`:""}`)}}class eD extends Error{constructor(t){super(`This functionality is not available because the contract does not implement the '${t.docLinks.contracts}' Extension. Learn how to unlock this functionality at https://portal.thirdweb.com/extensions `)}}class e$ extends Error{constructor(t,e,r,a,n,i,s,o){let c="Contract transaction failed\n\n";if(c+=`Message: ${t}`,c+="\n\n| Transaction info |\n",c+=ej("from",e),c+=ej("to",r),c+=ej("chain",`${n.name} (${n.chainId})`),o&&(c+="\n\n| Failed contract call info |\n",c+=ej("function",o.signature),c+=ej("arguments",JSON.stringify(o.inputs,null,2)),o.value.gt(0))){var l;c+=ej("value",`${P.formatEther(o.value)} ${null===(l=tK[n.chainId])||void 0===l?void 0:l.symbol}`)}try{let d=new URL(i);c+=ej("RPC",d.hostname)}catch(p){}c+="\n\n",c+="Need help with this error? Join our community: https://discord.gg/thirdweb",c+="\n\n\n\n",c+="| Raw error |",c+="\n\n",super(c+=s),(0,y._)(this,"reason",void 0),(0,y._)(this,"from",void 0),(0,y._)(this,"to",void 0),(0,y._)(this,"data",void 0),(0,y._)(this,"chain",void 0),(0,y._)(this,"rpcUrl",void 0),(0,y._)(this,"functionInfo",void 0),this.reason=t,this.from=e,this.to=r,this.data=a,this.chain=n,this.rpcUrl=i,this.functionInfo=o}}async function eL(t,e,r,a,n){let i;i=t.data?JSON.stringify(t.data):t instanceof Error?t.message:t.toString();let s=t.reason||eq(/.*?"message[^a-zA-Z0-9]*([^"\\]*).*?/,i),o=eq(/.*?"data[^a-zA-Z0-9]*([^"\\]*).*?/,i),c=eq(/.*?"url[^a-zA-Z0-9]*([^"\\]*).*?/,i),l=eq(/.*?"from[^a-zA-Z0-9]*([^"\\]*).*?/,i),d=eq(/.*?"to[^a-zA-Z0-9]*([^"\\]*).*?/,i);""===d&&(d=a),""===l&&(l=r);let p=o.length>0?function(t,e){try{let r=e.parseTransaction({data:t}),a={},n=r.args;return r.functionFragment.inputs.forEach((t,e)=>{if(Array.isArray(n[e])){let r={},i=t.components;if(i){let s=n[e];for(let o=0;o<i.length;o++){let c=i[o].name;r[c]=s[o]}a[t.name]=r}}else a[t.name]=n[e]}),{signature:r.signature,inputs:a,value:r.value}}catch(i){return}}(o,n):void 0;return new e$(s,l,d,o,e,c,i,p)}function ej(t,e){if(""===e)return e;let r=Array(10-t.length).fill(" ").join("");return`
${t}:${r}${e}`}function eq(t,e){let r=e.match(t)||[],a="";return(null==r?void 0:r.length)>0&&(a+=r[1]),a}function eU(t,e){return t&&t.toString().includes(e)||t.message&&t.message.toString().includes(e)||t.error&&t.error.toString().includes(e)}let eG=eh.merge(eg).merge(t1).merge(eb),eH=em.merge(eg).merge(t1).merge(eb),eZ=eG.merge(ef).merge(ey).merge(ew),eV={deploy:eZ,output:eH,input:eG},eJ=eh.merge(eg).merge(t1).merge(eb),eY=em.merge(eg).merge(t1).merge(eb),eQ=eJ.merge(ef).merge(ey).merge(ew),eK={deploy:eQ,output:eY,input:eJ},eX=eh.merge(ef).merge(ew),e0={deploy:eX,output:em,input:eh},e1=eh.merge(eg).merge(eb),e2=em.merge(eg).merge(eb),e5=e1.merge(ef).merge(ew),e7={deploy:e5,output:e2,input:e1},e3=g.z.object({address:tU,sharesBps:tj.gt(0,"Shares must be greater than 0")}),e6=e3.extend({address:tU,sharesBps:tj}),e8=eh.extend({recipients:g.z.array(e3).default([]).superRefine((t,e)=>{let r={},a=0;for(let n=0;n<t.length;n++){let i=t[n];r[i.address]&&e.addIssue({code:g.z.ZodIssueCode.custom,message:"Duplicate address.",path:[n,"address"]}),r[i.address]=!0,(a+=i.sharesBps)>1e4&&e.addIssue({code:g.z.ZodIssueCode.custom,message:"Total shares cannot go over 100%.",path:[n,"sharesBps"]})}1e4!==a&&e.addIssue({code:g.z.ZodIssueCode.custom,message:`Total shares need to add up to 100%. Total shares are currently ${a/100}%`,path:[]})})}),e4=em.extend({recipients:g.z.array(e6)}),e9=e8.merge(e8).merge(ew),rt={deploy:e9,output:e4,input:e8},re=eh.merge(eb),rr=em.merge(eb),ra=re.merge(ef).merge(ey).merge(ew),rn={deploy:ra,output:rr,input:re},ri=eh.merge(eg).merge(eb),rs=em.merge(eg).merge(eb),ro=ri.merge(ef).merge(ey).merge(ew),rc={deploy:ro,output:rs,input:ri},rl=eh.merge(eg).merge(eb),rd=em.merge(eg).merge(eb),rp=rl.merge(ef).merge(ey).merge(ew),ru={deploy:rp,output:rd,input:rl},rh=g.z.object({voting_delay_in_blocks:g.z.number().min(0).default(0),voting_period_in_blocks:g.z.number().min(1).default(1),voting_token_address:tU,voting_quorum_fraction:tq.default(0),proposal_token_threshold:t$.default(1)}),rm=rh.extend({proposal_token_threshold:tD}),rg=eh.merge(rh),ry=em.merge(rm),rf=rg.merge(ew),rw={deploy:rf,output:ry,input:rg};g.z.object({proposalId:tD,proposer:g.z.string(),targets:g.z.array(g.z.string()),values:g.z.array(tD),signatures:g.z.array(g.z.string()),calldatas:g.z.array(g.z.string()),startBlock:tD,endBlock:tD,description:g.z.string()});let rb=g.z.object({readonlySettings:g.z.object({rpcUrl:g.z.string().url(),chainId:g.z.number().optional()}).optional(),gasSettings:g.z.object({maxPriceInGwei:g.z.number().min(1,"gas price cannot be less than 1").default(300),speed:g.z.enum(["standard","fast","fastest"]).default("fastest")}).default({maxPriceInGwei:300,speed:"fastest"}),gasless:g.z.union([g.z.object({openzeppelin:g.z.object({relayerUrl:g.z.string().url(),relayerForwarderAddress:g.z.string().optional(),useEOAForwarder:g.z.boolean().default(!1)}),experimentalChainlessSupport:g.z.boolean().default(!1)}),g.z.object({biconomy:g.z.object({apiId:g.z.string(),apiKey:g.z.string(),deadlineSeconds:g.z.number().min(1,"deadlineSeconds cannot be les than 1").default(3600)})})]).optional()}).default({gasSettings:{maxPriceInGwei:300,speed:"fastest"}});g.z.object({nonce:g.z.string().optional(),expirationTime:g.z.date().optional(),chainId:g.z.number().optional()}).optional();let rv=g.z.object({domain:g.z.string(),address:tU,nonce:g.z.string().default((0,tC.Z)()),expiration_time:g.z.date().transform(t=>t.toISOString()),chain_id:g.z.number().optional()});g.z.object({payload:rv,signature:g.z.string()}),g.z.object({chainId:g.z.number().optional()}).optional(),g.z.object({invalidBefore:g.z.date().optional(),expirationTime:g.z.date().optional()}).optional();let rC=g.z.object({iss:g.z.string(),sub:g.z.string(),aud:g.z.string(),exp:tH.transform(t=>t.toNumber()),nbf:tH.transform(t=>t.toNumber()),iat:tH.transform(t=>t.toNumber()),jti:g.z.string().default((0,tC.Z)())});g.z.object({payload:rC,signature:g.z.string()});class rW{constructor(t,e,r,a,n){(0,y._)(this,"shardNybbles",void 0),(0,y._)(this,"shards",void 0),(0,y._)(this,"trees",void 0),(0,y._)(this,"storage",void 0),(0,y._)(this,"baseUri",void 0),(0,y._)(this,"originalEntriesUri",void 0),(0,y._)(this,"tokenDecimals",void 0),this.storage=t,this.shardNybbles=a,this.baseUri=e,this.originalEntriesUri=r,this.tokenDecimals=n,this.shards={},this.trees={}}static async fromUri(t,e){try{let r=await e.downloadJSON(t);if(r.isShardedMerkleTree)return rW.fromShardedMerkleTreeInfo(r,e)}catch(a){return}}static async fromShardedMerkleTreeInfo(t,e){return new rW(e,t.baseUri,t.originalEntriesUri,t.shardNybbles,t.tokenDecimals)}static hashEntry(t,e){var r,a;return r=t.address,a=P.parseUnits(t.maxClaimable,e),z.keccak256(["address","uint256"],[r,f.O$.from(a)])}static async buildAndUpload(t,e,r){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:2,n=t5.parse(t),i={};for(let s of n){let o=s.address.slice(2,2+a).toLowerCase();void 0===i[o]&&(i[o]=[]),i[o].push(s)}let c=Object.fromEntries(Object.entries(i).map(t=>{let[r,a]=t;return[r,new tw.MerkleTree(a.map(t=>rW.hashEntry(t,e)),I.keccak256,{sort:!0}).getHexRoot()]})),l=new tw.MerkleTree(Object.values(c),I.keccak256,{sort:!0}),d=[];for(let[p,u]of Object.entries(i)){let h={proofs:l.getProof(c[p]).map(t=>"0x"+t.data.toString("hex")),entries:u};d.push({data:JSON.stringify(h),name:`${p}.json`})}let m=await r.uploadBatch(d),g=m[0].slice(0,m[0].lastIndexOf("/")),y=await r.upload(n),f={merkleRoot:l.getHexRoot(),baseUri:g,originalEntriesUri:y,shardNybbles:a,tokenDecimals:e,isShardedMerkleTree:!0},w=await r.upload(f);return{shardedMerkleInfo:f,uri:w}}async getProof(t){let e=t.slice(2,2+this.shardNybbles).toLowerCase(),r=this.shards[e];if(void 0===r)try{r=this.shards[e]=await this.storage.downloadJSON(`${this.baseUri}/${e}.json`),this.trees[e]=new tw.MerkleTree(r.entries.map(t=>rW.hashEntry(t,this.tokenDecimals)),I.keccak256,{sort:!0})}catch(a){return console.warn("No merkle entry found for address",t),null}let n=r.entries.find(e=>e.address.toLowerCase()===t.toLowerCase());if(!n)return null;let i=rW.hashEntry(n,this.tokenDecimals),s=this.trees[e].getProof(i).map(t=>"0x"+t.data.toString("hex"));return{address:t,proof:s.concat(r.proofs),maxClaimable:n.maxClaimable}}async getAllEntries(){try{let t=await this.storage.downloadJSON(this.originalEntriesUri);return t}catch(e){return console.warn("Could not fetch original snapshot entries",e),[]}}computeAllShardIds(t){let e=parseInt(`0x${"f".repeat(t)}`,16),r=[];for(let a=0;a<=e;a++)r.push(a.toString(16).padStart(t,"0"));return r}}async function rA(t,e,r){let a=t5.parse(t),n=a.map(t=>t.address),i=new Set(n).size<n.length;if(i)throw new eF;let s=await rW.buildAndUpload(a,e,r);return{merkleRoot:s.shardedMerkleInfo.merkleRoot,snapshotUri:s.uri}}let rT={admin:"",transfer:"TRANSFER_ROLE",minter:"MINTER_ROLE",pauser:"PAUSER_ROLE",lister:"LISTER_ROLE",asset:"ASSET_ROLE",unwrap:"UNWRAP_ROLE",factory:"FACTORY_ROLE"};function rk(t){return"admin"===t?b.hexZeroPad([0],32):O.id(rT[t])}Object.keys(rT);let rE={name:"ERC20ClaimableWithConditions",namespace:"token.drop.claim",docLinks:{sdk:"sdk.erc20dclaimable",contracts:"DropSinglePhase"},abis:[J,V],features:{}},rS={name:"ERC20Burnable",namespace:"token.burn",docLinks:{sdk:"sdk.erc20burnable",contracts:"IBurnableERC20"},abis:[J,Z],features:{}},rP={name:"ERC20SignatureMintable",namespace:"token.signature",docLinks:{sdk:"sdk.erc20signaturemintable",contracts:"ISignatureMintERC20"},abis:[J,K],features:{}},rI={name:"ERC20BatchMintable",namespace:"token.mint.batch",docLinks:{sdk:"sdk.erc20batchmintable",contracts:"IMulticall"},abis:[J,Y,Q],features:{}},rz={name:"ERC20Mintable",namespace:"token.mint",docLinks:{sdk:"sdk.erc20mintable",contracts:"IMintableERC20"},abis:[J,Y],features:{[rI.name]:rI}},rO={name:"ERC20",namespace:"token",docLinks:{sdk:"sdk.erc20",contracts:"IERC20"},abis:[J],features:{[rS.name]:rS,[rz.name]:rz,[rE.name]:rE,[rP.name]:rP}},rB={name:"ERC721Burnable",namespace:"nft.burn",docLinks:{sdk:"sdk.erc721burnable",contracts:"IBurnableERC721"},abis:[D,X],features:{}},r_={name:"ERC721Revealable",namespace:"nft.drop.revealer",docLinks:{sdk:"sdk.drop.delayedreveal",contracts:"DelayedReveal"},abis:[D,tn,te],features:{}},rF={name:"ERC721ClaimableWithConditions",namespace:"nft.drop.claim",docLinks:{sdk:"sdk.erc721claimable",contracts:"DropSinglePhase"},abis:[D,tn,V],features:{}},rR={name:"ERC721Claimable",namespace:"nft.drop.claim",docLinks:{sdk:"sdk.erc721claimable",contracts:"IClaimableERC721"},abis:[D,tn,tt],features:{}},rM={name:"ERC721LazyMintable",namespace:"nft.drop",docLinks:{sdk:"sdk.erc721lazymintable",contracts:"LazyMint"},abis:[D,tn],features:{[r_.name]:r_,[rR.name]:rR,[rF.name]:rF}},rx={name:"ERC721BatchMintable",namespace:"nft.mint.batch",docLinks:{sdk:"sdk.erc721batchmintable",contracts:"IMulticall"},abis:[D,ti,Q],features:{}},rN={name:"ERC721Mintable",namespace:"nft.mint",docLinks:{sdk:"sdk.erc721mintable",contracts:"IMintableERC721"},abis:[D,ti],features:{[rx.name]:rx}},rD={name:"ERC721SignatureMint",namespace:"nft.signature",docLinks:{sdk:"sdk.erc721signaturemint",contracts:"ISignatureMintERC721"},abis:[D,ts],features:{}},r$={name:"ERC721Enumerable",namespace:"nft.query.owned",docLinks:{sdk:"sdk.erc721enumerable",contracts:"IERC721Enumerable"},abis:[D,tr],features:{}},rL={name:"ERC721Supply",namespace:"nft.query",docLinks:{sdk:"sdk.erc721supply",contracts:"IERC721Supply"},abis:[D,ta],features:{[r$.name]:r$}},rj={name:"ERC721",namespace:"nft",docLinks:{sdk:"sdk.erc721",contracts:"IERC721"},abis:[D],features:{[rB.name]:rB,[rL.name]:rL,[rN.name]:rN,[rM.name]:rM,[rD.name]:rD}},rq={name:"ERC1155Burnable",namespace:"edition.burn",docLinks:{sdk:"sdk.erc1155burnable",contracts:"IBurnableERC1155"},abis:[$,tl],features:{}},rU={name:"ERC1155ClaimableWithConditions",namespace:"edition.drop.claim",docLinks:{sdk:"sdk.erc1155claimable",contracts:"DropSinglePhase1155"},abis:[$,tn,tc],features:{}},rG={name:"ERC1155Claimable",namespace:"edition.drop.claim",docLinks:{sdk:"sdk.erc1155claimable",contracts:"IClaimableERC1155"},abis:[$,tn,td],features:{}},rH={name:"ERC1155LazyMintable",namespace:"edition.drop",docLinks:{sdk:"sdk.erc1155droppable",contracts:"LazyMint"},abis:[$,tn],features:{[rG.name]:rG,[rU.name]:rU}},rZ={name:"ERC1155Revealable",namespace:"edition.drop.revealer",docLinks:{sdk:"sdk.drop.delayedreveal",contracts:"DelayedReveal"},abis:[$,tn,to],features:{}},rV={name:"ERC1155SignatureMintable",namespace:"edition.signature",docLinks:{sdk:"sdk.erc1155signaturemintable",contracts:"ISignatureMintERC1155"},abis:[$,th],features:{}},rJ={name:"ERC1155BatchMintable",namespace:"edition.mint.batch",docLinks:{sdk:"sdk.erc1155batchmintable",contracts:"IMulticall"},abis:[$,tu,Q],features:{}},rY={name:"ERC1155Mintable",namespace:"edition.mint",docLinks:{sdk:"sdk.erc1155mintable",contracts:"IMintableERC1155"},abis:[$,tu],features:{[rJ.name]:rJ}},rQ={name:"ERC1155Enumerable",namespace:"edition.query",docLinks:{sdk:"sdk.erc1155",contracts:"IERC1155"},abis:[$,tp],features:{}},rK={name:"ERC1155",namespace:"edition",docLinks:{sdk:"sdk.erc1155enumerable",contracts:"IERC1155Enumerable"},abis:[$],features:{[rq.name]:rq,[rQ.name]:rQ,[rY.name]:rY,[rH.name]:rH,[rZ.name]:rZ,[rV.name]:rV}},rX={name:"Royalty",namespace:"royalty",docLinks:{sdk:"sdk.contractroyalty",contracts:"Royalty"},abis:[tO],features:{}},r0={name:"PrimarySale",namespace:"sales",docLinks:{sdk:"sdk.contractprimarysale",contracts:"PrimarySale"},abis:[tz],features:{}},r1={name:"PlatformFee",namespace:"platformFee",docLinks:{sdk:"sdk.platformfee",contracts:"PlatformFee"},abis:[tI],features:{}},r2={name:"PermissionsEnumerable",namespace:"roles",docLinks:{sdk:"sdk.contractroles",contracts:"PermissionsEnumerable"},abis:[tP],features:{}},r5={name:"Permissions",namespace:"roles",docLinks:{sdk:"sdk.contractroles",contracts:"Permissions"},abis:[tS],features:{[r2.name]:r2}},r7={name:"ContractMetadata",namespace:"metadata",docLinks:{sdk:"sdk.contractmetadata",contracts:"ContractMetadata"},abis:[tE],features:{}},r3={name:"AppURI",namespace:"appURI",docLinks:{sdk:"sdk.appURI",contracts:"AppURI"},abis:[tk],features:{}},r6={name:"Ownable",namespace:"owner",docLinks:{sdk:"sdk.owner",contracts:"Ownable"},abis:[tB],features:{}},r8={[rO.name]:rO,[rj.name]:rj,[rK.name]:rK,[rX.name]:rX,[r1.name]:r1,[r0.name]:r0,[r5.name]:r5,[r7.name]:r7,[r3.name]:r3,[r6.name]:r6};function r4(t,e){let r=(t||[]).filter(t=>"function"===t.type),a=[];for(let n of r){var i,s,o,c;let l=function(t,e,r){var a,n,i,s,o,c,l,d,p,u;return(null==e?void 0:null===(a=e.output)||void 0===a?void 0:null===(n=a.userdoc)||void 0===n?void 0:null===(i=n[r])||void 0===i?void 0:null===(s=i[Object.keys((null==e?void 0:null===(o=e.output)||void 0===o?void 0:o.userdoc[r])||{}).find(e=>e.includes(t||"unknown"))||""])||void 0===s?void 0:s.notice)||(null==e?void 0:null===(c=e.output)||void 0===c?void 0:null===(l=c.devdoc)||void 0===l?void 0:null===(d=l[r])||void 0===d?void 0:null===(p=d[Object.keys((null==e?void 0:null===(u=e.output)||void 0===u?void 0:u.devdoc[r])||{}).find(e=>e.includes(t||"unknown"))||""])||void 0===p?void 0:p.details)}(n.name,e,"methods"),d=(null===(i=n.inputs)||void 0===i?void 0:null===(s=i.map(t=>`${t.name||"key"}: ${r9(t)}`))||void 0===s?void 0:s.join(", "))||"",p=d?`, ${d}`:"",u=null===(o=n.outputs)||void 0===o?void 0:null===(c=o.map(t=>r9(t,!0)))||void 0===c?void 0:c.join(", "),h=u?`: Promise<${u}>`:": Promise<TransactionResult>",m=`contract.call("${n.name}"${p})${h}`;a.push({inputs:n.inputs||[],outputs:n.outputs||[],name:n.name||"unknown",signature:m,stateMutability:n.stateMutability||"",comment:l})}return a}function r9(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],r=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=t.type,n=!1;return a.endsWith("[]")&&(n=!0,a=a.slice(0,-2)),a.startsWith("bytes")&&(a="BytesLike"),(a.startsWith("uint")||a.startsWith("int"))&&(a=e?"BigNumber":"BigNumberish"),a.startsWith("bool")&&(a="boolean"),"address"===a&&(a="string"),"tuple"===a&&t.components&&(a=`{ ${t.components.map(t=>r9(t,!1,!0)).join(", ")} }`),n&&(a+="[]"),r&&(a=`${t.name}: ${a}`),a}async function at(t,e){let r=await e.getCode(t);if("0x"===r){let a=await e.getNetwork();throw Error(`Contract at ${t} does not exist on chain '${a.name}' (chainId: ${a.chainId})`)}if(r.startsWith("0x363d3d373d3d3d363d")){let n=r.slice(22,62);return await at(`0x${n}`,e)}try{let i=await e.getStorageAt(t,f.O$.from("0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc")),s=b.hexStripZeros(i);if("0x"!==s)return await at(s,e)}catch(o){}return await function(t){let e=function(t){var e;if((t=t.toString(16)).startsWith("0x")||(t=`0x${t}`),!(("string"==typeof(e=t)||"number"==typeof e)&&/^(-)?0x[0-9a-f]*$/i.test(e.toString())))throw Error(`Given value "${t}" is not a valid hex string.`);t=t.replace(/^0x/i,"");let r=[];for(let a=0;a<t.length;a+=2)r.push(parseInt(t.slice(a,a+2),16));return r}(t),r=256*e[e.length-2]+e[e.length-1],a=Uint8Array.from(e.slice(e.length-2-r,-2)),n=(0,ty.Jx)(a);if("ipfs"in n&&n.ipfs)try{return`ipfs://${tg().encode(n.ipfs)}`}catch(i){console.warn("feature-detection ipfs cbor failed",i)}}(r)}async function ae(t,e,r){let a=await at(t,e);if(!a)throw Error(`Could not resolve metadata for contract at ${t}`);return await ar(a,r)}async function ar(t,e){let r=await e.downloadJSON(t),a=af.parse(r.output.abi),n=r.settings.compilationTarget,i=Object.keys(n),s=n[i[0]],o=aT.parse({title:r.output.devdoc.title,author:r.output.devdoc.author,details:r.output.devdoc.detail,notice:r.output.userdoc.notice}),c=[...new Set(Object.entries(r.sources).map(t=>{let[,e]=t;return e.license}))];return{name:s,abi:a,metadata:r,info:o,licenses:c}}function aa(t,e){if(!t)throw new eD(e);return t}function an(t,e){return function(t,e){let r=function t(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:r8,a={};for(let n in r){let i=r[n],s=function(t,e){let r=[...new Set(r4(t).map(t=>t.name))],a=[...new Set(e.abis.flatMap(t=>r4(t)).map(t=>t.name))];return r.filter(t=>a.includes(t)).length===a.length}(e,i),o=t(e,i.features);a[n]={...i,features:o,enabled:s}}return a}(t);return function t(e,r){let a=Object.keys(e);if(!a.includes(r)){let n=!1;for(let i of a){let s=e[i];if(n=t(s.features,r))break}return n}let o=e[r];return o.enabled}(r,e)}(af.parse(t.abi),e)}function ai(t,e){return t in e.readContract.functions}let as="0|[1-9]\\d*",ao=`(${as})\\.(${as})\\.(${as})`,ac=RegExp(ao),al=eh.catchall(g.z.union([tL,g.z.unknown()])),ad=al.merge(eg.merge(t1).merge(eb).partial()),ap=em.merge(eg.merge(t1).merge(eb).partial()),au=ad.merge(ef.merge(ey).merge(ew).partial()),ah={deploy:au,output:ap,input:ad},am=g.z.object({type:g.z.string(),name:g.z.string()}).catchall(g.z.any()),ag=am.extend({stateMutability:g.z.string().optional(),components:g.z.array(am).optional()}).catchall(g.z.any()),ay=g.z.object({type:g.z.string(),name:g.z.string().default(""),inputs:g.z.array(ag).default([]),outputs:g.z.array(ag).default([])}).catchall(g.z.any()),af=g.z.array(ay),aw=g.z.object({name:g.z.string(),metadataUri:g.z.string(),bytecodeUri:g.z.string(),analytics:g.z.any().optional()}).catchall(g.z.any()),ab=g.z.record(g.z.string(),g.z.string()),av=g.z.object({implementationAddresses:ab,implementationInitializerFunction:g.z.string().default("initialize"),factoryAddresses:ab.optional()}),aC=g.z.object({version:g.z.string().refine(t=>{try{return!function(t){if(t.length>256)throw Error("version is longer than 256 characters");let e=t.trim().match(ac);if(!e||(null==e?void 0:e.length)!==4)throw Error(`${t} is not a valid semantic version. Should be in the format of major.minor.patch. Ex: 0.4.1`);let r=Number(e[1]),a=Number(e[2]),n=Number(e[3]);[r,a,n].join(".")}(t),!0}catch(e){return!1}},t=>({message:`'${t}' is not a valid semantic version. Should be in the format of major.minor.patch. Ex: 0.4.1`})),displayName:g.z.string().optional(),description:g.z.string().optional(),readme:g.z.string().optional(),license:g.z.string().optional(),changelog:g.z.string().optional(),tags:g.z.array(g.z.string()).optional(),audit:tx.nullable().optional(),logo:tx.nullable().optional(),isDeployableViaFactory:g.z.boolean().optional(),isDeployableViaProxy:g.z.boolean().optional(),factoryDeploymentData:av.optional()}).catchall(g.z.any()),aW=aC.extend({audit:g.z.string().nullable().optional(),logo:g.z.string().nullable().optional()});aw.merge(aC).extend({publisher:tU.optional()}),aw.merge(aW).extend({publisher:tU.optional()});let aA=g.z.object({name:g.z.string().optional(),bio:g.z.string().optional(),avatar:tx.nullable().optional(),website:g.z.string().optional(),twitter:g.z.string().optional(),telegram:g.z.string().optional(),facebook:g.z.string().optional(),github:g.z.string().optional(),medium:g.z.string().optional(),linkedin:g.z.string().optional(),reddit:g.z.string().optional(),discord:g.z.string().optional()});aA.extend({avatar:g.z.string().nullable().optional()}),g.z.object({id:g.z.string(),timestamp:t$,metadataUri:g.z.string()});let aT=g.z.object({title:g.z.string().optional(),author:g.z.string().optional(),details:g.z.string().optional(),notice:g.z.string().optional()}),ak=g.z.object({name:g.z.string(),abi:af,metadata:g.z.record(g.z.string(),g.z.any()),info:aT,licenses:g.z.array(g.z.string().optional()).default([]).transform(t=>t.filter(t=>void 0!==t))});aw.merge(ak).extend({bytecode:g.z.string()});let aE=()=>"undefined"!=typeof window,aS=()=>!aE();class aP extends q(){constructor(t,e){super(),(0,y._)(this,"provider",void 0),(0,y._)(this,"signer",void 0),(0,y._)(this,"options",void 0);let[r,a]=aI(t,e);this.signer=r,this.provider=a;try{this.options=rb.parse(e)}catch(n){console.error("invalid sdk options object passed, falling back to default options",n),this.options=rb.parse({})}}updateSignerOrProvider(t){let[e,r]=aI(t,this.options);this.signer=e,this.provider=r}isReadOnly(){return!B.E.isSigner(this.signer)}getSigner(){return this.signer}getProvider(){return this.provider}getSignerOrProvider(){return this.getSigner()||this.getProvider()}}function aI(t,e){let r,a;if(B.E.isSigner(t)&&(r=t,t.provider&&(a=t.provider)),null!=e&&e.readonlySettings&&(a=eO(e.readonlySettings.rpcUrl,e.readonlySettings.chainId)),!a){if(_.zt.isProvider(t))a=t;else if(!B.E.isSigner(t)){if("string"==typeof t){var n;a=eO(t,null==e?void 0:null===(n=e.readonlySettings)||void 0===n?void 0:n.chainId)}else a=S.yl(t)}}return a||(a=S.yl(),console.error("No provider found, using default provider on default chain!")),[r,a]}class az{constructor(t){(0,y._)(this,"contractWrapper",void 0),this.contractWrapper=t}encode(t,e){return this.contractWrapper.readContract.interface.encodeFunctionData(t,e)}decode(t,e){return this.contractWrapper.readContract.interface.decodeFunctionData(t,e)}}class aO{constructor(t,e,r){(0,y._)(this,"featureName",r7.name),(0,y._)(this,"contractWrapper",void 0),(0,y._)(this,"schema",void 0),(0,y._)(this,"storage",void 0),this.contractWrapper=t,this.schema=e,this.storage=r}parseOutputMetadata(t){return this.schema.output.parse(t)}parseInputMetadata(t){return this.schema.input.parse(t)}async get(){let t;if(this.supportsContractMetadata(this.contractWrapper)){let e=await this.contractWrapper.readContract.contractURI();e&&e.includes("://")&&(t=await this.storage.downloadJSON(e))}if(!t)try{let r;try{ai("name",this.contractWrapper)&&(r=await this.contractWrapper.readContract.name())}catch(a){}let n=await ae(this.contractWrapper.readContract.address,this.contractWrapper.getProvider(),this.storage);t={name:r||n.name,description:n.info.title}}catch(i){throw Error("Could not fetch contract metadata")}return this.parseOutputMetadata(t)}async set(t){let e=await this._parseAndUploadMetadata(t),r=this.contractWrapper;if(this.supportsContractMetadata(r)){let a=await r.sendTransaction("setContractURI",[e]);return{receipt:a,data:this.get}}throw new eD(r7)}async update(t){return await this.set({...await this.get(),...t})}async _parseAndUploadMetadata(t){let e=this.parseInputMetadata(t);return this.storage.upload(e)}supportsContractMetadata(t){return an(t,"ContractMetadata")}}class aB{constructor(t,e){(0,y._)(this,"featureName",r5.name),(0,y._)(this,"contractWrapper",void 0),(0,y._)(this,"roles",void 0),this.contractWrapper=t,this.roles=e}async getAll(){(0,L.Z)(this.roles.length,"this contract has no support for roles");let t={};for(let e of this.roles)t[e]=await this.get(e);return t}async get(t){(0,L.Z)(this.roles.includes(t),`this contract does not support the "${t}" role`);let e=this.contractWrapper;if(ai("getRoleMemberCount",e)&&ai("getRoleMember",e)){let r=rk(t),a=(await e.readContract.getRoleMemberCount(r)).toNumber();return await Promise.all(Array.from(Array(a).keys()).map(t=>e.readContract.getRoleMember(r,t)))}throw Error("Contract does not support enumerating roles. Please implement IPermissionsEnumerable to unlock this functionality.")}async setAll(t){let e=Object.keys(t);(0,L.Z)(e.length,"you must provide at least one role to set"),(0,L.Z)(e.every(t=>this.roles.includes(t)),"this contract does not support the given role");let r=await this.getAll(),a=[],n=e.sort(t=>"admin"===t?1:-1);for(let i=0;i<n.length;i++){let s=n[i],o=t[s]||[],c=r[s]||[],l=o.filter(t=>!c.includes(t)),d=c.filter(t=>!o.includes(t));if(l.length&&l.forEach(t=>{a.push(this.contractWrapper.readContract.interface.encodeFunctionData("grantRole",[rk(s),t]))}),d.length)for(let p=0;p<d.length;p++){let u=d[p],h=await this.getRevokeRoleFunctionName(u);a.push(this.contractWrapper.readContract.interface.encodeFunctionData(h,[rk(s),u]))}}return{receipt:await this.contractWrapper.multiCall(a)}}async verify(t,e){await Promise.all(t.map(async t=>{let r=await this.get(t);if(!r.map(t=>t.toLowerCase()).includes(e.toLowerCase()))throw new e_(e,t)}))}async grant(t,e){return(0,L.Z)(this.roles.includes(t),`this contract does not support the "${t}" role`),{receipt:await this.contractWrapper.sendTransaction("grantRole",[rk(t),e])}}async revoke(t,e){(0,L.Z)(this.roles.includes(t),`this contract does not support the "${t}" role`);let r=await this.getRevokeRoleFunctionName(e);return{receipt:await this.contractWrapper.sendTransaction(r,[rk(t),e])}}async getRevokeRoleFunctionName(t){let e=await this.contractWrapper.getSignerAddress();return e.toLowerCase()===t.toLowerCase()?"renounceRole":"revokeRole"}}class a_{constructor(t,e){(0,y._)(this,"featureName",rX.name),(0,y._)(this,"contractWrapper",void 0),(0,y._)(this,"metadata",void 0),this.contractWrapper=t,this.metadata=e}async getDefaultRoyaltyInfo(){let[t,e]=await this.contractWrapper.readContract.getDefaultRoyaltyInfo();return eg.parse({fee_recipient:t,seller_fee_basis_points:e})}async getTokenRoyaltyInfo(t){let[e,r]=await this.contractWrapper.readContract.getRoyaltyInfoForToken(t);return eg.parse({fee_recipient:e,seller_fee_basis_points:r})}async setDefaultRoyaltyInfo(t){let e=await this.metadata.get(),r=this.metadata.parseInputMetadata({...e,...t}),a=await this.metadata._parseAndUploadMetadata(r);if(ai("setContractURI",this.contractWrapper)){let n=[this.contractWrapper.readContract.interface.encodeFunctionData("setDefaultRoyaltyInfo",[r.fee_recipient,r.seller_fee_basis_points]),this.contractWrapper.readContract.interface.encodeFunctionData("setContractURI",[a])];return{receipt:await this.contractWrapper.multiCall(n),data:()=>this.getDefaultRoyaltyInfo()}}throw Error("Updating royalties requires implementing ContractMetadata in your contract to support marketplaces like OpenSea.")}async setTokenRoyaltyInfo(t,e){return{receipt:await this.contractWrapper.sendTransaction("setRoyaltyInfoForToken",[t,e.fee_recipient,e.seller_fee_basis_points]),data:()=>this.getDefaultRoyaltyInfo()}}}class aF{constructor(t){(0,y._)(this,"featureName",r0.name),(0,y._)(this,"contractWrapper",void 0),this.contractWrapper=t}async getRecipient(){return await this.contractWrapper.readContract.primarySaleRecipient()}async setRecipient(t){return{receipt:await this.contractWrapper.sendTransaction("setPrimarySaleRecipient",[t])}}}let aR={name:"Failed to load NFT metadata"};async function aM(t,e,r){let a;let n=e.replace("{id}",b.hexZeroPad(f.O$.from(t).toHexString(),32).slice(2));try{a=await r.downloadJSON(n)}catch(o){let i=e.replace("{id}",f.O$.from(t).toString());try{a=await r.downloadJSON(i)}catch(s){console.warn(`failed to get token metadata: ${JSON.stringify({tokenId:t.toString(),tokenUri:e})} -- falling back to default metadata`),a=aR}}return y.C.parse({id:f.O$.from(t).toString(),uri:e,...a})}async function ax(t,e,r,a){let n;let i=new F.CH(t,N,e),s=await i.supportsInterface(eE),o=await i.supportsInterface(eS);if(s){let c=new F.CH(t,tW,e);n=await c.tokenURI(r)}else if(o){let l=new F.CH(t,tA,e);n=await l.uri(r)}else throw Error("Contract must implement ERC 1155 or ERC 721.");if(!n)throw new eB;return aM(r,n,a)}async function aN(t,e){return"string"==typeof t?t:await e.upload(y.a.parse(t))}async function aD(t,e,r,a){if(void 0===t.find(t=>"string"!=typeof t))return t;if(void 0===t.find(t=>"object"!=typeof t)){let n=await e.uploadBatch(t.map(t=>y.a.parse(t)),{rewriteFileNames:{fileStartNumber:r||0},onProgress:null==a?void 0:a.onProgress});return n}throw Error("NFT metadatas must all be of the same type (all URI or all NFTMetadataInput)")}function a$(t){let e=t[0].substring(0,t[0].lastIndexOf("/"));for(let r=0;r<t.length;r++){let a=t[r].substring(0,t[r].lastIndexOf("/"));if(e!==a)throw Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${e}' but got '${a}'`)}return e.replace(/\/$/,"")+"/"}class aL{constructor(t,e,r,a){(0,y._)(this,"featureName",void 0),(0,y._)(this,"contractWrapper",void 0),(0,y._)(this,"storage",void 0),(0,y._)(this,"nextTokenIdToMintFn",void 0),this.featureName=r,this.nextTokenIdToMintFn=a,this.contractWrapper=t,this.storage=e}async createDelayedRevealBatch(t,e,r,a){let n;if(!r)throw Error("Password is required");let i=await this.storage.uploadBatch([y.a.parse(t)],{rewriteFileNames:{fileStartNumber:0}}),s=a$(i),o=await this.nextTokenIdToMintFn(),c=await this.storage.uploadBatch(e.map(t=>y.a.parse(t)),{onProgress:null==a?void 0:a.onProgress,rewriteFileNames:{fileStartNumber:o.toNumber()}}),l=a$(c),d=await this.contractWrapper.readContract.getBaseURICount(),p=await this.hashDelayRevealPasword(d,r),u=await this.contractWrapper.readContract.encryptDecrypt(v.Y0(l),p),h=await this.isLegacyContract();if(h)n=u;else{let m=await this.contractWrapper.getChainID(),g=z.keccak256(["bytes","bytes","uint256"],[v.Y0(l),p,m]);n=R.$.encode(["bytes","bytes32"],[u,g])}let f=await this.contractWrapper.sendTransaction("lazyMint",[c.length,s.endsWith("/")?s:`${s}/`,n]),w=this.contractWrapper.parseLogs("TokensLazyMinted",null==f?void 0:f.logs),b=w[0].args.startTokenId,C=w[0].args.endTokenId,W=[];for(let A=b;A.lte(C);A=A.add(1))W.push({id:A,receipt:f});return W}async reveal(t,e){if(!e)throw Error("Password is required");let r=await this.hashDelayRevealPasword(t,e);try{let a=await this.contractWrapper.callStatic().reveal(t,r);if(!a.includes("://")||!a.endsWith("/"))throw Error("invalid password")}catch(n){throw Error("invalid password")}return{receipt:await this.contractWrapper.sendTransaction("reveal",[t,r])}}async getBatchesToReveal(){let t=await this.contractWrapper.readContract.getBaseURICount();if(t.isZero())return[];let e=Array.from(Array(t.toNumber()).keys()),r=await Promise.all(e.map(t=>{if(ai("getBatchIdAtIndex",this.contractWrapper))return this.contractWrapper.readContract.getBatchIdAtIndex(t);if(ai("baseURIIndices",this.contractWrapper))return this.contractWrapper.readContract.baseURIIndices(t);throw Error("Contract does not have getBatchIdAtIndex or baseURIIndices.")})),a=r.slice(0,r.length-1),n=await Promise.all(Array.from([0,...a]).map(t=>this.getNftMetadata(t.toString()))),i=await this.isLegacyContract(),s=await Promise.all(Array.from([...r]).map(t=>i?this.getLegacyEncryptedData(t):this.contractWrapper.readContract.encryptedData(t))),o=s.map(t=>{if(!(b.hexDataLength(t)>0))return t;{if(i)return t;let e=R.$.decode(["bytes","bytes32"],t);return e[0]}});return n.map((t,e)=>({batchId:f.O$.from(e),batchUri:t.uri,placeholderMetadata:t})).filter((t,e)=>b.hexDataLength(o[e])>0)}async hashDelayRevealPasword(t,e){let r=await this.contractWrapper.getChainID(),a=this.contractWrapper.readContract.address;return z.keccak256(["string","uint256","uint256","address"],[e,r,t,a])}async getNftMetadata(t){return ax(this.contractWrapper.readContract.address,this.contractWrapper.getProvider(),t,this.storage)}async isLegacyContract(){if(ai("contractVersion",this.contractWrapper))try{let t=await this.contractWrapper.readContract.contractVersion();return t<=2}catch(e){}return!1}async getLegacyEncryptedData(t){let e=new F.CH(this.contractWrapper.readContract.address,tT,this.contractWrapper.getProvider()),r=await e.functions.encryptedBaseURI(t);return r.length>0?r[0]:"0x"}}let aj=[{name:"from",type:"address"},{name:"to",type:"address"},{name:"value",type:"uint256"},{name:"gas",type:"uint256"},{name:"nonce",type:"uint256"},{name:"data",type:"bytes"}],aq=[{name:"from",type:"address"},{name:"to",type:"address"},{name:"value",type:"uint256"},{name:"gas",type:"uint256"},{name:"nonce",type:"uint256"},{name:"data",type:"bytes"},{name:"chainid",type:"uint256"}],aU=[{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"uint256",name:"batchId",type:"uint256"}],name:"getNonce",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"}],aG={},aH={};async function aZ(t,e,r){let a=r.join("|"),n=aH[a],i=Date.now()-n>=2e3;if(!(a in aG)||i){let s=await t.functions[e](...r);Array.isArray(s)&&s.length>0?aG[a]=f.O$.from(s[0]):aG[a]=f.O$.from(s),aH[a]=Date.now()}let o=aG[a];return aG[a]=f.O$.from(aG[a]).add(1),o}let aV=P.parseUnits("31","gwei"),aJ=P.parseUnits("1","gwei");async function aY(t){let e=function(t){switch(t){case a.Polygon:return"https://gasstation-mainnet.matic.network/v2";case a.Mumbai:return"https://gasstation-mumbai.matic.today/v2"}}(t);try{let r=await (await G()(e)).json(),n=r.standard.maxPriorityFee;if(n>0){let i=parseFloat(n).toFixed(9);return P.parseUnits(i,"gwei")}}catch(s){console.error("failed to fetch gas",s)}return function(t){switch(t){case a.Polygon:return aV;case a.Mumbai:return aJ}}(t)}async function aQ(t,e,r,a){var n,i;let s=null==t?void 0:t.provider;if(!s)throw Error("missing provider");let o=M.E.getPayload(e,r,a),c="";if(null!=s&&null!==(n=s.provider)&&void 0!==n&&n.isWalletConnect)c=await s.send("eth_signTypedData",[(await t.getAddress()).toLowerCase(),JSON.stringify(o)]);else try{c=await t._signTypedData(e,r,a)}catch(l){if(null!=l&&null!==(i=l.message)&&void 0!==i&&i.includes("Method eth_signTypedData_v4 not supported"))c=await s.send("eth_signTypedData",[(await t.getAddress()).toLowerCase(),JSON.stringify(o)]);else throw l}return{payload:o,signature:b.joinSignature(b.splitSignature(c))}}let aK=[{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"}],aX=[{constant:!0,inputs:[],name:"DOMAIN_SEPARATOR",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],payable:!1,stateMutability:"view",type:"function"},{inputs:[],name:"getDomainSeperator",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"}],a0=[{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"nonces",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"address",name:"user",type:"address"}],name:"getNonce",outputs:[{internalType:"uint256",name:"nonce",type:"uint256"}],stateMutability:"view",type:"function"}];async function a1(t,e){let r=new F.CH(e,a0,t);try{return await r.nonces(await t.getAddress())}catch(a){return await r.getNonce(await t.getAddress())}}async function a2(t,e){let r=new F.CH(e,aX,t);try{return await r.DOMAIN_SEPARATOR()}catch(a){return await r.getDomainSeperator()}}async function a5(t,e){return new F.CH(e,aK,t).name()}async function a7(t,e){let r=await a2(t,e.verifyingContract),a={name:e.name,version:e.version,verifyingContract:e.verifyingContract,salt:b.hexZeroPad(f.O$.from(e.chainId).toHexString(),32)};return M.E.hashDomain(a)===r?a:e}async function a3(t,e,r,a,n,i,s){let o=await a7(t,{name:await a5(t,e),version:"1",chainId:await t.getChainId(),verifyingContract:e});s=s||(await a1(t,e)).toString(),i=i||x.Bz;let c={owner:r,spender:a,value:n,nonce:s,deadline:i},{signature:l}=await aQ(t,o,{Permit:[{name:"owner",type:"address"},{name:"spender",type:"address"},{name:"value",type:"uint256"},{name:"nonce",type:"uint256"},{name:"deadline",type:"uint256"}]},c);return{message:c,signature:l}}class a6 extends aP{constructor(t,e,r,a){super(t,a),(0,y._)(this,"isValidContract",!1),(0,y._)(this,"customOverrides",()=>({})),(0,y._)(this,"writeContract",void 0),(0,y._)(this,"readContract",void 0),(0,y._)(this,"abi",void 0),this.abi=r,this.writeContract=new F.CH(e,r,this.getSignerOrProvider()),this.readContract=this.writeContract.connect(this.getProvider())}updateSignerOrProvider(t){super.updateSignerOrProvider(t),this.writeContract=this.writeContract.connect(this.getSignerOrProvider()),this.readContract=this.writeContract.connect(this.getProvider())}async getChainID(){let t=this.getProvider(),{chainId:e}=await t.getNetwork();return e}async getSignerAddress(){let t=this.getSigner();if(!t)throw Error("This action requires a connected wallet to sign the transaction. Please pass a valid signer to the SDK.");return await t.getAddress()}callStatic(){return this.writeContract.callStatic}async getCallOverrides(){if(aE())return{};let t=await this.getProvider().getFeeData(),e=t.maxFeePerGas&&t.maxPriorityFeePerGas;if(!e)return{gasPrice:await this.getPreferredGasPrice()};{let r;let n=await this.getChainID(),i=await this.getProvider().getBlock("latest"),s=i&&i.baseFeePerGas?i.baseFeePerGas:P.parseUnits("1","gwei");r=n===a.Mumbai||n===a.Polygon?await aY(n):f.O$.from(t.maxPriorityFeePerGas);let o=this.getPreferredPriorityFee(r),c=s.mul(2),l=c.add(o);return{maxFeePerGas:l,maxPriorityFeePerGas:o}}}getPreferredPriorityFee(t){let e;let r=this.options.gasSettings.speed,a=this.options.gasSettings.maxPriceInGwei;switch(r){case"standard":e=f.O$.from(0);break;case"fast":e=t.div(100).mul(5);break;case"fastest":e=t.div(100).mul(10)}let n=t.add(e),i=P.parseUnits(a.toString(),"gwei"),s=P.parseUnits("2.5","gwei");return n.gt(i)&&(n=i),n.lt(s)&&(n=s),n}async getPreferredGasPrice(){let t;let e=await this.getProvider().getGasPrice(),r=this.options.gasSettings.speed,a=this.options.gasSettings.maxPriceInGwei,n=e;switch(r){case"standard":t=f.O$.from(1);break;case"fast":t=e.div(100).mul(5);break;case"fastest":t=e.div(100).mul(10)}n=n.add(t);let i=P.parseUnits(a.toString(),"gwei");return n.gt(i)&&(n=i),n}emitTransactionEvent(t,e){this.emit(n.Transaction,{status:t,transactionHash:e})}async multiCall(t){return this.sendTransaction("multicall",[t])}async estimateGas(t,e){return this.writeContract.estimateGas[t](...e)}withTransactionOverride(t){this.customOverrides=t}async call(t){let e;for(var r=arguments.length,a=Array(r>1?r-1:0),n=1;n<r;n++)a[n-1]=arguments[n];try{if(a.length>0&&"object"==typeof a[a.length-1]){let i=a[a.length-1];e=tJ.parse(i),a=a.slice(0,a.length-1)}}catch(s){}let o=r4(af.parse(this.abi)).filter(e=>e.name===t);if(!o.length)throw Error(`Function "${t}" not found in contract. Check your dashboard for the list of functions available`);let c=o.find(e=>e.name===t&&e.inputs.length===a.length);if(!c)throw Error(`Function "${t}" requires ${o[0].inputs.length} arguments, but ${a.length} were provided.
Expected function signature: ${o[0].signature}`);let l=`${t}(${c.inputs.map(t=>t.type).join()})`,d=l in this.readContract.functions?l:t;if("view"===c.stateMutability||"pure"===c.stateMutability)return this.readContract[d](...a);{let p=await this.sendTransaction(d,a,e);return{receipt:p}}}async sendTransaction(t,e,r){var a;if(r||(r=await this.getCallOverrides()),r={...r,...this.customOverrides()},this.customOverrides=()=>({}),null!==(a=this.options)&&void 0!==a&&a.gasless&&("openzeppelin"in this.options.gasless||"biconomy"in this.options.gasless)){if("multicall"===t&&Array.isArray(e[0])&&e[0].length>0){let n=await this.getSignerAddress();e[0]=e[0].map(t=>z.pack(["bytes","address"],[t,n]))}let i=this.getProvider(),s=await this.sendGaslessTransaction(t,e,r);this.emitTransactionEvent("submitted",s);let o=await i.waitForTransaction(s);return this.emitTransactionEvent("completed",s),o}{if(!this.isValidContract){let c=await this.getProvider().getCode(this.readContract.address);if(this.isValidContract="0x"!==c,!this.isValidContract)throw Error("The address you're trying to send a transaction to is not a smart contract. Make sure you are on the correct network and the contract address is correct")}let l=await this.sendTransactionByFunction(t,e,r);this.emitTransactionEvent("submitted",l.hash);let d=l.wait();return this.emitTransactionEvent("completed",l.hash),d}}async sendTransactionByFunction(t,e,r){let a=this.writeContract.functions[t];if(!a)throw Error(`invalid function: "${t.toString()}"`);try{return await a(...e,r)}catch(o){let n=await this.getProvider().getNetwork(),i=await this.getSignerAddress(),s=await this.readContract.address;throw await eL(o,n,i,s,this.readContract.interface)}}async sendGaslessTransaction(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],r=arguments.length>2?arguments[2]:void 0,a=this.getSigner();(0,L.Z)(a,"Cannot execute gasless transaction without valid signer");let n=await this.getChainID(),i=await this.getSignerAddress(),s=this.writeContract.address,o=(null==r?void 0:r.value)||0;if(f.O$.from(o).gt(0))throw Error("Cannot send native token value with gasless transaction");let c=this.writeContract.interface.encodeFunctionData(t,e),l=f.O$.from(0);try{let d=await this.readContract.estimateGas[t](...e);l=d.mul(2)}catch(p){}l.lt(1e5)&&(l=f.O$.from(5e5)),r.gasLimit&&f.O$.from(r.gasLimit).gt(l)&&(l=f.O$.from(r.gasLimit));let u={from:i,to:s,data:c,chainId:n,gasLimit:l,functionName:t.toString(),functionArgs:e,callOverrides:r};return await this.defaultGaslessSendFunction(u)}async signTypedData(t,e,r,a){this.emit(n.Signature,{status:"submitted",message:a,signature:""});let{signature:i}=await aQ(t,e,r,a);return this.emit(n.Signature,{status:"completed",message:a,signature:i}),i}parseLogs(t,e){if(!e||0===e.length)return[];let r=this.writeContract.interface.getEventTopic(t),a=e.filter(t=>t.topics.indexOf(r)>=0);return a.map(t=>this.writeContract.interface.parseLog(t))}async defaultGaslessSendFunction(t){return this.options.gasless&&"biconomy"in this.options.gasless?this.biconomySendFunction(t):this.defenderSendFunction(t)}async biconomySendFunction(t){var e,r,i,s;(0,L.Z)(this.options.gasless&&"biconomy"in this.options.gasless,"calling biconomySendFunction without biconomy");let o=this.getSigner(),c=this.getProvider();(0,L.Z)(o&&c,"signer and provider must be set");let l=new F.CH((i=t.chainId,s="biconomyForwarder",i===a.Hardhat?(0,C.d):ek[i][s]),aU,c),d=await aZ(l,"getNonce",[t.from,0]),p={from:t.from,to:t.to,token:C.d,txGas:t.gasLimit.toNumber(),tokenGasPrice:"0",batchId:0,batchNonce:d.toNumber(),deadline:Math.floor(Date.now()/1e3+((null===(e=this.options)||void 0===e?void 0:e.gasless)&&"biconomy"in this.options.gasless&&(null===(r=this.options.gasless.biconomy)||void 0===r?void 0:r.deadlineSeconds)||3600)),data:t.data},u=b.arrayify(z.keccak256(["address","address","address","uint256","uint256","uint256","uint256","uint256","bytes32"],[p.from,p.to,p.token,p.txGas,p.tokenGasPrice,p.batchId,p.batchNonce,p.deadline,I.keccak256(p.data)]));this.emit(n.Signature,{status:"submitted",message:u,signature:""});let h=await o.signMessage(u);this.emit(n.Signature,{status:"completed",message:u,signature:h});let m=await G()("https://api.biconomy.io/api/v2/meta-tx/native",{method:"POST",body:JSON.stringify({from:t.from,apiId:this.options.gasless.biconomy.apiId,params:[p,h],to:t.to,gasLimit:t.gasLimit.toHexString()}),headers:{"x-api-key":this.options.gasless.biconomy.apiKey,"Content-Type":"application/json;charset=utf-8"}});if(m.ok){let g=await m.json();if(!g.txHash)throw Error(`relay transaction failed: ${g.log}`);return g.txHash}throw Error(`relay transaction failed with status: ${m.status} (${m.statusText})`)}async defenderSendFunction(t){var e;let r,a,i,s;(0,L.Z)(this.options.gasless&&"openzeppelin"in this.options.gasless,"calling openzeppelin gasless transaction without openzeppelin config in the SDK options");let o=this.getSigner(),c=this.getProvider();(0,L.Z)(o,"provider is not set"),(0,L.Z)(c,"provider is not set");let l=this.options.gasless.openzeppelin.relayerForwarderAddress||(this.options.gasless.openzeppelin.useEOAForwarder?ek[t.chainId].openzeppelinForwarderEOA:ek[t.chainId].openzeppelinForwarder),d=new F.CH(l,H,c),p=await aZ(d,"getNonce",[t.from]);if(this.options.gasless.experimentalChainlessSupport?(r={name:"GSNv2 Forwarder",version:"0.0.1",verifyingContract:l},a={ForwardRequest:aq},i={from:t.from,to:t.to,value:f.O$.from(0).toString(),gas:f.O$.from(t.gasLimit).toString(),nonce:f.O$.from(p).toString(),data:t.data,chainid:f.O$.from(t.chainId).toString()}):(r={name:"GSNv2 Forwarder",version:"0.0.1",chainId:t.chainId,verifyingContract:l},a={ForwardRequest:aj},i={from:t.from,to:t.to,value:f.O$.from(0).toString(),gas:f.O$.from(t.gasLimit).toString(),nonce:f.O$.from(p).toString(),data:t.data}),this.emit(n.Signature,{status:"submitted",message:i,signature:""}),"approve"===t.functionName&&2===t.functionArgs.length){let u=t.functionArgs[0],h=t.functionArgs[1],{message:m,signature:g}=await a3(o,this.writeContract.address,t.from,u,h),{r:y,s:w,v}=b.splitSignature(g);i={to:this.readContract.address,owner:m.owner,spender:m.spender,value:f.O$.from(m.value).toString(),nonce:f.O$.from(m.nonce).toString(),deadline:f.O$.from(m.deadline).toString(),r:y,s:w,v},s=g}else{let{signature:C}=await aQ(o,r,a,i);s=C}let W="forward";null!==(e=i)&&void 0!==e&&e.owner&&(W="permit");let A=JSON.stringify({request:i,signature:s,forwarderAddress:l,type:W});this.emit(n.Signature,{status:"completed",message:i,signature:s});let T=await G()(this.options.gasless.openzeppelin.relayerUrl,{method:"POST",body:A});if(T.ok){let k=await T.json();if(!k.result)throw Error(`Relay transaction failed: ${k.message}`);let E=JSON.parse(k.result);return E.txHash}throw Error(`relay transaction failed with status: ${T.status} (${T.statusText})`)}}function a8(t){return t.toLowerCase()===tQ||t.toLowerCase()===C.d}async function a4(t,e,r){let a=await a9(t,r);return P.parseUnits(tG.parse(e),a.decimals)}async function a9(t,e){if(a8(e)){let r=await t.getNetwork(),a=tK[r.chainId];return{name:a.name,symbol:a.symbol,decimals:a.decimals}}{let n=new F.CH(e,tf,t),[i,s,o]=await Promise.all([n.name(),n.symbol(),n.decimals()]);return{name:i,symbol:s,decimals:o}}}async function nt(t,e,r){let a=await a9(t,e);return{...a,value:f.O$.from(r),displayValue:P.formatUnits(r,a.decimals)}}async function ne(t,e,r,a){if(a8(r))a.value=e;else{let n=t.getSigner(),i=t.getProvider(),s=new a6(n||i,r,J,{}),o=await t.getSignerAddress(),c=t.readContract.address,l=await s.readContract.allowance(o,c);return l.lt(e)&&await s.sendTransaction("approve",[c,e]),a}}async function nr(t,e,r,a,n){let i=t.getSigner(),s=t.getProvider(),o=new a6(i||s,e,J,{}),c=await t.getSignerAddress(),l=t.readContract.address,d=await o.readContract.allowance(c,l),p=f.O$.from(r).mul(f.O$.from(a)).div(P.parseUnits("1",n));d.lt(p)&&await o.sendTransaction("approve",[l,d.add(p)])}async function na(t,e,r){let a=t.getProvider(),n=new a6(a,e,J,{}),i=await t.getSignerAddress(),s=t.readContract.address,o=await n.readContract.allowance(i,s);return o.gte(r)}async function nn(t,e,r,a,n,i,s){let o=await n.getSignerAddress(),c=f.O$.from(0),l=[b.hexZeroPad([0],32)];try{if(!e.merkleRootHash.toString().startsWith(C.d)){let d=await ns(o,e.merkleRootHash.toString(),await r(),i);if(!d)throw Error("No claim found for this address");l=d.proof,c=P.parseUnits(d.maxClaimable,a)}}catch(p){if((null==p?void 0:p.message)==="No claim found for this address")throw p;console.warn("failed to check claim condition merkle root hash, continuing anyways",p)}let u=await n.getCallOverrides()||{},h=e.price,m=e.currencyAddress;return h.gt(0)&&(a8(m)?u.value=f.O$.from(h).mul(t).div(P.parseUnits("1",a)):s&&await nr(n,m,h,t,a)),{overrides:u,proofs:l,maxQuantityPerTransaction:c,price:h,currencyAddress:m}}async function ni(t,e,r){if(!e)return null;let a=e[t];if(a){let n=await r.downloadJSON(a);if(n.isShardedMerkleTree&&n.merkleRoot===t){let i=await rW.fromUri(a,r);return(null==i?void 0:i.getAllEntries())||null}{let s=t3.parse(n);if(t===s.merkleRoot)return s.claims.map(t=>({address:t.address,maxClaimable:t.maxClaimable}))}}return null}async function ns(t,e,r,a){if(!r)return null;let n=r[e];if(n){let i=await a.downloadJSON(n);if(i.isShardedMerkleTree&&i.merkleRoot===e){let s=await rW.fromShardedMerkleTreeInfo(i,a);return await s.getProof(t)}let o=t3.parse(i);if(e===o.merkleRoot)return o.claims.find(e=>e.address.toLowerCase()===t.toLowerCase())||null}return null}async function no(t,e,r){if(t>=r.length)throw Error(`Index out of bounds - got index: ${t} with ${r.length} conditions`);let a=r[t].currencyMetadata.decimals,n=r[t].price,i=P.formatUnits(n,a),s=t6.parse({...r[t],price:i,...e}),o=t4.parse({...s,price:n});return r.map((e,r)=>{let n;n=r===t?o:e;let i=P.formatUnits(n.price,a);return{...n,price:i}})}async function nc(t,e,r,a,n){let i=await ns(t,e,a,n);return i?{proof:i.proof,maxClaimable:P.parseUnits(i.maxClaimable,r)}:{proof:[],maxClaimable:f.O$.from(0)}}async function nl(t,e,r,a){let n=[],i=await Promise.all(t.map(async t=>{if(t.snapshot&&t.snapshot.length>0){let r=await rA(t5.parse(t.snapshot),e,a);n.push(r),t.merkleRootHash=r.merkleRoot}else t.merkleRootHash=b.hexZeroPad([0],32);return t})),s=t8.parse(i),o=(await Promise.all(s.map(t=>nd(t,e,r)))).sort((t,e)=>{let r=f.O$.from(t.startTimestamp),a=f.O$.from(e.startTimestamp);return r.eq(a)?0:r.gt(a)?1:-1});return{snapshotInfos:n,sortedConditions:o}}async function nd(t,e,r){let a,n;let i=t.currencyAddress===C.d?tQ:t.currencyAddress;return a="unlimited"===t.maxQuantity?x.Bz.toString():P.parseUnits(t.maxQuantity,e),n="unlimited"===t.quantityLimitPerTransaction?x.Bz.toString():P.parseUnits(t.quantityLimitPerTransaction,e),{startTimestamp:t.startTime,maxClaimableSupply:a,supplyClaimed:0,quantityLimitPerTransaction:n,waitTimeInSecondsBetweenClaims:t.waitInSeconds,pricePerToken:await a4(r,t.price,i),currency:i,merkleRoot:t.merkleRootHash}}async function np(t,e,r,a,n,i){let s=await nt(r,t.currency,t.pricePerToken),o=nu(t.maxClaimableSupply,e),c=nu(t.quantityLimitPerTransaction,e),l=nu(f.O$.from(t.maxClaimableSupply).sub(t.supplyClaimed),e),d=nu(t.supplyClaimed,e);return t4.parse({startTime:t.startTimestamp,maxQuantity:o,currentMintSupply:d,availableSupply:l,quantityLimitPerTransaction:c,waitInSeconds:t.waitTimeInSecondsBetweenClaims.toString(),price:f.O$.from(t.pricePerToken),currency:t.currency,currencyAddress:t.currency,currencyMetadata:s,merkleRootHash:t.merkleRoot,snapshot:i?await ni(t.merkleRoot,a,n):void 0})}function nu(t,e){return t.toString()===x.Bz.toString()?"unlimited":P.formatUnits(t,e)}async function nh(t,e,r,a,n){let i={},s=a||tQ,o=await a4(t.getProvider(),e,s),c=o.mul(r);return c.gt(0)&&(s===tQ?i={value:c}:s!==tQ&&n&&await nr(t,s,c,r,0)),i}(p=i||(i={}))[p.Direct=0]="Direct",p[p.Auction=1]="Auction",(u=s||(s={}))[u.Pending=0]="Pending",u[u.Active=1]="Active",u[u.Canceled=2]="Canceled",u[u.Defeated=3]="Defeated",u[u.Succeeded=4]="Succeeded",u[u.Queued=5]="Queued",u[u.Expired=6]="Expired",u[u.Executed=7]="Executed",(h=o||(o={}))[h.Against=0]="Against",h[h.For=1]="For",h[h.Abstain=2]="Abstain",(m=c||(c={})).NotEnoughSupply="There is not enough supply to claim.",m.AddressNotAllowed="This address is not on the allowlist.",m.WaitBeforeNextClaimTransaction="Not enough time since last claim transaction. Please wait.",m.AlreadyClaimed="You have already claimed the token.",m.NotEnoughTokens="There are not enough tokens in the wallet to pay for the claim.",m.NoActiveClaimPhase="There is no active claim phase at the moment. Please check back in later.",m.NoClaimConditionSet="There is no claim condition set.",m.NoWallet="No wallet connected.",m.Unknown="No claim conditions found.";class nm{constructor(t,e,r){(0,y._)(this,"contractWrapper",void 0),(0,y._)(this,"metadata",void 0),(0,y._)(this,"storage",void 0),this.storage=r,this.contractWrapper=t,this.metadata=e}async getActive(t){let e=await this.get(),r=await this.metadata.get();return await np(e,await this.getTokenDecimals(),this.contractWrapper.getProvider(),r.merkle||{},this.storage,(null==t?void 0:t.withAllowList)||!1)}async get(){if(this.isSinglePhaseDropContract(this.contractWrapper))return await this.contractWrapper.readContract.claimCondition();if(this.isMultiPhaseDropContract(this.contractWrapper)){let t=await this.contractWrapper.readContract.getActiveClaimConditionId();return await this.contractWrapper.readContract.getClaimConditionById(t)}throw Error("Contract does not support claim conditions")}async getAll(t){if(!this.isMultiPhaseDropContract(this.contractWrapper))return[await this.getActive(t)];{let e=await this.contractWrapper.readContract.claimCondition(),r=e.currentStartId.toNumber(),a=e.count.toNumber(),n=[];for(let i=r;i<r+a;i++)n.push(await this.contractWrapper.readContract.getClaimConditionById(i));let s=await this.metadata.get(),o=await this.getTokenDecimals();return Promise.all(n.map(e=>np(e,o,this.contractWrapper.getProvider(),s.merkle,this.storage,(null==t?void 0:t.withAllowList)||!1)))}}async canClaim(t,e){return 0===(await this.getClaimIneligibilityReasons(t,e)).length}async getClaimIneligibilityReasons(t,e){let r,a;let n=[],i=await this.getTokenDecimals(),s=P.parseUnits(tG.parse(t),i);if(void 0===e)try{e=await this.contractWrapper.getSignerAddress()}catch(o){console.warn("failed to get signer address",o)}if(!e)return[c.NoWallet];try{a=await this.getActive()}catch(l){if(eU(l,"!CONDITION")||eU(l,"no active mint condition"))return n.push(c.NoClaimConditionSet),n;return console.warn("failed to get active claim condition",l),n.push(c.Unknown),n}if("unlimited"!==a.availableSupply){let d=P.parseUnits(a.availableSupply,i);d.lt(s)&&n.push(c.NotEnoughSupply)}let p=b.stripZeros(a.merkleRootHash);if(p.length>0){let u=a.merkleRootHash.toString(),h=await this.metadata.get(),m=await nc(e,u,await this.getTokenDecimals(),h.merkle,this.storage);try{let g;if(this.isMultiPhaseDropContract(this.contractWrapper)?(r=await this.contractWrapper.readContract.getActiveClaimConditionId(),[g]=await this.contractWrapper.readContract.verifyClaimMerkleProof(r,e,t,m.proof,m.maxClaimable)):this.isSinglePhaseDropContract(this.contractWrapper)&&([g]=await this.contractWrapper.readContract.verifyClaimMerkleProof(e,t,{proof:m.proof,maxQuantityInAllowlist:m.maxClaimable})),!g)return n.push(c.AddressNotAllowed),n}catch(y){return n.push(c.AddressNotAllowed),n}}let[w,v]=[f.O$.from(0),f.O$.from(0)];this.isMultiPhaseDropContract(this.contractWrapper)?(r=await this.contractWrapper.readContract.getActiveClaimConditionId(),[w,v]=await this.contractWrapper.readContract.getClaimTimestamp(r,e)):this.isSinglePhaseDropContract(this.contractWrapper)&&([w,v]=await this.contractWrapper.readContract.getClaimTimestamp(e));let C=f.O$.from(Date.now()).div(1e3);if(w.gt(0)&&C.lt(v)&&(v.eq(x.Bz)?n.push(c.AlreadyClaimed):n.push(c.WaitBeforeNextClaimTransaction)),a.price.gt(0)&&aS()){let W=a.price.mul(f.O$.from(t)),A=this.contractWrapper.getProvider();if(a8(a.currencyAddress)){let T=await A.getBalance(e);T.lt(W)&&n.push(c.NotEnoughTokens)}else{let k=new a6(A,a.currencyAddress,J,{}),E=await k.readContract.balanceOf(e);E.lt(W)&&n.push(c.NotEnoughTokens)}}return n}async set(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],r=t;if(this.isSinglePhaseDropContract(this.contractWrapper)){if(e=!0,0===t.length)r=[{startTime:new Date(0),currencyAddress:tQ,price:0,maxQuantity:0,quantityLimitPerTransaction:0,waitInSeconds:0,merkleRootHash:b.hexZeroPad([0],32),snapshot:[]}];else if(t.length>1)throw Error("Single phase drop contract cannot have multiple claim conditions, only one is allowed")}let{snapshotInfos:a,sortedConditions:n}=await nl(r,await this.getTokenDecimals(),this.contractWrapper.getProvider(),this.storage),i={};a.forEach(t=>{i[t.merkleRoot]=t.snapshotUri});let s=await this.metadata.get(),o=[];if(!tv()(s.merkle,i)){let c=this.metadata.parseInputMetadata({...s,merkle:i}),l=await this.metadata._parseAndUploadMetadata(c);if(ai("setContractURI",this.contractWrapper))o.push(this.contractWrapper.readContract.interface.encodeFunctionData("setContractURI",[l]));else throw Error("Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.")}let d=this.contractWrapper;if(this.isSinglePhaseDropContract(d))o.push(d.readContract.interface.encodeFunctionData("setClaimConditions",[n[0],e]));else if(this.isMultiPhaseDropContract(d))o.push(d.readContract.interface.encodeFunctionData("setClaimConditions",[n,e]));else throw Error("Contract does not support claim conditions");return{receipt:await this.contractWrapper.multiCall(o)}}async update(t,e){let r=await this.getAll(),a=await no(t,e,r);return await this.set(a)}async getTokenDecimals(){return an(this.contractWrapper,"ERC20")?this.contractWrapper.readContract.decimals():Promise.resolve(0)}async prepareClaim(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return nn(t,await this.getActive(),async()=>(await this.metadata.get()).merkle,r,this.contractWrapper,this.storage,e)}isSinglePhaseDropContract(t){return!ai("getClaimConditionById",t)}isMultiPhaseDropContract(t){return ai("getClaimConditionById",t)}}class ng{constructor(t,e,r){(0,y._)(this,"contractWrapper",void 0),(0,y._)(this,"metadata",void 0),(0,y._)(this,"storage",void 0),this.storage=r,this.contractWrapper=t,this.metadata=e}async getActive(t,e){let r=await this.get(t),a=await this.metadata.get();return await np(r,0,this.contractWrapper.getProvider(),a.merkle,this.storage,(null==e?void 0:e.withAllowList)||!1)}async get(t){if(this.isSinglePhaseDropContract(this.contractWrapper))return await this.contractWrapper.readContract.claimCondition(t);if(this.isMultiPhaseDropContract(this.contractWrapper)){let e=await this.contractWrapper.readContract.getActiveClaimConditionId(t);return await this.contractWrapper.readContract.getClaimConditionById(t,e)}throw Error("Contract does not support claim conditions")}async getAll(t,e){if(!this.isMultiPhaseDropContract(this.contractWrapper))return[await this.getActive(t)];{let r=await this.contractWrapper.readContract.claimCondition(t),a=r.currentStartId.toNumber(),n=r.count.toNumber(),i=[];for(let s=a;s<a+n;s++)i.push(await this.contractWrapper.readContract.getClaimConditionById(t,s));let o=await this.metadata.get();return Promise.all(i.map(t=>np(t,0,this.contractWrapper.getProvider(),o.merkle,this.storage,(null==e?void 0:e.withAllowList)||!1)))}}async canClaim(t,e,r){return 0===(await this.getClaimIneligibilityReasons(t,e,r)).length}async getClaimIneligibilityReasons(t,e,r){let a,n;let i=[];if(void 0===r)try{r=await this.contractWrapper.getSignerAddress()}catch(s){console.warn("failed to get signer address",s)}if(!r)return[c.NoWallet];try{n=await this.getActive(t)}catch(o){if(eU(o,"!CONDITION")||eU(o,"no active mint condition"))return i.push(c.NoClaimConditionSet),i;return i.push(c.Unknown),i}"unlimited"!==n.availableSupply&&f.O$.from(n.availableSupply).lt(e)&&i.push(c.NotEnoughSupply);let l=b.stripZeros(n.merkleRootHash);if(l.length>0){let d=n.merkleRootHash.toString(),p=await this.metadata.get(),u=await nc(r,d,0,p.merkle,this.storage);try{let h;if(this.isMultiPhaseDropContract(this.contractWrapper)?(a=await this.contractWrapper.readContract.getActiveClaimConditionId(t),[h]=await this.contractWrapper.readContract.verifyClaimMerkleProof(a,r,t,e,u.proof,u.maxClaimable)):this.isSinglePhaseDropContract(this.contractWrapper)&&([h]=await this.contractWrapper.readContract.verifyClaimMerkleProof(t,r,e,{proof:u.proof,maxQuantityInAllowlist:u.maxClaimable})),!h)return i.push(c.AddressNotAllowed),i}catch(m){return i.push(c.AddressNotAllowed),i}}let[g,y]=[f.O$.from(0),f.O$.from(0)];this.isMultiPhaseDropContract(this.contractWrapper)?(a=await this.contractWrapper.readContract.getActiveClaimConditionId(t),[g,y]=await this.contractWrapper.readContract.getClaimTimestamp(t,a,r)):this.isSinglePhaseDropContract(this.contractWrapper)&&([g,y]=await this.contractWrapper.readContract.getClaimTimestamp(t,r));let w=f.O$.from(Date.now()).div(1e3);if(g.gt(0)&&w.lt(y)&&(y.eq(x.Bz)?i.push(c.AlreadyClaimed):i.push(c.WaitBeforeNextClaimTransaction)),n.price.gt(0)&&aS()){let v=n.price.mul(e),C=this.contractWrapper.getProvider();if(a8(n.currencyAddress)){let W=await C.getBalance(r);W.lt(v)&&i.push(c.NotEnoughTokens)}else{let A=new a6(C,n.currencyAddress,J,{}),T=await A.readContract.balanceOf(r);T.lt(v)&&i.push(c.NotEnoughTokens)}}return i}async set(t,e){let r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return this.setBatch([{tokenId:t,claimConditions:e}],r)}async setBatch(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],r={},a=await Promise.all(t.map(async t=>{let{tokenId:a,claimConditions:n}=t,i=n;if(this.isSinglePhaseDropContract(this.contractWrapper)){if(e=!0,0===n.length)i=[{startTime:new Date(0),currencyAddress:tQ,price:0,maxQuantity:0,quantityLimitPerTransaction:0,waitInSeconds:0,merkleRootHash:b.hexZeroPad([0],32),snapshot:[]}];else if(n.length>1)throw Error("Single phase drop contract cannot have multiple claim conditions, only one is allowed")}let{snapshotInfos:s,sortedConditions:o}=await nl(i,0,this.contractWrapper.getProvider(),this.storage);return s.forEach(t=>{r[t.merkleRoot]=t.snapshotUri}),{tokenId:a,sortedConditions:o}})),n=await this.metadata.get(),i=[];for(let s of Object.keys(n.merkle||{}))r[s]=n.merkle[s];if(!tv()(n.merkle,r)){let o=this.metadata.parseInputMetadata({...n,merkle:r}),c=await this.metadata._parseAndUploadMetadata(o);if(ai("setContractURI",this.contractWrapper))i.push(this.contractWrapper.readContract.interface.encodeFunctionData("setContractURI",[c]));else throw Error("Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.")}return a.forEach(t=>{let{tokenId:r,sortedConditions:a}=t;if(this.isSinglePhaseDropContract(this.contractWrapper))i.push(this.contractWrapper.readContract.interface.encodeFunctionData("setClaimConditions",[r,a[0],e]));else if(this.isMultiPhaseDropContract(this.contractWrapper))i.push(this.contractWrapper.readContract.interface.encodeFunctionData("setClaimConditions",[r,a,e]));else throw Error("Contract does not support claim conditions")}),{receipt:await this.contractWrapper.multiCall(i)}}async update(t,e,r){let a=await this.getAll(t),n=await no(e,r,a);return await this.set(t,n)}async prepareClaim(t,e,r){return nn(e,await this.getActive(t),async()=>(await this.metadata.get()).merkle,0,this.contractWrapper,this.storage,r)}isSinglePhaseDropContract(t){return!ai("getClaimConditionById",t)}isMultiPhaseDropContract(t){return ai("getClaimConditionById",t)}}class ny{constructor(t){(0,y._)(this,"events",void 0),this.events=t}async getAllClaimerAddresses(t){let e=(await this.events.getEvents("TokensClaimed")).filter(e=>!!(e.data&&f.O$.isBigNumber(e.data.tokenId))&&e.data.tokenId.eq(t));return Array.from(new Set(e.filter(t=>{var e;return"string"==typeof(null===(e=t.data)||void 0===e?void 0:e.claimer)}).map(t=>t.data.claimer)))}}class nf{constructor(t,e){(0,y._)(this,"featureName",rS.name),(0,y._)(this,"erc20",void 0),(0,y._)(this,"contractWrapper",void 0),this.erc20=t,this.contractWrapper=e}async tokens(t){return{receipt:await this.contractWrapper.sendTransaction("burn",[await this.erc20.normalizeAmount(t)])}}async from(t,e){return{receipt:await this.contractWrapper.sendTransaction("burnFrom",[t,await this.erc20.normalizeAmount(e)])}}}class nw{constructor(t,e,r){(0,y._)(this,"featureName",rE.name),(0,y._)(this,"conditions",void 0),(0,y._)(this,"contractWrapper",void 0),(0,y._)(this,"erc20",void 0),(0,y._)(this,"storage",void 0),this.erc20=t,this.contractWrapper=e,this.storage=r;let a=new aO(this.contractWrapper,ah,this.storage);this.conditions=new nm(this.contractWrapper,a,this.storage)}async to(t,e){let r=!(arguments.length>2)||void 0===arguments[2]||arguments[2],a=arguments.length>3?arguments[3]:void 0,n=await this.erc20.normalizeAmount(e),i=a;if(this.conditions&&!a&&(i=await this.conditions.prepareClaim(n,r,await this.contractWrapper.readContract.decimals())),!i)throw Error("Claim verification Data is required - either pass it in as 'claimData' or set claim conditions via 'conditions.set()'");let s=await this.contractWrapper.sendTransaction("claim",[t,n,i.currencyAddress,i.price,i.proofs,i.maxQuantityPerTransaction],i.overrides);return{receipt:s}}}class nb{constructor(t,e,r){(0,y._)(this,"claim",void 0),(0,y._)(this,"contractWrapper",void 0),(0,y._)(this,"erc20",void 0),(0,y._)(this,"storage",void 0),this.erc20=t,this.contractWrapper=e,this.storage=r,this.claim=new nw(this.erc20,this.contractWrapper,this.storage)}}class nv{constructor(t,e){(0,y._)(this,"featureName",rI.name),(0,y._)(this,"contractWrapper",void 0),(0,y._)(this,"erc20",void 0),this.erc20=t,this.contractWrapper=e}async to(t){let e=[];for(let r of t)e.push(this.contractWrapper.readContract.interface.encodeFunctionData("mintTo",[r.toAddress,await this.erc20.normalizeAmount(r.amount)]));return{receipt:await this.contractWrapper.multiCall(e)}}}class nC{constructor(t,e){(0,y._)(this,"featureName",rz.name),(0,y._)(this,"contractWrapper",void 0),(0,y._)(this,"erc20",void 0),(0,y._)(this,"batch",void 0),this.erc20=t,this.contractWrapper=e,this.batch=this.detectErc20BatchMintable()}async to(t,e){return{receipt:await this.contractWrapper.sendTransaction("mintTo",[t,await this.erc20.normalizeAmount(e)])}}detectErc20BatchMintable(){if(an(this.contractWrapper,"ERC20BatchMintable"))return new nv(this.erc20,this.contractWrapper)}}class nW{constructor(t,e){(0,y._)(this,"featureName",rP.name),(0,y._)(this,"contractWrapper",void 0),(0,y._)(this,"roles",void 0),this.contractWrapper=t,this.roles=e}async mint(t){let e=t.payload,r=t.signature,a=await this.mapPayloadToContractStruct(e),n=await this.contractWrapper.getCallOverrides();return await ne(this.contractWrapper,f.O$.from(a.price),e.currencyAddress,n),{receipt:await this.contractWrapper.sendTransaction("mintWithSignature",[a,r],n)}}async mintBatch(t){let e=await Promise.all(t.map(async t=>{let e=await this.mapPayloadToContractStruct(t.payload),r=t.signature,a=t.payload.price;if(f.O$.from(a).gt(0))throw Error("Can only batch free mints. For mints with a price, use regular mint()");return{message:e,signature:r}})),r=e.map(t=>this.contractWrapper.readContract.interface.encodeFunctionData("mintWithSignature",[t.message,t.signature]));return{receipt:await this.contractWrapper.multiCall(r)}}async verify(t){let e=t.payload,r=t.signature,a=await this.mapPayloadToContractStruct(e),n=await this.contractWrapper.readContract.verify(a,r);return n[0]}async generate(t){return(await this.generateBatch([t]))[0]}async generateBatch(t){var e;await (null===(e=this.roles)||void 0===e?void 0:e.verify(["minter"],await this.contractWrapper.getSignerAddress()));let r=t.map(t=>et.parse(t)),a=await this.contractWrapper.getChainID(),n=this.contractWrapper.getSigner();(0,L.Z)(n,"No signer available");let i=await this.contractWrapper.readContract.name();return await Promise.all(r.map(async t=>{let e=ee.parse(t),r=await this.contractWrapper.signTypedData(n,{name:i,version:"1",chainId:a,verifyingContract:this.contractWrapper.readContract.address},{MintRequest:el},await this.mapPayloadToContractStruct(e));return{payload:e,signature:r.toString()}}))}async mapPayloadToContractStruct(t){let e=await a4(this.contractWrapper.getProvider(),t.price,t.currencyAddress),r=P.parseUnits(t.quantity,await this.contractWrapper.readContract.decimals());return{to:t.to,primarySaleRecipient:t.primarySaleRecipient,quantity:r,price:e,currency:t.currencyAddress,validityEndTimestamp:t.mintEndTime,validityStartTimestamp:t.mintStartTime,uid:t.uid}}}class nA{get chainId(){return this._chainId}constructor(t,e,r){(0,y._)(this,"featureName",rO.name),(0,y._)(this,"mintable",void 0),(0,y._)(this,"burnable",void 0),(0,y._)(this,"droppable",void 0),(0,y._)(this,"signatureMintable",void 0),(0,y._)(this,"contractWrapper",void 0),(0,y._)(this,"storage",void 0),(0,y._)(this,"_chainId",void 0),this.contractWrapper=t,this.storage=e,this.mintable=this.detectErc20Mintable(),this.burnable=this.detectErc20Burnable(),this.droppable=this.detectErc20Droppable(),this.signatureMintable=this.detectErc20SignatureMintable(),this._chainId=r}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.readContract.address}async get(){return await a9(this.contractWrapper.getProvider(),this.getAddress())}async balance(){return await this.balanceOf(await this.contractWrapper.getSignerAddress())}async balanceOf(t){return this.getValue(await this.contractWrapper.readContract.balanceOf(t))}async totalSupply(){return await this.getValue(await this.contractWrapper.readContract.totalSupply())}async allowance(t){return await this.allowanceOf(await this.contractWrapper.getSignerAddress(),t)}async allowanceOf(t,e){return await this.getValue(await this.contractWrapper.readContract.allowance(t,e))}async transfer(t,e){return{receipt:await this.contractWrapper.sendTransaction("transfer",[t,await this.normalizeAmount(e)])}}async transferFrom(t,e,r){return{receipt:await this.contractWrapper.sendTransaction("transferFrom",[t,e,await this.normalizeAmount(r)])}}async setAllowance(t,e){return{receipt:await this.contractWrapper.sendTransaction("approve",[t,await this.normalizeAmount(e)])}}async transferBatch(t){let e=await Promise.all(t.map(async t=>{let e=await this.normalizeAmount(t.amount);return this.contractWrapper.readContract.interface.encodeFunctionData("transfer",[t.toAddress,e])}));await this.contractWrapper.multiCall(e)}async mint(t){return this.mintTo(await this.contractWrapper.getSignerAddress(),t)}async mintTo(t,e){return aa(this.mintable,rz).to(t,e)}async mintBatchTo(t){var e;return aa(null===(e=this.mintable)||void 0===e?void 0:e.batch,rI).to(t)}async burn(t){return aa(this.burnable,rS).tokens(t)}async burnFrom(t,e){return aa(this.burnable,rS).from(t,e)}async claim(t){let e=!(arguments.length>1)||void 0===arguments[1]||arguments[1],r=arguments.length>2?arguments[2]:void 0;return this.claimTo(await this.contractWrapper.getSignerAddress(),t,e,r)}async claimTo(t,e){var r;let a=!(arguments.length>2)||void 0===arguments[2]||arguments[2],n=arguments.length>3?arguments[3]:void 0;return aa(null===(r=this.droppable)||void 0===r?void 0:r.claim,rE).to(t,e,a,n)}get claimConditions(){var t;return aa(null===(t=this.droppable)||void 0===t?void 0:t.claim,rE).conditions}get signature(){return aa(this.signatureMintable,rP)}async normalizeAmount(t){let e=await this.contractWrapper.readContract.decimals();return P.parseUnits(tG.parse(t),e)}async getValue(t){return await nt(this.contractWrapper.getProvider(),this.getAddress(),f.O$.from(t))}detectErc20Mintable(){if(an(this.contractWrapper,"ERC20"))return new nC(this,this.contractWrapper)}detectErc20Burnable(){if(an(this.contractWrapper,"ERC20Burnable"))return new nf(this,this.contractWrapper)}detectErc20Droppable(){if(an(this.contractWrapper,"ERC20ClaimableWithConditions"))return new nb(this,this.contractWrapper,this.storage)}detectErc20SignatureMintable(){if(an(this.contractWrapper,"ERC20SignatureMintable"))return new nW(this.contractWrapper)}}class nT{constructor(t,e){(0,y._)(this,"events",void 0),(0,y._)(this,"contractWrapper",void 0),this.contractWrapper=t,this.events=e}async getAllHolderBalances(){let t=await this.events.getEvents("Transfer"),e=t.map(t=>t.data),r={};return e.forEach(t=>{let e=null==t?void 0:t.from,a=null==t?void 0:t.to,n=null==t?void 0:t.value;e!==C.d&&(e in r||(r[e]=f.O$.from(0)),r[e]=r[e].sub(n)),a!==C.d&&(a in r||(r[a]=f.O$.from(0)),r[a]=r[a].add(n))}),Promise.all(Object.keys(r).map(async t=>({holder:t,balance:await nt(this.contractWrapper.getProvider(),this.contractWrapper.readContract.address,r[t])})))}}class nk{get chainId(){return this._chainId}constructor(t,e,r){(0,y._)(this,"contractWrapper",void 0),(0,y._)(this,"storage",void 0),(0,y._)(this,"erc20",void 0),(0,y._)(this,"_chainId",void 0),this.contractWrapper=t,this.storage=e,this.erc20=new nA(this.contractWrapper,this.storage,r),this._chainId=r}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.readContract.address}async get(){return this.erc20.get()}async balance(){return await this.erc20.balance()}async balanceOf(t){return this.erc20.balanceOf(t)}async totalSupply(){return await this.erc20.totalSupply()}async allowance(t){return await this.erc20.allowance(t)}async allowanceOf(t,e){return await this.erc20.allowanceOf(t,e)}async transfer(t,e){return this.erc20.transfer(t,e)}async transferFrom(t,e,r){return this.erc20.transferFrom(t,e,r)}async setAllowance(t,e){return this.erc20.setAllowance(t,e)}async transferBatch(t){return this.erc20.transferBatch(t)}}class nE{constructor(t){(0,y._)(this,"featureName",rB.name),(0,y._)(this,"contractWrapper",void 0),this.contractWrapper=t}async token(t){return{receipt:await this.contractWrapper.sendTransaction("burn",[t])}}}class nS{constructor(t){(0,y._)(this,"contractWrapper",void 0),this.contractWrapper=t}async gasCostOf(t,e){let r=await this.contractWrapper.getPreferredGasPrice(),a=await this.contractWrapper.estimateGas(t,e);return P.formatEther(a.mul(r))}async gasLimitOf(t,e){return this.contractWrapper.estimateGas(t,e)}async currentGasPriceInGwei(){let t=await this.contractWrapper.getProvider().getGasPrice();return P.formatUnits(t,"gwei")}}class nP{static make(t){return new nP(t)}constructor(t){(0,y._)(this,"contractWrapper",void 0),(0,y._)(this,"functionName",void 0),(0,y._)(this,"args",void 0),(0,y._)(this,"overrides",void 0),(0,y._)(this,"encoder",void 0),(0,y._)(this,"estimator",void 0),this.contractWrapper=t.contractWrapper,this.functionName=t.functionName,this.args=t.args||[],this.overrides=t.overrides,this.encoder=new az(this.contractWrapper),this.estimator=new nS(this.contractWrapper)}overrideGasLimit(t){return this.overrides={...this.overrides,gasLimit:t},this}overrideGasPrice(t){return this.overrides={...this.overrides,gasPrice:t},this}overrideNonce(t){return this.overrides={...this.overrides,nonce:t},this}overrideValue(t){return this.overrides={...this.overrides,value:t},this}async estimateGasLimit(){return await this.estimator.gasLimitOf(this.functionName,this.args)}async estimateGasCostInEther(){return await this.estimator.gasCostOf(this.functionName,this.args)}async encodeFunctionData(){return this.encoder.encode(this.functionName,this.args)}async submit(){return await this.contractWrapper.sendTransactionByFunction(this.functionName,this.args,this.overrides||{})}async execute(){let t=await this.contractWrapper.sendTransaction(this.functionName,this.args,this.overrides||{});return{receipt:t}}}class nI{constructor(t,e){(0,y._)(this,"featureName",rR.name),(0,y._)(this,"erc721",void 0),(0,y._)(this,"contractWrapper",void 0),this.erc721=t,this.contractWrapper=e}async getClaimTransaction(t,e,r){let a={};return r&&r.pricePerToken&&(a=await nh(this.contractWrapper,r.pricePerToken,e,r.currencyAddress,r.checkERC20Allowance)),nP.make({contractWrapper:this.contractWrapper,functionName:"claim",args:[t,e],overrides:a})}async to(t,e,r){let a=await this.getClaimTransaction(t,e,r),{receipt:n}=await a.execute(),i=this.contractWrapper.parseLogs("TokensClaimed",null==n?void 0:n.logs),s=i[0].args.startTokenId,o=s.add(e),c=[];for(let l=s;l.lt(o);l=l.add(1))c.push({id:l,receipt:n,data:()=>this.erc721.get(l)});return c}}class nz{constructor(t,e,r){(0,y._)(this,"featureName",rF.name),(0,y._)(this,"conditions",void 0),(0,y._)(this,"contractWrapper",void 0),(0,y._)(this,"erc721",void 0),(0,y._)(this,"storage",void 0),this.erc721=t,this.contractWrapper=e,this.storage=r;let a=new aO(this.contractWrapper,ah,this.storage);this.conditions=new nm(this.contractWrapper,a,this.storage)}async getClaimTransaction(t,e,r){if(null!=r&&r.pricePerToken)throw Error("In ERC721ClaimableWithConditions, price per token is be set via claim conditions by calling `contract.erc721.claimConditions.set()`");let a=await this.conditions.prepareClaim(e,(null==r?void 0:r.checkERC20Allowance)===void 0||r.checkERC20Allowance);return nP.make({contractWrapper:this.contractWrapper,functionName:"claim",args:await this.getArgs(t,e,a),overrides:a.overrides})}async to(t,e,r){let a=await this.getClaimTransaction(t,e,r),{receipt:n}=await a.execute(),i=this.contractWrapper.parseLogs("TokensClaimed",null==n?void 0:n.logs),s=i[0].args.startTokenId,o=s.add(e),c=[];for(let l=s;l.lt(o);l=l.add(1))c.push({id:l,receipt:n,data:()=>this.erc721.get(l)});return c}async getArgs(t,e,r){let a=await this.isLegacyNFTContract();return a?[t,e,r.currencyAddress,r.price,r.proofs,r.maxQuantityPerTransaction]:[t,e,r.currencyAddress,r.price,{proof:r.proofs,maxQuantityInAllowlist:r.maxQuantityPerTransaction},v.Y0("")]}async isLegacyNFTContract(){if(!ai("contractType",this.contractWrapper))return!1;try{let t=v.ZN(await this.contractWrapper.readContract.contractType());return t.includes("DropERC721")}catch(e){return!1}}}class nO{constructor(t,e,r){(0,y._)(this,"featureName",rM.name),(0,y._)(this,"revealer",void 0),(0,y._)(this,"claimWithConditions",void 0),(0,y._)(this,"claim",void 0),(0,y._)(this,"contractWrapper",void 0),(0,y._)(this,"erc721",void 0),(0,y._)(this,"storage",void 0),this.erc721=t,this.contractWrapper=e,this.storage=r,this.revealer=this.detectErc721Revealable(),this.claimWithConditions=this.detectErc721ClaimableWithConditions(),this.claim=this.detectErc721Claimable()}async lazyMint(t,e){let r=await this.erc721.nextTokenIdToMint(),a=await aD(t,this.storage,r.toNumber(),e),n=a$(a),i=await this.contractWrapper.sendTransaction("lazyMint",[a.length,n.endsWith("/")?n:`${n}/`,v.Y0("")]),s=this.contractWrapper.parseLogs("TokensLazyMinted",null==i?void 0:i.logs),o=s[0].args.startTokenId,c=s[0].args.endTokenId,l=[];for(let d=o;d.lte(c);d=d.add(1))l.push({id:d,receipt:i,data:()=>this.erc721.getTokenMetadata(d)});return l}detectErc721Revealable(){if(an(this.contractWrapper,"ERC721Revealable"))return new aL(this.contractWrapper,this.storage,r_.name,()=>this.erc721.nextTokenIdToMint())}detectErc721ClaimableWithConditions(){if(an(this.contractWrapper,"ERC721ClaimableWithConditions"))return new nz(this.erc721,this.contractWrapper,this.storage)}detectErc721Claimable(){if(an(this.contractWrapper,"ERC721Claimable")&&!ai("setClaimConditions",this.contractWrapper))return new nI(this.erc721,this.contractWrapper)}}class nB{constructor(t,e,r){(0,y._)(this,"featureName",rx.name),(0,y._)(this,"contractWrapper",void 0),(0,y._)(this,"storage",void 0),(0,y._)(this,"erc721",void 0),this.erc721=t,this.contractWrapper=e,this.storage=r}async to(t,e){let r=await aD(e,this.storage),a=r.map(e=>this.contractWrapper.readContract.interface.encodeFunctionData("mintTo",[t,e])),n=await this.contractWrapper.multiCall(a),i=this.contractWrapper.parseLogs("TokensMinted",n.logs);if(0===i.length||i.length<e.length)throw Error("TokenMinted event not found, minting failed");return i.map(t=>{let e=t.args.tokenIdMinted;return{id:e,receipt:n,data:()=>this.erc721.get(e)}})}}class n_{constructor(t,e,r){(0,y._)(this,"featureName",rN.name),(0,y._)(this,"contractWrapper",void 0),(0,y._)(this,"storage",void 0),(0,y._)(this,"erc721",void 0),(0,y._)(this,"batch",void 0),this.erc721=t,this.contractWrapper=e,this.storage=r,this.batch=this.detectErc721BatchMintable()}async to(t,e){let r=await aN(e,this.storage),a=await this.contractWrapper.sendTransaction("mintTo",[t,r]),n=this.contractWrapper.parseLogs("Transfer",null==a?void 0:a.logs);if(0===n.length)throw Error("TransferEvent event not found");let i=n[0].args.tokenId;return{id:i,receipt:a,data:()=>this.erc721.get(i)}}detectErc721BatchMintable(){if(an(this.contractWrapper,"ERC721BatchMintable"))return new nB(this.erc721,this.contractWrapper,this.storage)}}class nF{constructor(t,e){(0,y._)(this,"featureName",r$.name),(0,y._)(this,"contractWrapper",void 0),(0,y._)(this,"erc721",void 0),this.erc721=t,this.contractWrapper=e}async all(t){let e=await this.tokenIds(t);return await Promise.all(e.map(t=>this.erc721.get(t.toString())))}async tokenIds(t){let e=t||await this.contractWrapper.getSignerAddress(),r=await this.contractWrapper.readContract.balanceOf(e),a=Array.from(Array(r.toNumber()).keys());return await Promise.all(a.map(t=>this.contractWrapper.readContract.tokenOfOwnerByIndex(e,t)))}}class nR{constructor(t,e){(0,y._)(this,"featureName",rL.name),(0,y._)(this,"contractWrapper",void 0),(0,y._)(this,"erc721",void 0),(0,y._)(this,"owned",void 0),this.erc721=t,this.contractWrapper=e,this.owned=this.detectErc721Owned()}async all(t){let e=f.O$.from((null==t?void 0:t.start)||0).toNumber(),r=f.O$.from((null==t?void 0:t.count)||y.D).toNumber(),a=await this.erc721.nextTokenIdToMint(),n=Math.min(a.toNumber(),e+r);return await Promise.all([...Array(n-e).keys()].map(t=>this.erc721.get((e+t).toString())))}async allOwners(){return Promise.all([...Array((await this.totalCount()).toNumber()).keys()].map(async t=>({tokenId:t,owner:await this.erc721.ownerOf(t).catch(()=>C.d)})))}async totalCount(){return await this.erc721.nextTokenIdToMint()}async totalCirculatingSupply(){return await this.contractWrapper.readContract.totalSupply()}detectErc721Owned(){if(an(this.contractWrapper,"ERC721Enumerable"))return new nF(this.erc721,this.contractWrapper)}}class nM{constructor(t,e){(0,y._)(this,"featureName",rD.name),(0,y._)(this,"contractWrapper",void 0),(0,y._)(this,"storage",void 0),this.contractWrapper=t,this.storage=e}async mint(t){let e,r;let a=t.payload,n=t.signature,i=await this.isLegacyNFTContract();r=i?(e=await this.mapLegacyPayloadToContractStruct(a)).price:(e=await this.mapPayloadToContractStruct(a)).pricePerToken.mul(e.quantity);let s=await this.contractWrapper.getCallOverrides();await ne(this.contractWrapper,r,a.currencyAddress,s);let o=await this.contractWrapper.sendTransaction("mintWithSignature",[e,n],s),c=this.contractWrapper.parseLogs("TokensMintedWithSignature",o.logs);if(0===c.length)throw Error("No MintWithSignature event found");let l=c[0].args.tokenIdMinted;return{id:l,receipt:o}}async mintBatch(t){let e=await this.isLegacyNFTContract(),r=await Promise.all(t.map(async t=>{let r;r=e?await this.mapLegacyPayloadToContractStruct(t.payload):await this.mapPayloadToContractStruct(t.payload);let a=t.signature,n=t.payload.price;if(f.O$.from(n).gt(0))throw Error("Can only batch free mints. For mints with a price, use regular mint()");return{message:r,signature:a}})),a=r.map(t=>{if(e){let r=this.contractWrapper.readContract;return r.interface.encodeFunctionData("mintWithSignature",[t.message,t.signature])}{let a=this.contractWrapper.readContract;return a.interface.encodeFunctionData("mintWithSignature",[t.message,t.signature])}}),n=await this.contractWrapper.multiCall(a),i=this.contractWrapper.parseLogs("TokensMintedWithSignature",n.logs);if(0===i.length)throw Error("No MintWithSignature event found");return i.map(t=>({id:t.args.tokenIdMinted,receipt:n}))}async verify(t){let e;let r=await this.isLegacyNFTContract(),a=t.payload,n=t.signature;if(r){let i=this.contractWrapper.readContract;e=await i.verify(await this.mapLegacyPayloadToContractStruct(a),n)}else{let s=this.contractWrapper.readContract;e=await s.verify(await this.mapPayloadToContractStruct(a),n)}return e[0]}async generate(t){return(await this.generateBatch([t]))[0]}async generateBatch(t){let e=await this.isLegacyNFTContract(),r=t.map(t=>eo.parse(t)),a=r.map(t=>t.metadata),n=await aD(a,this.storage),i=await this.contractWrapper.getChainID(),s=this.contractWrapper.getSigner();return(0,L.Z)(s,"No signer available"),await Promise.all(r.map(async(t,r)=>{let a;let o=n[r],c=ec.parse({...t,uri:o});return a=e?await this.contractWrapper.signTypedData(s,{name:"TokenERC721",version:"1",chainId:i,verifyingContract:this.contractWrapper.readContract.address},{MintRequest:ed},await this.mapLegacyPayloadToContractStruct(c)):await this.contractWrapper.signTypedData(s,{name:"SignatureMintERC721",version:"1",chainId:i,verifyingContract:await this.contractWrapper.readContract.address},{MintRequest:eu},await this.mapPayloadToContractStruct(c)),{payload:c,signature:a.toString()}}))}async mapPayloadToContractStruct(t){let e=await a4(this.contractWrapper.getProvider(),t.price,t.currencyAddress);return{to:t.to,royaltyRecipient:t.royaltyRecipient,royaltyBps:t.royaltyBps,primarySaleRecipient:t.primarySaleRecipient,uri:t.uri,quantity:t.quantity,pricePerToken:e,currency:t.currencyAddress,validityStartTimestamp:t.mintStartTime,validityEndTimestamp:t.mintEndTime,uid:t.uid}}async mapLegacyPayloadToContractStruct(t){let e=await a4(this.contractWrapper.getProvider(),t.price,t.currencyAddress);return{to:t.to,price:e,uri:t.uri,currency:t.currencyAddress,validityEndTimestamp:t.mintEndTime,validityStartTimestamp:t.mintStartTime,uid:t.uid,royaltyRecipient:t.royaltyRecipient,royaltyBps:t.royaltyBps,primarySaleRecipient:t.primarySaleRecipient}}async isLegacyNFTContract(){if(!ai("contractType",this.contractWrapper))return!1;try{let t=v.ZN(await this.contractWrapper.readContract.contractType());return t.includes("TokenERC721")}catch(e){return!1}}}class nx{get chainId(){return this._chainId}constructor(t,e,r){(0,y._)(this,"featureName",rj.name),(0,y._)(this,"query",void 0),(0,y._)(this,"mintable",void 0),(0,y._)(this,"burnable",void 0),(0,y._)(this,"lazyMintable",void 0),(0,y._)(this,"signatureMintable",void 0),(0,y._)(this,"contractWrapper",void 0),(0,y._)(this,"storage",void 0),(0,y._)(this,"_chainId",void 0),this.contractWrapper=t,this.storage=e,this.query=this.detectErc721Enumerable(),this.mintable=this.detectErc721Mintable(),this.burnable=this.detectErc721Burnable(),this.lazyMintable=this.detectErc721LazyMintable(),this.signatureMintable=this.detectErc721SignatureMintable(),this._chainId=r}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.readContract.address}async get(t){let[e,r]=await Promise.all([this.ownerOf(t).catch(()=>C.d),this.getTokenMetadata(t).catch(()=>({id:t.toString(),uri:"",...aR}))]);return{owner:e,metadata:r,type:"ERC721",supply:1}}async ownerOf(t){return await this.contractWrapper.readContract.ownerOf(t)}async balanceOf(t){return await this.contractWrapper.readContract.balanceOf(t)}async balance(){return await this.balanceOf(await this.contractWrapper.getSignerAddress())}async isApproved(t,e){return await this.contractWrapper.readContract.isApprovedForAll(t,e)}async transfer(t,e){let r=await this.contractWrapper.getSignerAddress();return{receipt:await this.contractWrapper.sendTransaction("safeTransferFrom(address,address,uint256)",[r,t,e])}}async setApprovalForAll(t,e){return{receipt:await this.contractWrapper.sendTransaction("setApprovalForAll",[t,e])}}async setApprovalForToken(t,e){return{receipt:await this.contractWrapper.sendTransaction("approve",[t,e])}}async getAll(t){return aa(this.query,rL).all(t)}async getAllOwners(){return aa(this.query,rL).allOwners()}async totalCount(){return this.nextTokenIdToMint()}async totalCirculatingSupply(){return aa(this.query,rL).totalCirculatingSupply()}async getOwned(t){var e;if(null!==(e=this.query)&&void 0!==e&&e.owned)return this.query.owned.all(t);{let r=t||await this.contractWrapper.getSignerAddress(),a=await this.getAllOwners();return Promise.all((a||[]).filter(t=>{var e;return(null==r?void 0:r.toLowerCase())===(null===(e=t.owner)||void 0===e?void 0:e.toLowerCase())}).map(async t=>await this.get(t.tokenId)))}}async getOwnedTokenIds(t){var e;if(null!==(e=this.query)&&void 0!==e&&e.owned)return this.query.owned.tokenIds(t);{let r=t||await this.contractWrapper.getSignerAddress(),a=await this.getAllOwners();return(a||[]).filter(t=>{var e;return(null==r?void 0:r.toLowerCase())===(null===(e=t.owner)||void 0===e?void 0:e.toLowerCase())}).map(t=>f.O$.from(t.tokenId))}}async mint(t){return this.mintTo(await this.contractWrapper.getSignerAddress(),t)}async mintTo(t,e){return aa(this.mintable,rN).to(t,e)}async mintBatch(t){return this.mintBatchTo(await this.contractWrapper.getSignerAddress(),t)}async mintBatchTo(t,e){var r;return aa(null===(r=this.mintable)||void 0===r?void 0:r.batch,rx).to(t,e)}async burn(t){return aa(this.burnable,rB).token(t)}async lazyMint(t,e){return aa(this.lazyMintable,rM).lazyMint(t,e)}async claim(t,e){return this.claimTo(await this.contractWrapper.getSignerAddress(),t,e)}async claimTo(t,e,r){var a,n;let i=null===(a=this.lazyMintable)||void 0===a?void 0:a.claimWithConditions,s=null===(n=this.lazyMintable)||void 0===n?void 0:n.claim;if(i)return i.to(t,e,r);if(s)return s.to(t,e,r);throw new eD(rR)}async getClaimTransaction(t,e,r){var a,n;let i=null===(a=this.lazyMintable)||void 0===a?void 0:a.claimWithConditions,s=null===(n=this.lazyMintable)||void 0===n?void 0:n.claim;if(i)return i.getClaimTransaction(t,e,r);if(s)return s.getClaimTransaction(t,e,r);throw new eD(rR)}async totalClaimedSupply(){let t=this.contractWrapper;if(ai("nextTokenIdToClaim",t))return t.readContract.nextTokenIdToClaim();if(ai("totalMinted",t))return t.readContract.totalMinted();throw Error("No function found on contract to get total claimed supply")}async totalUnclaimedSupply(){return(await this.nextTokenIdToMint()).sub(await this.totalClaimedSupply())}get claimConditions(){var t;return aa(null===(t=this.lazyMintable)||void 0===t?void 0:t.claimWithConditions,rF).conditions}get signature(){return aa(this.signatureMintable,rD)}get revealer(){var t;return aa(null===(t=this.lazyMintable)||void 0===t?void 0:t.revealer,r_)}async getTokenMetadata(t){let e=await this.contractWrapper.readContract.tokenURI(t);if(!e)throw new eB;return aM(t,e,this.storage)}async nextTokenIdToMint(){if(ai("nextTokenIdToMint",this.contractWrapper))return await this.contractWrapper.readContract.nextTokenIdToMint();if(ai("totalSupply",this.contractWrapper))return await this.contractWrapper.readContract.totalSupply();throw Error("Contract requires either `nextTokenIdToMint` or `totalSupply` function available to determine the next token ID to mint")}detectErc721Enumerable(){if(an(this.contractWrapper,"ERC721Supply")||ai("nextTokenIdToMint",this.contractWrapper))return new nR(this,this.contractWrapper)}detectErc721Mintable(){if(an(this.contractWrapper,"ERC721Mintable"))return new n_(this,this.contractWrapper,this.storage)}detectErc721Burnable(){if(an(this.contractWrapper,"ERC721Burnable"))return new nE(this.contractWrapper)}detectErc721LazyMintable(){if(an(this.contractWrapper,"ERC721LazyMintable"))return new nO(this,this.contractWrapper,this.storage)}detectErc721SignatureMintable(){if(an(this.contractWrapper,"ERC721SignatureMint"))return new nM(this.contractWrapper,this.storage)}}class nN{get chainId(){return this._chainId}constructor(t,e,r){(0,y._)(this,"contractWrapper",void 0),(0,y._)(this,"storage",void 0),(0,y._)(this,"erc721",void 0),(0,y._)(this,"_chainId",void 0),this.contractWrapper=t,this.storage=e,this.erc721=new nx(this.contractWrapper,this.storage,r),this._chainId=r}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.readContract.address}async getAll(t){return this.erc721.getAll(t)}async getOwned(t){return this.erc721.getOwned(t)}async getOwnedTokenIds(t){return this.erc721.getOwnedTokenIds(t)}async totalSupply(){return this.erc721.totalCirculatingSupply()}async get(t){return this.erc721.get(t)}async ownerOf(t){return this.erc721.ownerOf(t)}async balanceOf(t){return this.erc721.balanceOf(t)}async balance(){return this.erc721.balance()}async isApproved(t,e){return this.erc721.isApproved(t,e)}async transfer(t,e){return this.erc721.transfer(t,e)}async setApprovalForAll(t,e){return this.erc721.setApprovalForAll(t,e)}async setApprovalForToken(t,e){return{receipt:await this.contractWrapper.sendTransaction("approve",[t,e])}}}let nD=g.z.object({address:tU,quantity:tG.default(1)}),n$=g.z.union([g.z.array(g.z.string()).transform(t=>t.map(t=>nD.parse({address:t}))),g.z.array(nD)]);class nL{constructor(t){(0,y._)(this,"featureName",rq.name),(0,y._)(this,"contractWrapper",void 0),this.contractWrapper=t}async tokens(t,e){let r=await this.contractWrapper.getSignerAddress();return this.from(r,t,e)}async from(t,e,r){return{receipt:await this.contractWrapper.sendTransaction("burn",[t,e,r])}}async batch(t,e){let r=await this.contractWrapper.getSignerAddress();return this.batchFrom(r,t,e)}async batchFrom(t,e,r){return{receipt:await this.contractWrapper.sendTransaction("burnBatch",[t,e,r])}}}class nj{constructor(t,e){(0,y._)(this,"featureName",rQ.name),(0,y._)(this,"contractWrapper",void 0),(0,y._)(this,"erc1155",void 0),this.erc1155=t,this.contractWrapper=e}async all(t){let e=f.O$.from((null==t?void 0:t.start)||0).toNumber(),r=f.O$.from((null==t?void 0:t.count)||y.D).toNumber(),a=Math.min((await this.totalCount()).toNumber(),e+r);return await Promise.all([...Array(a-e).keys()].map(t=>this.erc1155.get((e+t).toString())))}async totalCount(){return await this.contractWrapper.readContract.nextTokenIdToMint()}async totalCirculatingSupply(t){return await this.contractWrapper.readContract.totalSupply(t)}async owned(t){let e=t||await this.contractWrapper.getSignerAddress(),r=await this.contractWrapper.readContract.nextTokenIdToMint(),a=await this.contractWrapper.readContract.balanceOfBatch(Array(r.toNumber()).fill(e),Array.from(Array(r.toNumber()).keys())),n=a.map((t,e)=>({tokenId:e,balance:t})).filter(t=>t.balance.gt(0));return await Promise.all(n.map(async t=>{let r=await this.erc1155.get(t.tokenId.toString());return{...r,owner:e,quantityOwned:t.balance.toNumber()}}))}}class nq{constructor(t){(0,y._)(this,"featureName",rG.name),(0,y._)(this,"contractWrapper",void 0),this.contractWrapper=t}async getClaimTransaction(t,e,r,a){let n={};return a&&a.pricePerToken&&(n=await nh(this.contractWrapper,a.pricePerToken,r,a.currencyAddress,a.checkERC20Allowance)),nP.make({contractWrapper:this.contractWrapper,functionName:"claim",args:[t,e,r],overrides:n})}async to(t,e,r,a){let n=await this.getClaimTransaction(t,e,r,a);return await n.execute()}}class nU{constructor(t,e){(0,y._)(this,"featureName",rU.name),(0,y._)(this,"conditions",void 0),(0,y._)(this,"contractWrapper",void 0),(0,y._)(this,"storage",void 0),this.contractWrapper=t,this.storage=e;let r=new aO(this.contractWrapper,ah,this.storage);this.conditions=new ng(t,r,this.storage)}async getClaimTransaction(t,e,r,a){if(null!=a&&a.pricePerToken)throw Error("In ERC1155ClaimableWithConditions, price per token is be set via claim conditions by calling `contract.erc1155.claimConditions.set()`");let n=await this.conditions.prepareClaim(e,r,(null==a?void 0:a.checkERC20Allowance)||!0);return nP.make({contractWrapper:this.contractWrapper,functionName:"claim",args:await this.getArgs(e,t,r,n),overrides:n.overrides})}async to(t,e,r,a){let n=await this.getClaimTransaction(t,e,r,a);return await n.execute()}async getArgs(t,e,r,a){let n=await this.isLegacyNFTContract();return n?[e,t,r,a.currencyAddress,a.price,a.proofs,a.maxQuantityPerTransaction]:[e,t,r,a.currencyAddress,a.price,{proof:a.proofs,maxQuantityInAllowlist:a.maxQuantityPerTransaction},v.Y0("")]}async isLegacyNFTContract(){if(!ai("contractType",this.contractWrapper))return!1;try{let t=v.ZN(await this.contractWrapper.readContract.contractType());return t.includes("DropERC1155")}catch(e){return!1}}}class nG{constructor(t,e,r){(0,y._)(this,"featureName",rH.name),(0,y._)(this,"revealer",void 0),(0,y._)(this,"claimWithConditions",void 0),(0,y._)(this,"claim",void 0),(0,y._)(this,"contractWrapper",void 0),(0,y._)(this,"erc1155",void 0),(0,y._)(this,"storage",void 0),this.erc1155=t,this.contractWrapper=e,this.storage=r,this.claim=this.detectErc1155Claimable(),this.claimWithConditions=this.detectErc1155ClaimableWithConditions(),this.revealer=this.detectErc721Revealable()}async lazyMint(t,e){let r;let a=await this.erc1155.nextTokenIdToMint(),n=await aD(t,this.storage,a.toNumber(),e),i=n[0].substring(0,n[0].lastIndexOf("/"));for(let s=0;s<n.length;s++){let o=n[s].substring(0,n[s].lastIndexOf("/"));if(i!==o)throw Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${i}' but got '${o}'`)}let c=await this.isLegacyEditionDropContract();r=c?await this.contractWrapper.sendTransaction("lazyMint",[n.length,`${i.endsWith("/")?i:`${i}/`}`]):await this.contractWrapper.sendTransaction("lazyMint",[n.length,`${i.endsWith("/")?i:`${i}/`}`,v.Y0("")]);let l=this.contractWrapper.parseLogs("TokensLazyMinted",null==r?void 0:r.logs),d=l[0].args.startTokenId,p=l[0].args.endTokenId,u=[];for(let h=d;h.lte(p);h=h.add(1))u.push({id:h,receipt:r,data:()=>this.erc1155.getTokenMetadata(h)});return u}detectErc1155Claimable(){if(an(this.contractWrapper,"ERC1155Claimable")&&!ai("setClaimConditions",this.contractWrapper))return new nq(this.contractWrapper)}detectErc1155ClaimableWithConditions(){if(an(this.contractWrapper,"ERC1155ClaimableWithConditions"))return new nU(this.contractWrapper,this.storage)}detectErc721Revealable(){if(an(this.contractWrapper,"ERC1155Revealable"))return new aL(this.contractWrapper,this.storage,rZ.name,()=>this.erc1155.nextTokenIdToMint())}async isLegacyEditionDropContract(){if(!ai("contractType",this.contractWrapper))return!1;try{let t=v.ZN(await this.contractWrapper.readContract.contractType());return t.includes("DropERC1155")}catch(e){return!1}}}class nH{constructor(t,e,r){(0,y._)(this,"featureName",rJ.name),(0,y._)(this,"contractWrapper",void 0),(0,y._)(this,"erc1155",void 0),(0,y._)(this,"storage",void 0),this.erc1155=t,this.contractWrapper=e,this.storage=r}async to(t,e){let r=e.map(t=>t.metadata),a=e.map(t=>t.supply),n=await aD(r,this.storage),i=n.map((e,r)=>this.contractWrapper.readContract.interface.encodeFunctionData("mintTo",[t,x.Bz,e,a[r]])),s=await this.contractWrapper.multiCall(i),o=this.contractWrapper.parseLogs("TokensMinted",s.logs);if(0===o.length||o.length<r.length)throw Error("TokenMinted event not found, minting failed");return o.map(t=>{let e=t.args.tokenIdMinted;return{id:e,receipt:s,data:()=>this.erc1155.get(e)}})}}class nZ{constructor(t,e,r){(0,y._)(this,"featureName",rY.name),(0,y._)(this,"contractWrapper",void 0),(0,y._)(this,"erc1155",void 0),(0,y._)(this,"storage",void 0),(0,y._)(this,"batch",void 0),this.erc1155=t,this.contractWrapper=e,this.storage=r,this.batch=this.detectErc1155BatchMintable()}async to(t,e){let r=await aN(e.metadata,this.storage),a=await this.contractWrapper.sendTransaction("mintTo",[t,x.Bz,r,e.supply]),n=this.contractWrapper.parseLogs("TransferSingle",null==a?void 0:a.logs);if(0===n.length)throw Error("TransferSingleEvent event not found");let i=n[0].args.id;return{id:i,receipt:a,data:()=>this.erc1155.get(i.toString())}}async additionalSupplyTo(t,e,r){let a=await this.erc1155.getTokenMetadata(e),n=await this.contractWrapper.sendTransaction("mintTo",[t,e,a.uri,r]);return{id:f.O$.from(e),receipt:n,data:()=>this.erc1155.get(e)}}detectErc1155BatchMintable(){if(an(this.contractWrapper,"ERC1155BatchMintable"))return new nH(this.erc1155,this.contractWrapper,this.storage)}}class nV{constructor(t,e,r){(0,y._)(this,"featureName",rV.name),(0,y._)(this,"contractWrapper",void 0),(0,y._)(this,"storage",void 0),(0,y._)(this,"roles",void 0),this.contractWrapper=t,this.storage=e,this.roles=r}async mint(t){let e=t.payload,r=t.signature,a=await this.mapPayloadToContractStruct(e),n=await this.contractWrapper.getCallOverrides();await ne(this.contractWrapper,a.pricePerToken.mul(a.quantity),e.currencyAddress,n);let i=await this.contractWrapper.sendTransaction("mintWithSignature",[a,r],n),s=this.contractWrapper.parseLogs("TokensMintedWithSignature",i.logs);if(0===s.length)throw Error("No MintWithSignature event found");let o=s[0].args.tokenIdMinted;return{id:o,receipt:i}}async mintBatch(t){let e=await Promise.all(t.map(async t=>{let e=await this.mapPayloadToContractStruct(t.payload),r=t.signature,a=t.payload.price;if(f.O$.from(a).gt(0))throw Error("Can only batch free mints. For mints with a price, use regular mint()");return{message:e,signature:r}})),r=e.map(t=>this.contractWrapper.readContract.interface.encodeFunctionData("mintWithSignature",[t.message,t.signature])),a=await this.contractWrapper.multiCall(r),n=this.contractWrapper.parseLogs("TokensMintedWithSignature",a.logs);if(0===n.length)throw Error("No MintWithSignature event found");return n.map(t=>({id:t.args.tokenIdMinted,receipt:a}))}async verify(t){let e=t.payload,r=t.signature,a=await this.mapPayloadToContractStruct(e),n=await this.contractWrapper.readContract.verify(a,r);return n[0]}async generate(t){let e={...t,tokenId:x.Bz};return this.generateFromTokenId(e)}async generateFromTokenId(t){let e=await this.generateBatchFromTokenIds([t]);return e[0]}async generateBatch(t){let e=t.map(t=>({...t,tokenId:x.Bz}));return this.generateBatchFromTokenIds(e)}async generateBatchFromTokenIds(t){var e;await (null===(e=this.roles)||void 0===e?void 0:e.verify(["minter"],await this.contractWrapper.getSignerAddress()));let r=t.map(t=>ei.parse(t)),a=r.map(t=>t.metadata),n=await aD(a,this.storage),i=await this.contractWrapper.getChainID(),s=this.contractWrapper.getSigner();return(0,L.Z)(s,"No signer available"),await Promise.all(r.map(async(t,e)=>{let r=n[e],a=es.parse({...t,uri:r}),o=await this.contractWrapper.signTypedData(s,{name:"TokenERC1155",version:"1",chainId:i,verifyingContract:this.contractWrapper.readContract.address},{MintRequest:ep},await this.mapPayloadToContractStruct(a));return{payload:a,signature:o.toString()}}))}async mapPayloadToContractStruct(t){let e=await a4(this.contractWrapper.getProvider(),t.price,t.currencyAddress);return{to:t.to,tokenId:t.tokenId,uri:t.uri,quantity:t.quantity,pricePerToken:e,currency:t.currencyAddress,validityStartTimestamp:t.mintStartTime,validityEndTimestamp:t.mintEndTime,uid:t.uid,royaltyRecipient:t.royaltyRecipient,royaltyBps:t.royaltyBps,primarySaleRecipient:t.primarySaleRecipient}}}class nJ{get chainId(){return this._chainId}constructor(t,e,r){(0,y._)(this,"featureName",rK.name),(0,y._)(this,"query",void 0),(0,y._)(this,"mintable",void 0),(0,y._)(this,"burnable",void 0),(0,y._)(this,"lazyMintable",void 0),(0,y._)(this,"signatureMintable",void 0),(0,y._)(this,"contractWrapper",void 0),(0,y._)(this,"storage",void 0),(0,y._)(this,"_chainId",void 0),this.contractWrapper=t,this.storage=e,this.query=this.detectErc1155Enumerable(),this.mintable=this.detectErc1155Mintable(),this.burnable=this.detectErc1155Burnable(),this.lazyMintable=this.detectErc1155LazyMintable(),this.signatureMintable=this.detectErc1155SignatureMintable(),this._chainId=r}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.readContract.address}async get(t){let[e,r]=await Promise.all([this.contractWrapper.readContract.totalSupply(t).catch(()=>f.O$.from(0)),this.getTokenMetadata(t).catch(()=>({id:t.toString(),uri:"",...aR}))]);return{owner:C.d,metadata:r,type:"ERC1155",supply:e.toNumber()}}async totalSupply(t){return await this.contractWrapper.readContract.totalSupply(t)}async balanceOf(t,e){return await this.contractWrapper.readContract.balanceOf(t,e)}async balance(t){return await this.balanceOf(await this.contractWrapper.getSignerAddress(),t)}async isApproved(t,e){return await this.contractWrapper.readContract.isApprovedForAll(t,e)}async transfer(t,e,r){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[0],n=await this.contractWrapper.getSignerAddress();return{receipt:await this.contractWrapper.sendTransaction("safeTransferFrom",[n,t,e,r,a])}}async setApprovalForAll(t,e){return{receipt:await this.contractWrapper.sendTransaction("setApprovalForAll",[t,e])}}async airdrop(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[0],a=await this.contractWrapper.getSignerAddress(),n=await this.balanceOf(a,t),i=n$.parse(e),s=i.reduce((t,e)=>t+Number((null==e?void 0:e.quantity)||1),0);if(n.toNumber()<s)throw Error(`The caller owns ${n.toNumber()} NFTs, but wants to airdrop ${s} NFTs.`);let o=i.map(e=>{let{address:n,quantity:i}=e;return this.contractWrapper.readContract.interface.encodeFunctionData("safeTransferFrom",[a,n,t,i,r])});return{receipt:await this.contractWrapper.multiCall(o)}}async nextTokenIdToMint(){if(ai("nextTokenIdToMint",this.contractWrapper))return await this.contractWrapper.readContract.nextTokenIdToMint();throw Error("Contract requires the `nextTokenIdToMint` function available to determine the next token ID to mint")}async getAll(t){return aa(this.query,rQ).all(t)}async totalCount(){return aa(this.query,rQ).totalCount()}async totalCirculatingSupply(t){return aa(this.query,rQ).totalCirculatingSupply(t)}async getOwned(t){return aa(this.query,rQ).owned(t)}async mint(t){return this.mintTo(await this.contractWrapper.getSignerAddress(),t)}async mintTo(t,e){return aa(this.mintable,rY).to(t,e)}async mintAdditionalSupply(t,e){return aa(this.mintable,rY).additionalSupplyTo(await this.contractWrapper.getSignerAddress(),t,e)}async mintAdditionalSupplyTo(t,e,r){return aa(this.mintable,rY).additionalSupplyTo(t,e,r)}async mintBatch(t){return this.mintBatchTo(await this.contractWrapper.getSignerAddress(),t)}async mintBatchTo(t,e){var r;return aa(null===(r=this.mintable)||void 0===r?void 0:r.batch,rJ).to(t,e)}async burn(t,e){return aa(this.burnable,rq).tokens(t,e)}async burnFrom(t,e,r){return aa(this.burnable,rq).from(t,e,r)}async burnBatch(t,e){return aa(this.burnable,rq).batch(t,e)}async burnBatchFrom(t,e,r){return aa(this.burnable,rq).batchFrom(t,e,r)}async lazyMint(t,e){return aa(this.lazyMintable,rH).lazyMint(t,e)}async getClaimTransaction(t,e,r,a){var n,i;let s=null===(n=this.lazyMintable)||void 0===n?void 0:n.claimWithConditions,o=null===(i=this.lazyMintable)||void 0===i?void 0:i.claim;if(s)return s.getClaimTransaction(t,e,r,a);if(o)return o.getClaimTransaction(t,e,r,a);throw new eD(rG)}async claim(t,e,r){return this.claimTo(await this.contractWrapper.getSignerAddress(),t,e,r)}async claimTo(t,e,r,a){var n,i;let s=null===(n=this.lazyMintable)||void 0===n?void 0:n.claimWithConditions,o=null===(i=this.lazyMintable)||void 0===i?void 0:i.claim;if(s)return s.to(t,e,r,a);if(o)return o.to(t,e,r,a);throw new eD(rG)}get claimConditions(){var t;return aa(null===(t=this.lazyMintable)||void 0===t?void 0:t.claimWithConditions,rU).conditions}get signature(){return aa(this.signatureMintable,rV)}get revealer(){var t;return aa(null===(t=this.lazyMintable)||void 0===t?void 0:t.revealer,rZ)}async getTokenMetadata(t){let e=await this.contractWrapper.readContract.uri(t);if(!e)throw new eB;return aM(t,e,this.storage)}detectErc1155Enumerable(){if(an(this.contractWrapper,"ERC1155Enumerable"))return new nj(this,this.contractWrapper)}detectErc1155Mintable(){if(an(this.contractWrapper,"ERC1155Mintable"))return new nZ(this,this.contractWrapper,this.storage)}detectErc1155Burnable(){if(an(this.contractWrapper,"ERC1155Burnable"))return new nL(this.contractWrapper)}detectErc1155LazyMintable(){if(an(this.contractWrapper,"ERC1155LazyMintable"))return new nG(this,this.contractWrapper,this.storage)}detectErc1155SignatureMintable(){if(an(this.contractWrapper,"ERC1155SignatureMintable"))return new nV(this.contractWrapper,this.storage)}}class nY{get chainId(){return this._chainId}constructor(t,e,r){(0,y._)(this,"contractWrapper",void 0),(0,y._)(this,"storage",void 0),(0,y._)(this,"erc1155",void 0),(0,y._)(this,"_chainId",void 0),this.contractWrapper=t,this.storage=e,this.erc1155=new nJ(this.contractWrapper,this.storage,r),this._chainId=r}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.readContract.address}async get(t){return this.erc1155.get(t)}async totalSupply(t){return this.erc1155.totalSupply(t)}async balanceOf(t,e){return this.erc1155.balanceOf(t,e)}async balance(t){return this.erc1155.balance(t)}async isApproved(t,e){return this.erc1155.isApproved(t,e)}async transfer(t,e,r){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[0];return this.erc1155.transfer(t,e,r,a)}async setApprovalForAll(t,e){return this.erc1155.setApprovalForAll(t,e)}async airdrop(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[0];return this.erc1155.airdrop(t,e,r)}}async function nQ(t,e,r,a,n){try{let i=new F.CH(r,N,t),s=await i.supportsInterface(eE),o=await i.supportsInterface(eS);if(s){let c=new F.CH(r,D,t),l=await c.isApprovedForAll(n,e);if(l)return!0;return(await c.getApproved(a)).toLowerCase()===e.toLowerCase()}if(!o)return console.error("Contract does not implement ERC 1155 or ERC 721."),!1;{let d=new F.CH(r,$,t);return await d.isApprovedForAll(n,e)}}catch(p){return console.error("Failed to check if token is approved",p),!1}}async function nK(t,e,r,a,n){let i=new F.CH(r,N,t),s=await i.supportsInterface(eE),o=await i.supportsInterface(eS);if(s){let c=new a6(t,r,D,{}),l=await c.readContract.isApprovedForAll(n,e);if(!l){let d=(await c.readContract.getApproved(a)).toLowerCase()===e.toLowerCase();d||await c.sendTransaction("setApprovalForAll",[e,!0])}}else if(o){let p=new a6(t,r,$,{}),u=await p.readContract.isApprovedForAll(n,e);u||await p.sendTransaction("setApprovalForAll",[e,!0])}else throw Error("Contract must implement ERC 1155 or ERC 721.")}function nX(t){(0,L.Z)(void 0!==t.assetContractAddress&&null!==t.assetContractAddress,"Asset contract address is required"),(0,L.Z)(void 0!==t.buyoutPricePerToken&&null!==t.buyoutPricePerToken,"Buyout price is required"),(0,L.Z)(void 0!==t.listingDurationInSeconds&&null!==t.listingDurationInSeconds,"Listing duration is required"),(0,L.Z)(void 0!==t.startTimestamp&&null!==t.startTimestamp,"Start time is required"),(0,L.Z)(void 0!==t.tokenId&&null!==t.tokenId,"Token ID is required"),(0,L.Z)(void 0!==t.quantity&&null!==t.quantity,"Quantity is required"),"NewAuctionListing"===t.type&&(0,L.Z)(void 0!==t.reservePricePerToken&&null!==t.reservePricePerToken,"Reserve price is required")}async function n0(t,e,r){return{quantity:r.quantityDesired,pricePerToken:r.pricePerToken,currencyContractAddress:r.currency,buyerAddress:r.offeror,quantityDesired:r.quantityWanted,currencyValue:await nt(t,r.currency,r.quantityWanted.mul(r.pricePerToken)),listingId:e}}class n1{constructor(t,e){(0,y._)(this,"contractWrapper",void 0),(0,y._)(this,"storage",void 0),this.contractWrapper=t,this.storage=e}getAddress(){return this.contractWrapper.readContract.address}async getListing(t){let e=await this.contractWrapper.readContract.listings(t);if(e.assetContract===C.d)throw new eM(this.getAddress(),t.toString());if(e.listingType!==i.Direct)throw new ex(this.getAddress(),t.toString(),"Auction","Direct");return await this.mapListing(e)}async getActiveOffer(t,e){await this.validateListing(f.O$.from(t)),(0,L.Z)(w.isAddress(e),"Address must be a valid address");let r=await this.contractWrapper.readContract.offers(t,e);if(r.offeror!==C.d)return await n0(this.contractWrapper.getProvider(),f.O$.from(t),r)}async createListing(t){var e;nX(t),await nK(this.contractWrapper.getSignerOrProvider(),this.getAddress(),t.assetContractAddress,t.tokenId,await this.contractWrapper.getSignerAddress());let r=await a4(this.contractWrapper.getProvider(),t.buyoutPricePerToken,t.currencyContractAddress),a=Math.floor(t.startTimestamp.getTime()/1e3),n=await this.contractWrapper.getProvider().getBlock("latest"),s=n.timestamp;a<s&&(a=s);let o=await this.contractWrapper.sendTransaction("createListing",[{assetContract:t.assetContractAddress,tokenId:t.tokenId,buyoutPricePerToken:r,currencyToAccept:a8(e=t.currencyContractAddress)?tQ:e,listingType:i.Direct,quantityToList:t.quantity,reservePricePerToken:r,secondsUntilEndTime:t.listingDurationInSeconds,startTime:f.O$.from(a)}],{gasLimit:5e5}),c=this.contractWrapper.parseLogs("ListingAdded",null==o?void 0:o.logs);return{id:c[0].args.listingId,receipt:o}}async makeOffer(t,e,r,a,n){if(a8(r))throw Error("You must use the wrapped native token address when making an offer with a native token");let i=await a4(this.contractWrapper.getProvider(),a,r);try{await this.getListing(t)}catch(s){throw console.error("Failed to get listing, err =",s),Error(`Error getting the listing with id ${t}`)}let o=f.O$.from(e),c=f.O$.from(i).mul(o),l=await this.contractWrapper.getCallOverrides()||{};await ne(this.contractWrapper,c,r,l);let d=x.Bz;return n&&(d=f.O$.from(Math.floor(n.getTime()/1e3))),{receipt:await this.contractWrapper.sendTransaction("offer",[t,e,r,i,d],l)}}async acceptOffer(t,e){await this.validateListing(f.O$.from(t));let r=await this.contractWrapper.readContract.offers(t,e);return{receipt:await this.contractWrapper.sendTransaction("acceptOffer",[t,e,r.currency,r.pricePerToken])}}async buyoutListing(t,e,r){let a=await this.validateListing(f.O$.from(t)),{valid:n,error:i}=await this.isStillValidListing(a,e);if(!n)throw Error(`Listing ${t} is no longer valid. ${i}`);let s=r||await this.contractWrapper.getSignerAddress(),o=f.O$.from(e),c=f.O$.from(a.buyoutPrice).mul(o),l=await this.contractWrapper.getCallOverrides()||{};return await ne(this.contractWrapper,c,a.currencyContractAddress,l),{receipt:await this.contractWrapper.sendTransaction("buy",[t,s,o,a.currencyContractAddress,c],l)}}async updateListing(t){return{receipt:await this.contractWrapper.sendTransaction("updateListing",[t.id,t.quantity,t.buyoutPrice,t.buyoutPrice,t.currencyContractAddress,t.startTimeInSeconds,t.secondsUntilEnd])}}async cancelListing(t){return{receipt:await this.contractWrapper.sendTransaction("cancelDirectListing",[t])}}async validateListing(t){try{return await this.getListing(t)}catch(e){throw console.error(`Error getting the listing with id ${t}`),e}}async mapListing(t){return{assetContractAddress:t.assetContract,buyoutPrice:f.O$.from(t.buyoutPricePerToken),currencyContractAddress:t.currency,buyoutCurrencyValuePerToken:await nt(this.contractWrapper.getProvider(),t.currency,t.buyoutPricePerToken),id:t.listingId.toString(),tokenId:t.tokenId,quantity:t.quantity,startTimeInSeconds:t.startTime,asset:await ax(t.assetContract,this.contractWrapper.getProvider(),t.tokenId,this.storage),secondsUntilEnd:t.endTime,sellerAddress:t.tokenOwner,type:i.Direct}}async isStillValidListing(t,e){let r=await nQ(this.contractWrapper.getProvider(),this.getAddress(),t.assetContractAddress,t.tokenId,t.sellerAddress);if(!r)return{valid:!1,error:`Token '${t.tokenId}' from contract '${t.assetContractAddress}' is not approved for transfer`};let a=this.contractWrapper.getProvider(),n=new F.CH(t.assetContractAddress,N,a),i=await n.supportsInterface(eE),s=await n.supportsInterface(eS);if(i){let o=new F.CH(t.assetContractAddress,D,a),c=(await o.ownerOf(t.tokenId)).toLowerCase()===t.sellerAddress.toLowerCase();return{valid:c,error:c?void 0:`Seller is not the owner of Token '${t.tokenId}' from contract '${t.assetContractAddress} anymore'`}}if(!s)return{valid:!1,error:"Contract does not implement ERC 1155 or ERC 721."};{let l=new F.CH(t.assetContractAddress,$,a),d=await l.balanceOf(t.sellerAddress,t.tokenId),p=d.gte(e||t.quantity);return{valid:p,error:p?void 0:`Seller does not have enough balance of Token '${t.tokenId}' from contract '${t.assetContractAddress} to fulfill the listing`}}}}class n2{constructor(t,e){(0,y._)(this,"contractWrapper",void 0),(0,y._)(this,"storage",void 0),(0,y._)(this,"encoder",void 0),this.contractWrapper=t,this.storage=e,this.encoder=new az(t)}getAddress(){return this.contractWrapper.readContract.address}async getListing(t){let e=await this.contractWrapper.readContract.listings(t);if(e.listingId.toString()!==t.toString())throw new eM(this.getAddress(),t.toString());if(e.listingType!==i.Auction)throw new ex(this.getAddress(),t.toString(),"Direct","Auction");return await this.mapListing(e)}async getWinningBid(t){await this.validateListing(f.O$.from(t));let e=await this.contractWrapper.readContract.winningBid(t);if(e.offeror!==C.d)return await n0(this.contractWrapper.getProvider(),f.O$.from(t),e)}async getWinner(t){let e=await this.validateListing(f.O$.from(t)),r=await this.contractWrapper.readContract.winningBid(t),a=f.O$.from(Math.floor(Date.now()/1e3)),n=f.O$.from(e.endTimeInEpochSeconds);if(a.gt(n)&&r.offeror!==C.d)return r.offeror;let i=await this.contractWrapper.readContract.queryFilter(this.contractWrapper.readContract.filters.AuctionClosed()),s=i.find(e=>e.args.listingId.eq(f.O$.from(t)));if(!s)throw Error(`Could not find auction with listingId ${t} in closed auctions`);return s.args.winningBidder}async createListing(t){var e;nX(t),await nK(this.contractWrapper.getSignerOrProvider(),this.getAddress(),t.assetContractAddress,t.tokenId,await this.contractWrapper.getSignerAddress());let r=await a4(this.contractWrapper.getProvider(),t.buyoutPricePerToken,t.currencyContractAddress),a=await a4(this.contractWrapper.getProvider(),t.reservePricePerToken,t.currencyContractAddress),n=Math.floor(t.startTimestamp.getTime()/1e3),s=await this.contractWrapper.getProvider().getBlock("latest"),o=s.timestamp;n<o&&(n=o);let c=await this.contractWrapper.sendTransaction("createListing",[{assetContract:t.assetContractAddress,tokenId:t.tokenId,buyoutPricePerToken:r,currencyToAccept:a8(e=t.currencyContractAddress)?tQ:e,listingType:i.Auction,quantityToList:t.quantity,reservePricePerToken:a,secondsUntilEndTime:t.listingDurationInSeconds,startTime:f.O$.from(n)}],{gasLimit:5e5}),l=this.contractWrapper.parseLogs("ListingAdded",null==c?void 0:c.logs);return{id:l[0].args.listingId,receipt:c}}async buyoutListing(t){let e=await this.validateListing(f.O$.from(t)),r=await a9(this.contractWrapper.getProvider(),e.currencyContractAddress);return this.makeBid(t,P.formatUnits(e.buyoutPrice,r.decimals))}async makeBid(t,e){let r=await this.validateListing(f.O$.from(t)),a=await a4(this.contractWrapper.getProvider(),e,r.currencyContractAddress);if(a.eq(f.O$.from(0)))throw Error("Cannot make a bid with 0 value");let n=await this.contractWrapper.readContract.bidBufferBps(),i=await this.getWinningBid(t);if(i){let s=function(t,e,r){if(r=f.O$.from(r),t=f.O$.from(t),e=f.O$.from(e),t.eq(f.O$.from(0)))return!1;let a=e.sub(t).mul(1e4).div(t);return a.gte(r)}(i.pricePerToken,a,n);(0,L.Z)(s,"Bid price is too low based on the current winning bid and the bid buffer")}else{let o=f.O$.from(r.reservePrice);(0,L.Z)(a.gte(o),"Bid price is too low based on reserve price")}let c=f.O$.from(r.quantity),l=a.mul(c),d=await this.contractWrapper.getCallOverrides()||{};return await ne(this.contractWrapper,l,r.currencyContractAddress,d),{receipt:await this.contractWrapper.sendTransaction("offer",[t,r.quantity,r.currencyContractAddress,a,x.Bz],d)}}async cancelListing(t){let e=await this.validateListing(f.O$.from(t)),r=f.O$.from(Math.floor(Date.now()/1e3)),a=f.O$.from(e.startTimeInEpochSeconds),n=await this.contractWrapper.readContract.winningBid(t);if(r.gt(a)&&n.offeror!==C.d)throw new eR(t.toString());return{receipt:await this.contractWrapper.sendTransaction("closeAuction",[f.O$.from(t),await this.contractWrapper.getSignerAddress()])}}async closeListing(t,e){e||(e=await this.contractWrapper.getSignerAddress());let r=await this.validateListing(f.O$.from(t));try{return{receipt:await this.contractWrapper.sendTransaction("closeAuction",[f.O$.from(t),e])}}catch(a){if(a.message.includes("cannot close auction before it has ended"))throw new eN(t.toString(),r.endTimeInEpochSeconds.toString());throw a}}async executeSale(t){let e=await this.validateListing(f.O$.from(t));try{let r=await this.getWinningBid(t);(0,L.Z)(r,"No winning bid found");let a=this.encoder.encode("closeAuction",[t,e.sellerAddress]),n=this.encoder.encode("closeAuction",[t,r.buyerAddress]);return await this.contractWrapper.multiCall([a,n])}catch(i){if(i.message.includes("cannot close auction before it has ended"))throw new eN(t.toString(),e.endTimeInEpochSeconds.toString());throw i}}async updateListing(t){return{receipt:await this.contractWrapper.sendTransaction("updateListing",[t.id,t.quantity,t.reservePrice,t.buyoutPrice,t.currencyContractAddress,t.startTimeInEpochSeconds,t.endTimeInEpochSeconds])}}async getBidBufferBps(){return this.contractWrapper.readContract.bidBufferBps()}async getMinimumNextBid(t){let[e,r,a]=await Promise.all([this.getBidBufferBps(),this.getWinningBid(t),await this.validateListing(f.O$.from(t))]),n=r?r.currencyValue.value:a.reservePrice,i=n.add(n.mul(e).div(1e4));return nt(this.contractWrapper.getProvider(),a.currencyContractAddress,i)}async validateListing(t){try{return await this.getListing(t)}catch(e){throw console.error(`Error getting the listing with id ${t}`),e}}async mapListing(t){return{assetContractAddress:t.assetContract,buyoutPrice:f.O$.from(t.buyoutPricePerToken),currencyContractAddress:t.currency,buyoutCurrencyValuePerToken:await nt(this.contractWrapper.getProvider(),t.currency,t.buyoutPricePerToken),id:t.listingId.toString(),tokenId:t.tokenId,quantity:t.quantity,startTimeInEpochSeconds:t.startTime,asset:await ax(t.assetContract,this.contractWrapper.getProvider(),t.tokenId,this.storage),reservePriceCurrencyValuePerToken:await nt(this.contractWrapper.getProvider(),t.currency,t.reservePricePerToken),reservePrice:f.O$.from(t.reservePricePerToken),endTimeInEpochSeconds:t.endTime,sellerAddress:t.tokenOwner,type:i.Auction}}}let n5=eh.merge(t1).merge(eb),n7=em.merge(t1).merge(eb),n3=n5.merge(ef).merge(ey).merge(ew),n6={deploy:n3,output:n7,input:n5},n8=eh.merge(eg).merge(eb),n4=em.merge(eg).merge(eb),n9=n8.merge(ew),it={deploy:n9,output:n4,input:n8},ie={name:"DropERC1155",contractType:"edition-drop",schema:eK,roles:["admin","minter","transfer"],initialize:async function(){for(var t=arguments.length,e=Array(t),a=0;a<t;a++)e[a]=arguments[a];let[n,i,s,o]=e,[,c]=aI(n,o),[l,d,p]=await Promise.all([ie.getAbi(),r.e(2811).then(r.bind(r,32811)),c.getNetwork()]);return new d.EditionDrop(n,i,s,o,l,p.chainId)},getAbi:async()=>(await r.e(44).then(r.t.bind(r,50044,19))).default},ir={name:"TokenERC1155",contractType:"edition",schema:ru,roles:["admin","minter","transfer"],initialize:async function(){for(var t=arguments.length,e=Array(t),a=0;a<t;a++)e[a]=arguments[a];let[n,i,s,o]=e,[,c]=aI(n,o),[l,d,p]=await Promise.all([ir.getAbi(),r.e(8808).then(r.bind(r,28808)),c.getNetwork()]);return new d.Edition(n,i,s,o,l,p.chainId)},getAbi:async()=>(await r.e(2610).then(r.t.bind(r,22610,19))).default},ia={name:"Marketplace",contractType:"marketplace",schema:e0,roles:["admin","lister","asset"],initialize:async function(){for(var t=arguments.length,e=Array(t),a=0;a<t;a++)e[a]=arguments[a];let[n,i,s,o]=e,[,c]=aI(n,o),[l,d,p]=await Promise.all([ia.getAbi(),r.e(4403).then(r.bind(r,74403)),c.getNetwork()]);return new d.Marketplace(n,i,s,o,l,p.chainId)},getAbi:async()=>(await r.e(4247).then(r.t.bind(r,94247,19))).default},ii={name:"Multiwrap",contractType:"multiwrap",schema:it,roles:["admin","transfer","minter","unwrap","asset"],initialize:async function(){for(var t=arguments.length,e=Array(t),a=0;a<t;a++)e[a]=arguments[a];let[n,i,s,o]=e,[,c]=aI(n,o),[l,d,p]=await Promise.all([ii.getAbi(),r.e(4454).then(r.bind(r,34454)),c.getNetwork()]);return new d.Multiwrap(n,i,s,o,l,p.chainId)},getAbi:async()=>(await r.e(6164).then(r.t.bind(r,86164,19))).default},is={name:"TokenERC721",contractType:"nft-collection",schema:rc,roles:["admin","minter","transfer"],initialize:async function(){for(var t=arguments.length,e=Array(t),a=0;a<t;a++)e[a]=arguments[a];let[n,i,s,o]=e,[,c]=aI(n,o),[l,d,p]=await Promise.all([is.getAbi(),r.e(1791).then(r.bind(r,71791)),c.getNetwork()]);return new d.NFTCollection(n,i,s,o,l,p.chainId)},getAbi:async()=>(await r.e(8777).then(r.t.bind(r,88777,19))).default},io={name:"DropERC721",contractType:"nft-drop",schema:eV,roles:["admin","minter","transfer"],initialize:async function(){for(var t=arguments.length,e=Array(t),a=0;a<t;a++)e[a]=arguments[a];let[n,i,s,o]=e,[,c]=aI(n,o),[l,d,p]=await Promise.all([io.getAbi(),r.e(3127).then(r.bind(r,13127)),c.getNetwork()]);return new d.NFTDrop(n,i,s,o,l,p.chainId)},getAbi:async()=>(await r.e(8110).then(r.t.bind(r,88110,19))).default},ic={name:"Pack",contractType:"pack",schema:e7,roles:["admin","minter","asset","transfer"],initialize:async function(){for(var t=arguments.length,e=Array(t),a=0;a<t;a++)e[a]=arguments[a];let[n,i,s,o]=e,[,c]=aI(n,o),[l,d,p]=await Promise.all([ic.getAbi(),r.e(267).then(r.bind(r,60267)),c.getNetwork()]);return new d.Pack(n,i,s,o,l,p.chainId)},getAbi:async()=>(await r.e(5236).then(r.t.bind(r,65236,19))).default},il={name:"SignatureDrop",contractType:"signature-drop",schema:eV,roles:["admin","minter","transfer"],initialize:async function(){for(var t=arguments.length,e=Array(t),a=0;a<t;a++)e[a]=arguments[a];let[n,i,s,o]=e,[,c]=aI(n,o),[l,d,p]=await Promise.all([il.getAbi(),r.e(2515).then(r.bind(r,52515)),c.getNetwork()]);return new d.SignatureDrop(n,i,s,o,l,p.chainId)},getAbi:async()=>(await r.e(3199).then(r.t.bind(r,33199,19))).default},id={name:"Split",contractType:"split",schema:rt,roles:["admin"],initialize:async function(){for(var t=arguments.length,e=Array(t),a=0;a<t;a++)e[a]=arguments[a];let[n,i,s,o]=e,[,c]=aI(n,o),[l,d,p]=await Promise.all([id.getAbi(),r.e(6607).then(r.bind(r,16607)),c.getNetwork()]);return new d.Split(n,i,s,o,l,p.chainId)},getAbi:async()=>(await r.e(4506).then(r.t.bind(r,64506,19))).default},ip={name:"DropERC20",contractType:"token-drop",schema:n6,roles:["admin","transfer"],initialize:async function(){for(var t=arguments.length,e=Array(t),a=0;a<t;a++)e[a]=arguments[a];let[n,i,s,o]=e,[,c]=aI(n,o),[l,d,p]=await Promise.all([ip.getAbi(),r.e(1621).then(r.bind(r,51621)),c.getNetwork()]);return new d.TokenDrop(n,i,s,o,l,p.chainId)},getAbi:async()=>(await r.e(7891).then(r.t.bind(r,37891,19))).default},iu={name:"TokenERC20",contractType:"token",schema:rn,roles:["admin","minter","transfer"],initialize:async function(){for(var t=arguments.length,e=Array(t),a=0;a<t;a++)e[a]=arguments[a];let[n,i,s,o]=e,[,c]=aI(n,o),[l,d,p]=await Promise.all([iu.getAbi(),r.e(7706).then(r.bind(r,37706)),c.getNetwork()]);return new d.Token(n,i,s,o,l,p.chainId)},getAbi:async()=>(await r.e(3028).then(r.t.bind(r,83028,19))).default},ih={name:"VoteERC20",contractType:"vote",schema:rw,roles:[],initialize:async function(){for(var t=arguments.length,e=Array(t),a=0;a<t;a++)e[a]=arguments[a];let[n,i,s,o]=e,[,c]=aI(n,o),[l,d,p]=await Promise.all([ih.getAbi(),r.e(2903).then(r.bind(r,12903)),c.getNetwork()]);return new d.Vote(n,i,s,o,l,p.chainId)},getAbi:async()=>(await r.e(9695).then(r.t.bind(r,59695,19))).default};ie.contractType,ir.contractType,ia.contractType,ii.contractType,is.contractType,io.contractType,ic.contractType,il.contractType,id.contractType,ip.contractType,iu.contractType,ih.contractType;class im{constructor(t){(0,y._)(this,"contractWrapper",void 0),this.contractWrapper=t}addTransactionListener(t){this.contractWrapper.addListener(n.Transaction,t)}removeTransactionListener(t){this.contractWrapper.off(n.Transaction,t)}addEventListener(t,e){let r=this.contractWrapper.readContract.interface.getEvent(t),a=this.contractWrapper.readContract.address,n={address:a,topics:[this.contractWrapper.readContract.interface.getEventTopic(r)]},i=t=>{let r=this.contractWrapper.readContract.interface.parseLog(t);e(this.toContractEvent(r.eventFragment,r.args,t))};return this.contractWrapper.getProvider().on(n,i),()=>{this.contractWrapper.getProvider().off(n,i)}}listenToAllEvents(t){let e=this.contractWrapper.readContract.address,r={address:e},a=e=>{try{let r=this.contractWrapper.readContract.interface.parseLog(e);t(this.toContractEvent(r.eventFragment,r.args,e))}catch(a){console.error("Could not parse event:",e,a)}};return this.contractWrapper.getProvider().on(r,a),()=>{this.contractWrapper.getProvider().off(r,a)}}removeEventListener(t,e){let r=this.contractWrapper.readContract.interface.getEvent(t);this.contractWrapper.readContract.off(r.name,e)}removeAllListeners(){this.contractWrapper.readContract.removeAllListeners();let t=this.contractWrapper.readContract.address;this.contractWrapper.getProvider().removeAllListeners({address:t})}async getAllEvents(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{fromBlock:0,toBlock:"latest",order:"desc"},e=await this.contractWrapper.readContract.queryFilter({},t.fromBlock,t.toBlock),r=e.sort((e,r)=>"desc"===t.order?r.blockNumber-e.blockNumber:e.blockNumber-r.blockNumber);return this.parseEvents(r)}async getEvents(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{fromBlock:0,toBlock:"latest",order:"desc"},r=this.contractWrapper.readContract.interface.getEvent(t),a=this.contractWrapper.readContract.filters[r.name],n=await this.contractWrapper.readContract.queryFilter(a(),e.fromBlock,e.toBlock),i=n.sort((t,r)=>"desc"===e.order?r.blockNumber-t.blockNumber:t.blockNumber-r.blockNumber);return this.parseEvents(i)}parseEvents(t){return t.map(t=>{let e=Object.fromEntries(Object.entries(t).filter(t=>"function"!=typeof t[1]&&"args"!==t[0]));if(t.args){let r=Object.entries(t.args),a=r.slice(r.length/2,r.length),n={};for(let[i,s]of a)n[i]=s;return{eventName:t.event||"",data:n,transaction:e}}return{eventName:t.event||"",data:{},transaction:e}})}toContractEvent(t,e,r){let a=Object.fromEntries(Object.entries(r).filter(t=>"function"!=typeof t[1]&&"args"!==t[0])),n={};return t.inputs.forEach((t,r)=>{if(Array.isArray(e[r])){let a={},i=t.components;if(i){let s=e[r];for(let o=0;o<i.length;o++){let c=i[o].name;a[c]=s[o]}n[t.name]=a}}else n[t.name]=e[r]}),{eventName:t.name,data:n,transaction:a}}}class ig{constructor(t){(0,y._)(this,"contractWrapper",void 0),this.contractWrapper=t}overrideNextTransaction(t){this.contractWrapper.withTransactionOverride(t)}}class iy{constructor(t){(0,y._)(this,"featureName",r1.name),(0,y._)(this,"contractWrapper",void 0),this.contractWrapper=t}async get(){let[t,e]=await this.contractWrapper.readContract.getPlatformFeeInfo();return ef.parse({platform_fee_recipient:t,platform_fee_basis_points:e})}async set(t){let e=ef.parse(t);return{receipt:await this.contractWrapper.sendTransaction("setPlatformFeeInfo",[e.platform_fee_recipient,e.platform_fee_basis_points])}}}class iw{constructor(t){(0,y._)(this,"featureName",r6.name),(0,y._)(this,"contractWrapper",void 0),this.contractWrapper=t}async get(){return this.contractWrapper.readContract.owner()}async set(t){return{receipt:await this.contractWrapper.sendTransaction("setOwner",[t])}}}let ib="https://paper.xyz/api/2022-08-12/platform/thirdweb",iv={[a.Mainnet]:"Ethereum",[a.Goerli]:"Goerli",[a.Polygon]:"Polygon",[a.Mumbai]:"Mumbai",[a.Avalanche]:"Avalanche"};async function iC(t,e){let r=((0,L.Z)(e in iv,`chainId not supported by paper: ${e}`),iv[e]),a=await G()(`${ib}/register-contract?contractAddress=${t}&chain=${r}`),n=await a.json();return(0,L.Z)(n.result.id,"Contract is not registered with paper"),n.result.id}let iW={expiresInMinutes:15,feeBearer:"BUYER",sendEmailOnSuccess:!0,redirectAfterPayment:!1};async function iA(t,e){let r=await G()(`${ib}/checkout-link-intent`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({contractId:t,...iW,...e,metadata:{...e.metadata,via_platform:"thirdweb"},hideNativeMint:!0,hidePaperWallet:!!e.walletAddress,hideExternalWallet:!0,hidePayWithCrypto:!0,usePaperKey:!1})}),a=await r.json();return(0,L.Z)(a.checkoutLinkIntentUrl,"Failed to create checkout link intent"),a.checkoutLinkIntentUrl}class iT{constructor(t){(0,y._)(this,"contractWrapper",void 0),this.contractWrapper=t}async getCheckoutId(){return iC(this.contractWrapper.readContract.address,await this.contractWrapper.getChainID())}async isEnabled(){try{return!!await this.getCheckoutId()}catch(t){return!1}}async createLinkIntent(t){return await iA(await this.getCheckoutId(),t)}}}}]);