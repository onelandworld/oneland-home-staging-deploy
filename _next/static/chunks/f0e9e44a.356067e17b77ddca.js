"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[2054],{18998:function(t,e,r){let a,i,n,s,o,c,l,d,p,f,h;r.d(e,{a7:function(){return eD},a8:function(){return eF},a9:function(){return eO},aD:function(){return ot},aH:function(){return s4},aK:function(){return op},aL:function(){return oh},aM:function(){return om},aO:function(){return od},aP:function(){return oc},aQ:function(){return ol},aR:function(){return oj},aT:function(){return o1},aU:function(){return sy},aW:function(){return oq},aX:function(){return oY},aY:function(){return oK},ab:function(){return eR},ac:function(){return eN},ah:function(){return a0},ai:function(){return sb},aj:function(){return sC},ak:function(){return sv},al:function(){return sW},am:function(){return sP},an:function(){return sD},ao:function(){return sF},ap:function(){return sz},as:function(){return sM},au:function(){return sQ},ax:function(){return sJ},bN:function(){return nq},bO:function(){return nj},bT:function(){return aE},bU:function(){return aT},bV:function(){return aS},bW:function(){return a_},bX:function(){return aP},bY:function(){return ax},b_:function(){return aD},bd:function(){return r5},bf:function(){return r6},bg:function(){return r8},bj:function(){return r3},bq:function(){return aX},c$:function(){return ak},cT:function(){return a2},cU:function(){return ex},cV:function(){return oi},cW:function(){return sE},cX:function(){return oe},cY:function(){return oa},cZ:function(){return or},c_:function(){return on},cd:function(){return eg},ce:function(){return ey},cg:function(){return eb},ci:function(){return ev},d0:function(){return rb},d1:function(){return rV},d2:function(){return rv},d3:function(){return ip},d4:function(){return ih},d5:function(){return iu},d6:function(){return oA},d7:function(){return sT},d8:function(){return rM},d9:function(){return rm},da:function(){return iT},db:function(){return ic},dc:function(){return rE},dd:function(){return rB},de:function(){return ob},df:function(){return rI},dg:function(){return rJ},e:function(){return cd},u:function(){return en}});var u,m,g,y,w,b=r(59189),C=r(9279),v=r(16441),W=r(5325),A=r(6881),k=r(37707),E=r(19485),T=r(2593),S=r(29251),_=r(99448),P=r(90967),x=r(97820),B=r(61744),D=r(67827),F=r(64146),O=r(21046),I=r(31886),R=r(38197),N=r(32046),L=r(83875),M=r(11388),z=r(84243),$=r(8198),U=r(93684),V=r(79911),q=r(86237),j=r(26219),G=r(68834),H=r(65660),Z=r(61303),J=r(71497),Y=r(49242),K=r(56880),Q=r(94317),X=r(13670),tt=r(79120),te=r(97604),tr=r(8187),ta=r(19362),ti=r(59190),tn=r(70332),ts=r(54730),to=r(36250),tc=r(85725),tl=r(38730),td=r(48507),tp=r(38398),tf=r(2090),th=r(86841),tu=r(49561),tm=r(80580),tg=r(40246),ty=r(54253),tw=r(91559),tb=r(8455),tC=r(40553),tv=r(26),tW=r(69392),tA=r(29526),tk=r(24601),tE=r(46878),tT=r(77033),tS=r(87033),t_=r(5158),tP=r(27761),tx=r(20583),tB=r(92355),tD=r(84194),tF=r(51121),tO=r(32484),tI=r(78435),tR=r(17249),tN=r(1604),tL=r(6475),tM=r(62822),tz=r.n(tM),t$=r(56371),tU=r(71770),tV=r(62555),tq=r(96200),tj=r(54098),tG=r.n(tj),tH=r(2177),tZ=r(82037),tJ=r(2162),tY=r(64063),tK=r.n(tY),tQ=r(57632),tX=r(25025),t0=r(34161),t1=r(50266),t2=r(98839),t5=r(65815),t6=r(52378),t8=r(55173),t3=r(46085),t4=r(51375),t7=r(43320),t9=r(83454),et=r(48764).Buffer;function ee(t,e,r){!function(t,e){if(e.has(t))throw TypeError("Cannot initialize the same private elements twice on an object")}(t,e),e.set(t,r)}function er(t,e,r){if(!e.has(t))throw TypeError("attempted to "+r+" private field on non-instance");return e.get(t)}function ea(t,e){var r=er(t,e,"get");return r.get?r.get.call(t):r.value}function ei(t,e,r){var a=er(t,e,"set");return!function(t,e,r){if(e.set)e.set.call(t,r);else{if(!e.writable)throw TypeError("attempted to set read only private field");e.value=r}}(t,a,r),r}let en=((u={})[u.Mainnet=1]="Mainnet",u[u.Goerli=5]="Goerli",u[u.Polygon=137]="Polygon",u[u.Mumbai=80001]="Mumbai",u[u.Localhost=1337]="Localhost",u[u.Hardhat=31337]="Hardhat",u[u.Fantom=250]="Fantom",u[u.FantomTestnet=4002]="FantomTestnet",u[u.Avalanche=43114]="Avalanche",u[u.AvalancheFujiTestnet=43113]="AvalancheFujiTestnet",u[u.Optimism=10]="Optimism",u[u.OptimismGoerli=420]="OptimismGoerli",u[u.Arbitrum=42161]="Arbitrum",u[u.ArbitrumGoerli=421613]="ArbitrumGoerli",u[u.BinanceSmartChainMainnet=56]="BinanceSmartChainMainnet",u[u.BinanceSmartChainTestnet=97]="BinanceSmartChainTestnet",u),es=[en.Mainnet,en.Goerli,en.Polygon,en.Mumbai,en.Fantom,en.FantomTestnet,en.Avalanche,en.AvalancheFujiTestnet,en.Optimism,en.OptimismGoerli,en.Arbitrum,en.ArbitrumGoerli,en.BinanceSmartChainMainnet,en.BinanceSmartChainTestnet,en.Hardhat,en.Localhost],eo=tL.gL9,ec="0xc82BbE41f2cF04e3a8efA18F7032BDD7f6d98a81",el="0x7c487845f98938Bb955B1D5AD069d9a30e4131fd",ed="0x5DBC7B840baa9daBcBe9D2492E45D7244B54A2A0",ep={[en.Mainnet]:{openzeppelinForwarder:ec,openzeppelinForwarderEOA:"0x76ce2CB1Ae48Fa067f4fb8c5f803111AE0B24BEA",biconomyForwarder:"0x84a0856b038eaAd1cC7E297cF34A7e72685A8693",twFactory:ed,twRegistry:el,twBYOCRegistry:C.d},[en.Goerli]:{openzeppelinForwarder:"0x5001A14CA6163143316a7C614e30e6041033Ac20",openzeppelinForwarderEOA:"0xe73c50cB9c5B378627ff625BB6e6725A4A5D65d2",biconomyForwarder:"0xE041608922d06a4F26C0d4c27d8bCD01daf1f792",twFactory:ed,twRegistry:el,twBYOCRegistry:"0xB1Bd9d7942A250BA2Dce27DD601F2ED4211A60C4"},[en.Polygon]:{openzeppelinForwarder:ec,openzeppelinForwarderEOA:"0x4f247c69184ad61036EC2Bb3213b69F10FbEDe1F",biconomyForwarder:"0x86C80a8aa58e0A4fa09A69624c31Ab2a6CAD56b8",twFactory:ed,twRegistry:el,twBYOCRegistry:"0x308473Be900F4185A56587dE54bDFF5E8f7a6AE7"},[en.Mumbai]:{openzeppelinForwarder:ec,openzeppelinForwarderEOA:"0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",biconomyForwarder:"0x9399BB24DBB5C4b782C70c2969F58716Ebbd6a3b",twFactory:ed,twRegistry:el,twBYOCRegistry:"0x3F17972CB27506eb4a6a3D59659e0B57a43fd16C"},[en.Avalanche]:{openzeppelinForwarder:ec,openzeppelinForwarderEOA:"0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",biconomyForwarder:"0x64CD353384109423a966dCd3Aa30D884C9b2E057",twFactory:ed,twRegistry:el,twBYOCRegistry:C.d},[en.AvalancheFujiTestnet]:{openzeppelinForwarder:ec,openzeppelinForwarderEOA:"0xe73c50cB9c5B378627ff625BB6e6725A4A5D65d2",biconomyForwarder:"0x6271Ca63D30507f2Dcbf99B52787032506D75BBF",twFactory:ed,twRegistry:el,twBYOCRegistry:"0x3E6eE864f850F5e5A98bc950B68E181Cf4010F23"},[en.Fantom]:{openzeppelinForwarder:ec,openzeppelinForwarderEOA:"0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",biconomyForwarder:"0x64CD353384109423a966dCd3Aa30D884C9b2E057",twFactory:"0x97EA0Fcc552D5A8Fb5e9101316AAd0D62Ea0876B",twRegistry:el,twBYOCRegistry:C.d},[en.FantomTestnet]:{openzeppelinForwarder:ec,openzeppelinForwarderEOA:"0x42D3048b595B6e1c28a588d70366CcC2AA4dB47b",biconomyForwarder:"0x69FB8Dca8067A5D38703b9e8b39cf2D51473E4b4",twFactory:ed,twRegistry:el,twBYOCRegistry:"0x3E6eE864f850F5e5A98bc950B68E181Cf4010F23"},[en.Arbitrum]:{openzeppelinForwarder:"0x8cbc8B5d71702032904750A66AEfE8B603eBC538",openzeppelinForwarderEOA:"0x4f247c69184ad61036EC2Bb3213b69F10FbEDe1F",biconomyForwarder:"0xfe0fa3C06d03bDC7fb49c892BbB39113B534fB57",twFactory:"0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",twRegistry:"0x7c487845f98938Bb955B1D5AD069d9a30e4131fd",twBYOCRegistry:C.d},[en.ArbitrumGoerli]:{openzeppelinForwarder:"0x8cbc8B5d71702032904750A66AEfE8B603eBC538",openzeppelinForwarderEOA:"0x119704314Ef304EaAAE4b3c7C9ABd59272A28310",biconomyForwarder:C.d,twFactory:"0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",twRegistry:"0x7c487845f98938Bb955B1D5AD069d9a30e4131fd",twBYOCRegistry:C.d},[en.Optimism]:{openzeppelinForwarder:"0x8cbc8B5d71702032904750A66AEfE8B603eBC538",openzeppelinForwarderEOA:"0x7e80648EB2071E26937F9D42A513ccf4815fc702",biconomyForwarder:"0xefba8a2a82ec1fb1273806174f5e28fbb917cf95",twFactory:"0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",twRegistry:"0x7c487845f98938Bb955B1D5AD069d9a30e4131fd",twBYOCRegistry:C.d},[en.OptimismGoerli]:{openzeppelinForwarder:"0x8cbc8B5d71702032904750A66AEfE8B603eBC538",openzeppelinForwarderEOA:"0x119704314Ef304EaAAE4b3c7C9ABd59272A28310",biconomyForwarder:C.d,twFactory:"0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",twRegistry:"0x7c487845f98938Bb955B1D5AD069d9a30e4131fd",twBYOCRegistry:C.d},[en.BinanceSmartChainMainnet]:{openzeppelinForwarder:"0x8cbc8B5d71702032904750A66AEfE8B603eBC538",openzeppelinForwarderEOA:"0xE8dd2Ff0212F86d3197b4AfDC6dAC6ac47eb10aC",biconomyForwarder:"0x86C80a8aa58e0A4fa09A69624c31Ab2a6CAD56b8",twBYOCRegistry:C.d,twFactory:"0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",twRegistry:"0x7c487845f98938Bb955B1D5AD069d9a30e4131fd"},[en.BinanceSmartChainTestnet]:{openzeppelinForwarder:"0x8cbc8B5d71702032904750A66AEfE8B603eBC538",openzeppelinForwarderEOA:"0x7e80648EB2071E26937F9D42A513ccf4815fc702",biconomyForwarder:"0x61456BF1715C1415730076BB79ae118E806E74d2",twBYOCRegistry:C.d,twFactory:"0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",twRegistry:"0x7c487845f98938Bb955B1D5AD069d9a30e4131fd"},[en.Hardhat]:{openzeppelinForwarder:C.d,openzeppelinForwarderEOA:C.d,biconomyForwarder:C.d,twFactory:C.d,twRegistry:C.d,twBYOCRegistry:C.d},[en.Localhost]:{openzeppelinForwarder:C.d,openzeppelinForwarderEOA:C.d,biconomyForwarder:C.d,twFactory:C.d,twRegistry:C.d,twBYOCRegistry:C.d}},ef={[en.Mainnet]:{"nft-drop":"0x60fF9952e0084A6DEac44203838cDC91ABeC8736","edition-drop":"0x74af262d0671F378F97a1EDC3d0970Dbe8A1C550","token-drop":"0xE1eE43D23f247b6A9aF81fcE2766E76709482728","signature-drop":"0x6fD690EB509BdE4C50028C5D9C0dE3750C2Fad6A"},[en.Polygon]:{"nft-drop":"0xB96508050Ba0925256184103560EBADA912Fcc69","edition-drop":"0x74af262d0671F378F97a1EDC3d0970Dbe8A1C550","token-drop":"0x5A8eA4Adad8289746D073947BA06D69A62499aaf","signature-drop":"0xBE2fDc35410E268e41Bec62DBb01AEb43245c7d5"},[en.Fantom]:{"nft-drop":"0x2A396b2D90BAcEF19cDa973586B2633d22710fC2","edition-drop":"0x06395FCF9AC6ED827f9dD6e776809cEF1Be0d21B","token-drop":"0x0148b28a38efaaC31b6aa0a6D9FEb70FE7C91FFa","signature-drop":"0xe135Ef65C2B2213C3fD56d0Bd6500A2cA147aC10"},[en.Avalanche]:{"nft-drop":"0x9cF91118C8ee2913F0588e0F10e36B3d63F68bF6","edition-drop":"0x135fC9D26E5eC51260ece1DF4ED424E2f55c7766","token-drop":"0xca0B071899E575BA86495D46c5066971b6f3A901","signature-drop":"0x1d47526C3292B0130ef0afD5F02c1DA052A017B3"},[en.Optimism]:{"nft-drop":"0xFBd7D24d80ee005671E731a7287DEB6073264dD1","edition-drop":"0xe135Ef65C2B2213C3fD56d0Bd6500A2cA147aC10","token-drop":"0x902Dd246e66d8C3CE652375a723F2a52b43b9AAE","signature-drop":"0x8a4cd3549e548bbEEb38C16E041FFf040a5acabD"},[en.Arbitrum]:{"nft-drop":"0xC4903c1Ff5367b9ac2c349B63DC2409421AaEE2a","edition-drop":"0xCcddcec1831646Beff2753249f1B9C580327E89F","token-drop":"0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9","signature-drop":"0x2dF9851af45dd41C8584ac55D983C604da985Bc7"},[en.BinanceSmartChainMainnet]:{"nft-drop":"0x902Dd246e66d8C3CE652375a723F2a52b43b9AAE","edition-drop":"0x2A396b2D90BAcEF19cDa973586B2633d22710fC2","token-drop":"0xe135Ef65C2B2213C3fD56d0Bd6500A2cA147aC10","signature-drop":"0xFBd7D24d80ee005671E731a7287DEB6073264dD1"},[en.Goerli]:{"nft-drop":"0xD11c97DD5F5546B5bBd630D7D1d7327481B0b92C","edition-drop":"0x5A8eA4Adad8289746D073947BA06D69A62499aaf","token-drop":"0x5680933221B752EB443654a014f88B101F868d50","signature-drop":"0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9"},[en.Mumbai]:{"nft-drop":"0xC4903c1Ff5367b9ac2c349B63DC2409421AaEE2a","edition-drop":"0xCcddcec1831646Beff2753249f1B9C580327E89F","token-drop":"0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9","signature-drop":"0x2dF9851af45dd41C8584ac55D983C604da985Bc7"},[en.FantomTestnet]:{"nft-drop":"0x8a4cd3549e548bbEEb38C16E041FFf040a5acabD","edition-drop":"0x902Dd246e66d8C3CE652375a723F2a52b43b9AAE","token-drop":"0xFBd7D24d80ee005671E731a7287DEB6073264dD1","signature-drop":"0x5A8eA4Adad8289746D073947BA06D69A62499aaf"},[en.AvalancheFujiTestnet]:{"nft-drop":"0xD11c97DD5F5546B5bBd630D7D1d7327481B0b92C","edition-drop":"0xE1eE43D23f247b6A9aF81fcE2766E76709482728","token-drop":"0x6fD690EB509BdE4C50028C5D9C0dE3750C2Fad6A","signature-drop":"0xCcddcec1831646Beff2753249f1B9C580327E89F"},[en.OptimismGoerli]:{"nft-drop":"0xCcddcec1831646Beff2753249f1B9C580327E89F","edition-drop":"0x6fD690EB509BdE4C50028C5D9C0dE3750C2Fad6A","token-drop":"0xD11c97DD5F5546B5bBd630D7D1d7327481B0b92C","signature-drop":"0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9"},[en.ArbitrumGoerli]:{"nft-drop":"0x9CfE807a5b124b962064Fa8F7FD823Cc701255b6","edition-drop":"0x9cF91118C8ee2913F0588e0F10e36B3d63F68bF6","token-drop":"0x1d47526C3292B0130ef0afD5F02c1DA052A017B3","signature-drop":"0xE1eE43D23f247b6A9aF81fcE2766E76709482728"},[en.BinanceSmartChainTestnet]:{"nft-drop":"","edition-drop":"","token-drop":"","signature-drop":""},[en.Hardhat]:{"nft-drop":"","edition-drop":"","token-drop":"","signature-drop":""},[en.Localhost]:{"nft-drop":"","edition-drop":"","token-drop":"","signature-drop":""}};function eh(t,e){return t===en.Hardhat||t===en.Localhost?"twFactory"===e?t9.env.factoryAddress:"twRegistry"===e?t9.env.registryAddress:C.d:ep[t]?.[e]}function eu(){return t9.env.multiChainRegistryAddress?t9.env.multiChainRegistryAddress:"0xcdAD8FA86e18538aC207872E8ff3536501431B73"}function em(t){let e=es.find(e=>e===t),r=e?ep[e].biconomyForwarder:C.d,a=e?ep[e].openzeppelinForwarder:C.d;return r!==C.d?[a,r]:[a]}let eg=v.arrayify("0x80ac58cd"),ey=v.arrayify("0xd9b67a26"),ew="0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",eb={[en.Mainnet]:{name:"Ether",symbol:"ETH",decimals:18,wrapped:{address:"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",name:"Wrapped Ether",symbol:"WETH"}},[en.Goerli]:{name:"G\xf6rli Ether",symbol:"GOR",decimals:18,wrapped:{address:"0xb4fbf271143f4fbf7b91a5ded31805e42b2208d6",name:"Wrapped Ether",symbol:"WETH"}},[en.Polygon]:{name:"Matic",symbol:"MATIC",decimals:18,wrapped:{address:"0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270",name:"Wrapped Matic",symbol:"WMATIC"}},[en.Mumbai]:{name:"Matic",symbol:"MATIC",decimals:18,wrapped:{address:"0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889",name:"Wrapped Matic",symbol:"WMATIC"}},[en.Avalanche]:{name:"Avalanche",symbol:"AVAX",decimals:18,wrapped:{address:"0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7",name:"Wrapped AVAX",symbol:"WAVAX"}},[en.AvalancheFujiTestnet]:{name:"Avalanche",symbol:"AVAX",decimals:18,wrapped:{address:"0xd00ae08403B9bbb9124bB305C09058E32C39A48c",name:"Wrapped AVAX",symbol:"WAVAX"}},[en.Fantom]:{name:"Fantom",symbol:"FTM",decimals:18,wrapped:{address:"0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83",name:"Wrapped Fantom",symbol:"WFTM"}},[en.FantomTestnet]:{name:"Fantom",symbol:"FTM",decimals:18,wrapped:{address:"0xf1277d1Ed8AD466beddF92ef448A132661956621",name:"Wrapped Fantom",symbol:"WFTM"}},[en.Arbitrum]:{name:"Ether",symbol:"ETH",decimals:18,wrapped:{address:"0x82af49447d8a07e3bd95bd0d56f35241523fbab1",name:"Wrapped Ether",symbol:"WETH"}},[en.ArbitrumGoerli]:{name:"Arbitrum Goerli Ether",symbol:"AGOR",decimals:18,wrapped:{address:"0xe39Ab88f8A4777030A534146A9Ca3B52bd5D43A3",name:"Wrapped Ether",symbol:"WETH"}},[en.Optimism]:{name:"Ether",symbol:"ETH",decimals:18,wrapped:{address:"0x4200000000000000000000000000000000000006",name:"Wrapped Ether",symbol:"WETH"}},[en.OptimismGoerli]:{name:"Goerli Ether",symbol:"ETH",decimals:18,wrapped:{address:"0x4200000000000000000000000000000000000006",name:"Wrapped Ether",symbol:"WETH"}},[en.BinanceSmartChainMainnet]:{name:"Binance Chain Native Token",symbol:"BNB",decimals:18,wrapped:{address:"0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",name:"Wrapped Binance Chain Token",symbol:"WBNB"}},[en.BinanceSmartChainTestnet]:{name:"Binance Chain Native Token",symbol:"TBNB",decimals:18,wrapped:{address:"0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd",name:"Wrapped Binance Chain Testnet Token",symbol:"WBNB"}},[en.Hardhat]:{name:"Ether",symbol:"ETH",decimals:18,wrapped:{address:"0x5FbDB2315678afecb367f032d93F642f64180aa3",name:"Wrapped Ether",symbol:"WETH"}},[en.Localhost]:{name:"Ether",symbol:"ETH",decimals:18,wrapped:{address:"0x5FbDB2315678afecb367f032d93F642f64180aa3",name:"Wrapped Ether",symbol:"WETH"}},84531:{name:"Base Goerli Testnet",symbol:"ETH",decimals:18,wrapped:{address:"0x4200000000000000000000000000000000000006",name:"Wrapped Ether",symbol:"WETH"}}};function eC(t){let e=eo.find(e=>e.chainId===t);return e&&e.nativeCurrency?{name:e.nativeCurrency.name,symbol:e.nativeCurrency.symbol,decimals:18,wrapped:{address:C.d,name:`Wrapped ${e.nativeCurrency.name}`,symbol:`W${e.nativeCurrency.symbol}`}}:eb[t]||{name:"Ether",symbol:"ETH",decimals:18,wrapped:{address:C.d,name:"Wrapped Ether",symbol:"WETH"}}}let ev={[en.Mainnet]:"0x514910771AF9Ca656af840dff83E8264EcF986CA",[en.Goerli]:"0x326C977E6efc84E512bB9C30f76E30c160eD06FB",[en.BinanceSmartChainMainnet]:"0x404460C6A5EdE2D891e8297795264fDe62ADBB75",[en.Polygon]:"0xb0897686c545045aFc77CF20eC7A532E3120E0F1",[en.Mumbai]:"0x326C977E6efc84E512bB9C30f76E30c160eD06FB",[en.Avalanche]:"0x5947BB275c521040051D82396192181b413227A3",[en.AvalancheFujiTestnet]:"0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846",[en.Fantom]:"0x6F43FF82CCA38001B6699a8AC47A2d0E66939407",[en.FantomTestnet]:"0xfaFedb041c0DD4fA2Dc0d87a6B0979Ee6FA7af5F"},eW=((m={}).Transaction="transaction",m.Signature="signature",m);function eA(t){return!!(t&&t._isSigner)}function ek(t){return!!(t&&t._isProvider)}function eE(t,e){let r,a;if(eA(t)?(r=t,t.provider&&(a=t.provider)):a=ek(t)?t:rY(t,e),e?.readonlySettings&&(a=rX(e.readonlySettings.rpcUrl,e.readonlySettings.chainId)),!a){if(r)throw Error("No provider passed to the SDK! Please make sure that your signer is connected to a provider!");throw Error("No provider found! Make sure to specify which network to connect to, or pass a signer or provider to the SDK!")}return[r,a]}let eT={timeLimitMs:50,sizeLimit:250};class eS extends W.c{constructor(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:eT;super(t,e),(0,tR._)(this,"_timeLimitMs",void 0),(0,tR._)(this,"_sizeLimit",void 0),(0,tR._)(this,"_pendingBatchAggregator",void 0),(0,tR._)(this,"_pendingBatch",void 0),this._timeLimitMs=r.timeLimitMs||250,this._sizeLimit=r.sizeLimit||50,this._pendingBatchAggregator=null,this._pendingBatch=null}sendCurrentBatch(t){this._pendingBatchAggregator&&clearTimeout(this._pendingBatchAggregator);let e=this._pendingBatch||[];this._pendingBatch=null,this._pendingBatchAggregator=null;let r=e.map(t=>t.request);return this.emit("debug",{action:"requestBatch",request:A.deepCopy(t),provider:this}),k.fetchJson(this.connection,JSON.stringify(r)).then(t=>{this.emit("debug",{action:"response",request:r,response:t,provider:this}),e.forEach((e,r)=>{let a=t[r];if(a){if(a.error){let i=Error(a.error.message);i.code=a.error.code,i.data=a.error.data,e.reject(i)}else e.resolve(a.result)}else e.reject(Error("No response for request"))})},t=>{this.emit("debug",{action:"response",error:t,request:r,provider:this}),e.forEach(e=>{e.reject(t)})})}send(t,e){let r={method:t,params:e,id:this._nextId++,jsonrpc:"2.0"};null===this._pendingBatch&&(this._pendingBatch=[]);let a={request:r,resolve:null,reject:null},i=new Promise((t,e)=>{a.resolve=t,a.reject=e});return this._pendingBatch.push(a),this._pendingBatch.length===this._sizeLimit&&this.sendCurrentBatch(r),this._pendingBatchAggregator||(this._pendingBatchAggregator=setTimeout(()=>{this.sendCurrentBatch(r)},this._timeLimitMs)),i}}let e_=new Map;async function eP(t){let e,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;a||(a=eE("ethereum")[1]),e=e_.has(t)?e_.get(t):a.resolveName(t).then(t=>t?{address:t,expirationTime:new Date(Date.now()+3e5)}:{address:null,expirationTime:new Date(Date.now()+3e4)});let i=await e;return i.expirationTime<new Date&&(e_.delete(t),0===r&&eP(t,r+1)),i.address}async function ex(t){return eR.parseAsync(t)}let eB=tN.z.custom(t=>"string"==typeof t&&(t.endsWith(".eth")||t.endsWith(".cb.id"))).transform(async t=>eP(t)).refine(t=>!!t&&E.isAddress(t),{message:"Provided value was not a valid ENS name"}),eD=tN.z.union([tN.z.string(),tN.z.number(),tN.z.bigint(),tN.z.custom(t=>T.O$.isBigNumber(t))]).transform(t=>T.O$.from(t)),eF=eD.transform(t=>t.toString()),eO=tN.z.union([tN.z.bigint(),tN.z.custom(t=>T.O$.isBigNumber(t))]).transform(t=>T.O$.from(t).toString()),eI=tN.z.custom(t=>"string"==typeof t&&E.isAddress(t),t=>({message:`${t} is not a valid address`})),eR=tN.z.union([eI,eB],{invalid_type_error:"Provided value was not a valid address or ENS name"}),eN=tN.z.union([tN.z.date().transform(t=>T.O$.from(Math.floor(t.getTime()/1e3))),tN.z.number().transform(t=>T.O$.from(t))]),eL=eN.default(new Date(0)),eM=eN.default(new Date(Date.now()+31536e7)),ez=tN.z.object({gasLimit:eF.optional(),gasPrice:eF.optional(),maxFeePerGas:eF.optional(),maxPriorityFeePerGas:eF.optional(),nonce:eF.optional(),value:eF.optional(),blockTag:tN.z.union([tN.z.string(),tN.z.number()]).optional(),from:eR.optional(),type:tN.z.number().optional()}).strict(),e$=tN.z.object({rpc:tN.z.array(tN.z.string().url()),chainId:tN.z.number(),nativeCurrency:tN.z.object({name:tN.z.string(),symbol:tN.z.string(),decimals:tN.z.number()}),slug:tN.z.string()}),eU=tN.z.object({supportedChains:tN.z.array(e$).default(tL.gL9),thirdwebApiKey:tN.z.string().default(tR.D),alchemyApiKey:tN.z.string().optional(),infuraApiKey:tN.z.string().optional(),readonlySettings:tN.z.object({rpcUrl:tN.z.string().url(),chainId:tN.z.number().optional()}).optional(),gasSettings:tN.z.object({maxPriceInGwei:tN.z.number().min(1,"gas price cannot be less than 1").default(300),speed:tN.z.enum(["standard","fast","fastest"]).default("fastest")}).default({maxPriceInGwei:300,speed:"fastest"}),gasless:tN.z.union([tN.z.object({openzeppelin:tN.z.object({relayerUrl:tN.z.string().url(),relayerForwarderAddress:tN.z.string().optional(),useEOAForwarder:tN.z.boolean().default(!1)}),experimentalChainlessSupport:tN.z.boolean().default(!1)}),tN.z.object({biconomy:tN.z.object({apiId:tN.z.string(),apiKey:tN.z.string(),deadlineSeconds:tN.z.number().min(1,"deadlineSeconds cannot be les than 1").default(3600)})})]).optional(),gatewayUrls:tN.z.array(tN.z.string()).optional()}).default({gasSettings:{maxPriceInGwei:300,speed:"fastest"}}),eV=tN.z.object({name:tN.z.string(),symbol:tN.z.string(),decimals:tN.z.number()}),eq=eV.extend({value:eD,displayValue:tN.z.string()}),ej=tN.z.object({merkle:tN.z.record(tN.z.string()).default({})}),eG=tN.z.object({address:eR,maxClaimable:tR.Q.default(0),price:tR.Q.optional(),currencyAddress:eR.default(C.d).optional()}),eH=tN.z.union([tN.z.array(tN.z.string()).transform(async t=>await Promise.all(t.map(t=>eG.parseAsync({address:t})))),tN.z.array(eG)]),eZ=eG.extend({proof:tN.z.array(tN.z.string())}),eJ=tN.z.object({merkleRoot:tN.z.string(),claims:tN.z.array(eZ)});tN.z.object({merkleRoot:tN.z.string(),snapshotUri:tN.z.string()});let eY=tN.z.object({name:tN.z.string().optional()}).catchall(tN.z.unknown()),eK=tN.z.object({startTime:eL,currencyAddress:tN.z.string().default(ew),price:tR.A.default(0),maxClaimableSupply:tR.Q,maxClaimablePerWallet:tR.Q,waitInSeconds:eF.default(0),merkleRootHash:tR.B.default(v.hexZeroPad([0],32)),snapshot:tN.z.optional(eH).nullable(),metadata:eY.optional()}),eQ=tN.z.array(eK);eK.partial();let eX=eK.extend({availableSupply:tR.Q,currentMintSupply:tR.Q,currencyMetadata:eq.default({value:T.O$.from("0"),displayValue:"0",symbol:"",decimals:18,name:""}),price:eD,waitInSeconds:eD,startTime:eD.transform(t=>new Date(1e3*t.toNumber())),snapshot:eH.optional().nullable()}),e0=tN.z.object({to:eR.refine(t=>t.toLowerCase()!==C.d,{message:"Cannot create payload to mint to zero address"}),price:tR.A.default(0),currencyAddress:eI.default(ew),mintStartTime:eL,mintEndTime:eM,uid:tN.z.string().optional().transform(t=>(function(t){if(void 0!==t)return v.hexlify(t);{let e=et.alloc(16);return(0,tQ.Z)({},e),v.hexlify(S.Y0(e.toString("hex")))}})(t)),primarySaleRecipient:eR.default(C.d)}),e1=e0.extend({quantity:tR.A}),e2=e1.extend({mintStartTime:eD,mintEndTime:eD}),e5=e0.extend({metadata:tR.N,royaltyRecipient:tN.z.string().default(C.d),royaltyBps:tR.a.default(0)}),e6=e5.extend({metadata:tR.N.default(""),uri:tN.z.string(),royaltyBps:eD,mintStartTime:eD,mintEndTime:eD}),e8=e5.extend({metadata:tR.N.default(""),quantity:eF}),e3=e8.extend({tokenId:eF}),e4=e6.extend({tokenId:eD,quantity:eD}),e7=e5.extend({metadata:tR.N.default(""),quantity:eD.default(1)}),e9=e6.extend({quantity:eD.default(1)}),rt=[{name:"to",type:"address"},{name:"primarySaleRecipient",type:"address"},{name:"quantity",type:"uint256"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],re=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],rr=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"tokenId",type:"uint256"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],ra=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],ri=[{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"},{name:"data",type:"bytes"}],rn=tN.z.object({name:tN.z.string(),description:tN.z.string().optional(),image:tR.F.optional(),external_link:tN.z.string().optional(),app_uri:tN.z.string().optional()}),rs=rn.extend({image:tN.z.string().optional()}).catchall(tN.z.unknown()),ro=tN.z.object({seller_fee_basis_points:tR.a.default(0),fee_recipient:eR.default(C.d)}),rc=tN.z.object({primary_sale_recipient:eR}),rl=tN.z.object({platform_fee_basis_points:tR.a.default(0),platform_fee_recipient:eR.default(C.d)}),rd=tN.z.object({trusted_forwarders:tN.z.array(eR).default([])}),rp=tN.z.object({symbol:tN.z.string().default("")}),rf=rn.merge(ro).merge(ej).merge(rp),rh=rs.merge(ro).merge(ej).merge(rp),ru=rf.merge(rl).merge(rc).merge(rd),rm={deploy:ru,output:rh,input:rf},rg=rn.merge(ro).merge(ej).merge(rp),ry=rs.merge(ro).merge(ej).merge(rp),rw=rg.merge(rl).merge(rc).merge(rd),rb={deploy:rw,output:ry,input:rg},rC=rn.merge(rl).merge(rd),rv={deploy:rC,output:rs,input:rn},rW=rn.merge(ro).merge(rp),rA=rs.merge(ro).merge(rp),rk=rW.merge(rl).merge(rd),rE={deploy:rk,output:rA,input:rW},rT=tN.z.object({address:eR,sharesBps:tR.a.gt(0,"Shares must be greater than 0")}),rS=rT.extend({address:eR,sharesBps:tR.a}),r_=rn.extend({recipients:tN.z.array(rT).default([]).superRefine((t,e)=>{let r={},a=0;for(let i=0;i<t.length;i++){let n=t[i];r[n.address]&&e.addIssue({code:tN.z.ZodIssueCode.custom,message:"Duplicate address.",path:[i,"address"]}),r[n.address]=!0,(a+=n.sharesBps)>1e4&&e.addIssue({code:tN.z.ZodIssueCode.custom,message:"Total shares cannot go over 100%.",path:[i,"sharesBps"]})}1e4!==a&&e.addIssue({code:tN.z.ZodIssueCode.custom,message:`Total shares need to add up to 100%. Total shares are currently ${a/100}%`,path:[]})})}),rP=rs.extend({recipients:tN.z.array(rS)}),rx=r_.merge(r_).merge(rd),rB={deploy:rx,output:rP,input:r_},rD=rn.merge(rp),rF=rs.merge(rp),rO=rD.merge(rl).merge(rc).merge(rd),rI={deploy:rO,output:rF,input:rD},rR=rn.merge(ro).merge(rp),rN=rs.merge(ro).merge(rp),rL=rR.merge(rl).merge(rc).merge(rd),rM={deploy:rL,output:rN,input:rR},rz=rn.merge(ro).merge(rp),r$=rs.merge(ro).merge(rp),rU=rz.merge(rl).merge(rc).merge(rd),rV={deploy:rU,output:r$,input:rz},rq=tN.z.object({voting_delay_in_blocks:tN.z.number().min(0).default(0),voting_period_in_blocks:tN.z.number().min(1).default(1),voting_token_address:eR,voting_quorum_fraction:tR.P.default(0),proposal_token_threshold:eF.default(1)}),rj=rq.extend({proposal_token_threshold:eD}),rG=rn.merge(rq),rH=rs.merge(rj),rZ=rG.merge(rd),rJ={deploy:rZ,output:rH,input:rG};function rY(t,e){let r;if("string"==typeof t&&function(t){let e=t.match(/^(ws|http)s?:/i);if(e)switch(e[1].toLowerCase()){case"http":case"https":case"ws":case"wss":return!0}return!1}(t))return rX(t);let a=eU.parse(e);rK(t)&&(a.supportedChains=[t,...a.supportedChains]);let i=a.supportedChains.reduce((t,e)=>(t[e.chainId]=e,t),{}),n="";try{r=function(t,e){if(rK(t))return t.chainId;if("number"==typeof t)return t;{let r=e.supportedChains.reduce((t,e)=>(t[e.slug]=e.chainId,t),{});if(t in r)return r[t]}throw Error(`Cannot resolve chainId from: ${t} - please pass the chainId instead and specify it in the 'supportedChains' property of the SDK options.`)}(t,a),n=(0,tL.NXR)(i[r],{thirdwebApiKey:a.thirdwebApiKey||tR.D,infuraApiKey:a.infuraApiKey,alchemyApiKey:a.alchemyApiKey})}catch(s){}if(n||(n=`https://${r||t}.rpc.thirdweb.com/${a.thirdwebApiKey||tR.D}`),!n)throw Error(`No rpc url found for chain ${t}. Please provide a valid rpc url via the 'supportedChains' property of the sdk options.`);return rX(n,r)}function rK(t){return"string"!=typeof t&&"number"!=typeof t&&!eA(t)&&!ek(t)}tN.z.object({proposalId:eD,proposer:tN.z.string(),targets:tN.z.array(tN.z.string()),values:tN.z.array(eD),signatures:tN.z.array(tN.z.string()),calldatas:tN.z.array(tN.z.string()),startBlock:eD,endBlock:eD,description:tN.z.string()});let rQ=new Map;function rX(t,e){try{let r=t.match(/^(ws|http)s?:/i);if(r)switch(r[1].toLowerCase()){case"http":case"https":let a=`${t}-${e||-1}`,i=rQ.get(a);if(i)return i;let n=e?new eS(t,e):new _.I(t);return rQ.set(a,n),n;case"ws":case"wss":return new P.q(t,e)}}catch(s){}return x.getDefaultProvider(t)}class r0 extends Error{constructor(t){super(t?`Object with id ${t} NOT FOUND`:"NOT_FOUND")}}class r1 extends Error{constructor(t,e){super(`MISSING ROLE: ${t} does not have the '${e}' role`)}}class r2 extends Error{constructor(t){super(`DUPLICATE_LEAFS${t?` : ${t}`:""}`)}}class r5 extends Error{constructor(t){super(`Auction already started with existing bid${t?`, id: ${t}`:""}`)}}class r6 extends Error{constructor(t,e){super(`Could not find listing.${t?` marketplace address: ${t}`:""}${e?` listing id: ${e}`:""}`)}}class r8 extends Error{constructor(t,e,r,a){super(`Incorrect listing type. Are you sure you're using the right method?.${t?` marketplace address: ${t}`:""}${e?` listing id: ${e}`:""}${a?` expected type: ${a}`:""}${r?` actual type: ${r}`:""}`)}}class r3 extends Error{constructor(t,e){super(`Auction has not ended yet${t?`, id: ${t}`:""}${e?`, end time: ${e.toString()}`:""}`)}}class r4 extends Error{constructor(t){super(`This functionality is not available because the contract does not implement the '${t.docLinks.contracts}' Extension. Learn how to unlock this functionality at https://portal.thirdweb.com/extensions `)}}var r7=new WeakMap,r9=new WeakMap;class at extends Error{constructor(t){let e=`


╔═══════════════════╗
║ TRANSACTION ERROR ║
╚═══════════════════╝

`;if(e+=`Reason: ${t.reason}`,e+=`


╔═════════════════════════╗
║ TRANSACTION INFORMATION ║
╚═════════════════════════╝
`,e+=ar("from",t.from),t.to&&(e+=ar("to",t.contractName?`${t.to} (${t.contractName})`:t.to)),e+=ar("chain",`${t.network.name} (${t.network.chainId})`),t.rpcUrl)try{let r=new URL(t.rpcUrl);e+=ar("rpc",r.hostname)}catch(a){}if(t.hash&&(e+=ar("tx hash",t.hash)),t.value&&t.value.gt(0)&&(e+=ar("value",`${B.formatEther(t.value)} ${eb[t.network.chainId]?.symbol||""}`)),e+=ar("data",`${t.data}`),t.method&&(e+=ar("method",t.method)),t.sources){let i=t.sources.find(e=>e.source.includes(t.reason));if(i){let n=i.source.split("\n").map((t,e)=>`${e+1}  ${t}`),s=n.findIndex(e=>e.includes(t.reason));n[s]+="   <-- REVERT";let o=n.slice(s-8,s+4);e+=`


╔══════════════════════╗
║ SOLIDITY STACK TRACE ║
╚══════════════════════╝

`,e+=`File: ${i.filename.replace("node_modules/","")}

`,e+=o.join("\n")}}e+=`


╔═════════════════════╗
║ DEBUGGING RESOURCES ║
╚═════════════════════╝

`,e+="Need helping debugging? Join our Discord: https://discord.gg/thirdweb",super(e+=`

`),ee(this,r7,{writable:!0,value:void 0}),ee(this,r9,{writable:!0,value:void 0}),ei(this,r7,t.reason),ei(this,r9,t)}get reason(){return ea(this,r7)}get info(){return ea(this,r9)}}function ae(t){if(t.reason&&!t.reason.includes("cannot estimate gas"))return t.reason;if(t.error)return t.error;let e=t;return"object"==typeof t?e=JSON.stringify(t):"string"!=typeof t&&(e=t.toString()),aa(/.*?"message":"([^"\\]*).*?/,e)||aa(/.*?"reason":"([^"\\]*).*?/,e)||t.message||""}function ar(t,e){if(""===e)return e;let r=Array(10-t.length).fill(" ").join("");return`
${t}:${e=e.includes("\n")?"\n\n  "+e.split("\n").join(`
  `):`${r}${e}`}`}function aa(t,e){let r=e.match(t)||[],a="";return r?.length>0&&(a+=r[1]),a}function ai(t,e){return!!t&&(t&&t.toString().includes(e)||t&&t.message&&t.message.toString().includes(e)||t&&t.error&&t.error.toString().includes(e))}let an=[{name:"from",type:"address"},{name:"to",type:"address"},{name:"value",type:"uint256"},{name:"gas",type:"uint256"},{name:"nonce",type:"uint256"},{name:"data",type:"bytes"}],as=[{name:"from",type:"address"},{name:"to",type:"address"},{name:"value",type:"uint256"},{name:"gas",type:"uint256"},{name:"nonce",type:"uint256"},{name:"data",type:"bytes"},{name:"chainid",type:"uint256"}],ao=[{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"uint256",name:"batchId",type:"uint256"}],name:"getNonce",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"}],ac={},al={};async function ad(t,e,r){let a=r.join("|"),i=al[a],n=Date.now()-i>=2e3;if(!(a in ac)||n){let s=await t.functions[e](...r);Array.isArray(s)&&s.length>0?ac[a]=T.O$.from(s[0]):ac[a]=T.O$.from(s),al[a]=Date.now()}let o=ac[a];return ac[a]=T.O$.from(ac[a]).add(1),o}async function ap(t,e,r,a){let i=t?.provider;if(!i)throw Error("missing provider");let n=D.E.getPayload(e,r,a),s="",o=(await t.getAddress()).toLowerCase();if(i?.provider?.isWalletConnect)s=await i.send("eth_signTypedData",[(await t.getAddress()).toLowerCase(),JSON.stringify(n)]);else try{s=await t._signTypedData(e,r,a)}catch(l){if(l?.message?.includes("Method eth_signTypedData_v4 not supported"))s=await i.send("eth_signTypedData",[o,JSON.stringify(n)]);else try{await i.send("eth_signTypedData_v4",[o,JSON.stringify(n)])}catch(c){throw c}}return{payload:n,signature:v.joinSignature(v.splitSignature(s))}}let af=[{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"}],ah=[{constant:!0,inputs:[],name:"DOMAIN_SEPARATOR",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],payable:!1,stateMutability:"view",type:"function"},{inputs:[],name:"getDomainSeperator",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"}],au=[{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"nonces",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"address",name:"user",type:"address"}],name:"getNonce",outputs:[{internalType:"uint256",name:"nonce",type:"uint256"}],stateMutability:"view",type:"function"}];async function am(t,e){let r=new F.CH(e,au,t);try{return await r.nonces(await t.getAddress())}catch(a){return await r.getNonce(await t.getAddress())}}async function ag(t,e){let r=new F.CH(e,ah,t);try{return await r.DOMAIN_SEPARATOR()}catch(i){try{return await r.getDomainSeperator()}catch(a){console.error("Error getting domain separator",a)}}}async function ay(t,e){return new F.CH(e,af,t).name()}async function aw(t,e){let r=await ag(t,e.verifyingContract),a={name:e.name,version:e.version,verifyingContract:e.verifyingContract,salt:v.hexZeroPad(T.O$.from(e.chainId).toHexString(),32)};return D.E.hashDomain(a)===r?a:e}async function ab(t,e,r,a,i,n,s){let o=await aw(t,{name:await ay(t,e),version:"1",chainId:await t.getChainId(),verifyingContract:e});s=s||(await am(t,e)).toString(),n=n||O.Bz;let c={owner:r,spender:a,value:i,nonce:s,deadline:n},{signature:l}=await ap(t,o,{Permit:[{name:"owner",type:"address"},{name:"spender",type:"address"},{name:"value",type:"uint256"},{name:"nonce",type:"uint256"},{name:"deadline",type:"uint256"}]},c);return{message:c,signature:l}}let aC=()=>!0,av=()=>!aC();class aW extends tU.Z{constructor(t,e){super(),(0,tR._)(this,"provider",void 0),(0,tR._)(this,"signer",void 0),(0,tR._)(this,"options",void 0);try{this.options=eU.parse(e)}catch(r){console.error("invalid sdk options object passed, falling back to default options",r),this.options=eU.parse({})}let[a,i]=eE(t,this.options);this.signer=a,this.provider=i}updateSignerOrProvider(t){let[e,r]=eE(t,this.options);this.signer=e,this.provider=r}isReadOnly(){return!eA(this.signer)}getSigner(){return this.signer}getProvider(){return this.provider}getSignerOrProvider(){return this.getSigner()||this.getProvider()}}var aA=new WeakMap;class ak extends aW{constructor(t,e,r,a){super(t,a),ee(this,aA,{writable:!0,value:void 0}),(0,tR._)(this,"isValidContract",!1),(0,tR._)(this,"customOverrides",()=>({})),(0,tR._)(this,"writeContract",void 0),(0,tR._)(this,"readContract",void 0),(0,tR._)(this,"abi",void 0),this.abi=r,this.writeContract=new F.CH(e,r,this.getSignerOrProvider()),this.readContract=this.writeContract.connect(this.getProvider()),ei(this,aA,new tq.EA)}updateSignerOrProvider(t){super.updateSignerOrProvider(t),this.writeContract=this.writeContract.connect(this.getSignerOrProvider()),this.readContract=this.writeContract.connect(this.getProvider())}async getChainID(){let t=this.getProvider(),{chainId:e}=await t.getNetwork();return e}async getSignerAddress(){let t=this.getSigner();if(!t)throw Error("This action requires a connected wallet to sign the transaction. Please pass a valid signer to the SDK.");return await t.getAddress()}callStatic(){return this.writeContract.callStatic}async getCallOverrides(){return{}}getPreferredPriorityFee(t){let e;let r=this.options.gasSettings.speed,a=this.options.gasSettings.maxPriceInGwei;switch(r){case"standard":e=T.O$.from(0);break;case"fast":e=t.div(100).mul(5);break;case"fastest":e=t.div(100).mul(10)}let i=t.add(e),n=B.parseUnits(a.toString(),"gwei"),s=B.parseUnits("2.5","gwei");return i.gt(n)&&(i=n),i.lt(s)&&(i=s),i}async getPreferredGasPrice(){let t;let e=await this.getProvider().getGasPrice(),r=this.options.gasSettings.speed,a=this.options.gasSettings.maxPriceInGwei,i=e;switch(r){case"standard":t=T.O$.from(1);break;case"fast":t=e.div(100).mul(5);break;case"fastest":t=e.div(100).mul(10)}i=i.add(t);let n=B.parseUnits(a.toString(),"gwei");return i.gt(n)&&(i=n),i}emitTransactionEvent(t,e){this.emit(eW.Transaction,{status:t,transactionHash:e})}async multiCall(t){return this.sendTransaction("multicall",[t])}async estimateGas(t,e){return this.writeContract.estimateGas[t](...e)}withTransactionOverride(t){this.customOverrides=t}async call(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],r=arguments.length>2?arguments[2]:void 0,a=r?await ez.parseAsync(r):void 0,i=nI(cd.parse(this.abi)).filter(e=>e.name===t);if(!i.length)throw Error(`Function "${t}" not found in contract. Check your dashboard for the list of functions available`);let n=i.find(r=>r.name===t&&r.inputs.length===e.length);if(!n)throw Error(`Function "${t}" requires ${i[0].inputs.length} arguments, but ${e.length} were provided.
Expected function signature: ${i[0].signature}`);let s=`${t}(${n.inputs.map(t=>t.type).join()})`,o=s in this.readContract.functions?s:t;if("view"===n.stateMutability||"pure"===n.stateMutability)return this.readContract[o](...e);{let c=await this.sendTransaction(o,e,a);return{receipt:c}}}async sendTransaction(t,e,r){if(r||(r=await this.getCallOverrides()),r={...r,...this.customOverrides()},this.customOverrides=()=>({}),this.options?.gasless&&("openzeppelin"in this.options.gasless||"biconomy"in this.options.gasless)){if("multicall"===t&&Array.isArray(e[0])&&e[0].length>0){let a=await this.getSignerAddress();e[0]=e[0].map(t=>I.pack(["bytes","address"],[t,a]))}let i=this.getProvider(),n=await this.sendGaslessTransaction(t,e,r);this.emitTransactionEvent("submitted",n);let s=await i.waitForTransaction(n);return this.emitTransactionEvent("completed",n),s}{let o;if(!this.isValidContract){let c=await this.getProvider().getCode(this.readContract.address);if(this.isValidContract="0x"!==c,!this.isValidContract)throw Error("The address you're trying to send a transaction to is not a smart contract. Make sure you are on the correct network and the contract address is correct")}let l=await this.sendTransactionByFunction(t,e,r);this.emitTransactionEvent("submitted",l.hash);try{o=await l.wait()}catch(p){try{await this.writeContract.callStatic[t](...e,...r.value?[{value:r.value}]:[])}catch(d){throw await this.formatError(d,t,e,r)}throw await this.formatError(p,t,e,r)}return this.emitTransactionEvent("completed",l.hash),o}}async sendTransactionByFunction(t,e,r){let a=this.writeContract.functions[t];if(!a)throw Error(`invalid function: "${t.toString()}"`);if(!r.gasLimit)try{r.gasLimit=await this.writeContract.estimateGas[t](...e,r)}catch(n){try{await this.writeContract.callStatic[t](...e,...r.value?[{value:r.value}]:[])}catch(i){throw await this.formatError(i,t,e,r)}}try{return await a(...e,r)}catch(l){let s=await (r.from||this.getSignerAddress()),o=await (r.value?r.value:0),c=await this.getProvider().getBalance(s);if(c.eq(0)||o&&c.lt(o))throw await this.formatError(Error("You have insufficient funds in your account to execute this transaction."),t,e,r);throw await this.formatError(l,t,e,r)}}async formatError(t,e,r,a){let i,n;let s=this.getProvider(),o=await s.getNetwork(),c=await (a.from||this.getSignerAddress()),l=this.readContract.address,d=this.readContract.interface.encodeFunctionData(e,r),p=T.O$.from(a.value||0),f=s.connection?.url,h=this.readContract.interface.getFunction(e),u=r.map(t=>JSON.stringify(t).length<=80?JSON.stringify(t):JSON.stringify(t,void 0,2)),m=u.join(", ").length<=80?u.join(", "):"\n"+u.map(t=>"  "+t.split("\n").join("\n  ")).join(",\n")+"\n",g=`${h.name}(${m})`,y=t.transactionHash||t.transaction?.hash||t.receipt?.transactionHash,w=ae(t);try{let b=await o6(this.readContract.address,this.getProvider(),ea(this,aA));b.name&&(n=b.name),b.metadata.sources&&(i=await o4(b,ea(this,aA)))}catch(C){}return new at({reason:w,from:c,to:l,method:g,data:d,network:o,rpcUrl:f,value:p,hash:y,contractName:n,sources:i})}async sendGaslessTransaction(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],r=arguments.length>2?arguments[2]:void 0,a=this.getSigner();(0,tH.Z)(a,"Cannot execute gasless transaction without valid signer");let i=await this.getChainID(),n=await this.getSignerAddress(),s=this.writeContract.address,o=r?.value||0;if(T.O$.from(o).gt(0))throw Error("Cannot send native token value with gasless transaction");let c=this.writeContract.interface.encodeFunctionData(t,e),l=T.O$.from(0);try{let d=await this.readContract.estimateGas[t](...e);l=d.mul(2)}catch(p){}l.lt(1e5)&&(l=T.O$.from(5e5)),r.gasLimit&&T.O$.from(r.gasLimit).gt(l)&&(l=T.O$.from(r.gasLimit));let f={from:n,to:s,data:c,chainId:i,gasLimit:l,functionName:t.toString(),functionArgs:e,callOverrides:r};return await this.defaultGaslessSendFunction(f)}async signTypedData(t,e,r,a){this.emit(eW.Signature,{status:"submitted",message:a,signature:""});let{signature:i}=await ap(t,e,r,a);return this.emit(eW.Signature,{status:"completed",message:a,signature:i}),i}parseLogs(t,e){if(!e||0===e.length)return[];let r=this.writeContract.interface.getEventTopic(t),a=e.filter(t=>t.topics.indexOf(r)>=0);return a.map(t=>this.writeContract.interface.parseLog(t))}async defaultGaslessSendFunction(t){return this.options.gasless&&"biconomy"in this.options.gasless?this.biconomySendFunction(t):this.defenderSendFunction(t)}async biconomySendFunction(t){(0,tH.Z)(this.options.gasless&&"biconomy"in this.options.gasless,"calling biconomySendFunction without biconomy");let e=this.getSigner(),r=this.getProvider();(0,tH.Z)(e&&r,"signer and provider must be set");let a=new F.CH(eh(t.chainId,"biconomyForwarder"),ao,r),i=await ad(a,"getNonce",[t.from,0]),n={from:t.from,to:t.to,token:C.d,txGas:t.gasLimit.toNumber(),tokenGasPrice:"0",batchId:0,batchNonce:i.toNumber(),deadline:Math.floor(Date.now()/1e3+(this.options?.gasless&&"biconomy"in this.options.gasless&&this.options.gasless.biconomy?.deadlineSeconds||3600)),data:t.data},s=v.arrayify(I.keccak256(["address","address","address","uint256","uint256","uint256","uint256","uint256","bytes32"],[n.from,n.to,n.token,n.txGas,n.tokenGasPrice,n.batchId,n.batchNonce,n.deadline,R.keccak256(n.data)]));this.emit(eW.Signature,{status:"submitted",message:s,signature:""});let o=await e.signMessage(s);this.emit(eW.Signature,{status:"completed",message:s,signature:o});let c=await tG()("https://api.biconomy.io/api/v2/meta-tx/native",{method:"POST",body:JSON.stringify({from:t.from,apiId:this.options.gasless.biconomy.apiId,params:[n,o],to:t.to,gasLimit:t.gasLimit.toHexString()}),headers:{"x-api-key":this.options.gasless.biconomy.apiKey,"Content-Type":"application/json;charset=utf-8"}});if(c.ok){let l=await c.json();if(!l.txHash)throw Error(`relay transaction failed: ${l.log}`);return l.txHash}throw Error(`relay transaction failed with status: ${c.status} (${c.statusText})`)}async defenderSendFunction(t){let e,r,a,i;(0,tH.Z)(this.options.gasless&&"openzeppelin"in this.options.gasless,"calling openzeppelin gasless transaction without openzeppelin config in the SDK options");let n=this.getSigner(),s=this.getProvider();(0,tH.Z)(n,"provider is not set"),(0,tH.Z)(s,"provider is not set");let o=this.options.gasless.openzeppelin.relayerForwarderAddress||(this.options.gasless.openzeppelin.useEOAForwarder?ep[t.chainId].openzeppelinForwarderEOA:ep[t.chainId].openzeppelinForwarder),c=new F.CH(o,tV,s),l=await ad(c,"getNonce",[t.from]);if(this.options.gasless.experimentalChainlessSupport?(e={name:"GSNv2 Forwarder",version:"0.0.1",verifyingContract:o},r={ForwardRequest:as},a={from:t.from,to:t.to,value:T.O$.from(0).toString(),gas:T.O$.from(t.gasLimit).toString(),nonce:T.O$.from(l).toString(),data:t.data,chainid:T.O$.from(t.chainId).toString()}):(e={name:"GSNv2 Forwarder",version:"0.0.1",chainId:t.chainId,verifyingContract:o},r={ForwardRequest:an},a={from:t.from,to:t.to,value:T.O$.from(0).toString(),gas:T.O$.from(t.gasLimit).toString(),nonce:T.O$.from(l).toString(),data:t.data}),this.emit(eW.Signature,{status:"submitted",message:a,signature:""}),"approve"===t.functionName&&2===t.functionArgs.length){let d=t.functionArgs[0],p=t.functionArgs[1],{message:f,signature:h}=await ab(n,this.writeContract.address,t.from,d,p),{r:u,s:m,v:g}=v.splitSignature(h);a={to:this.readContract.address,owner:f.owner,spender:f.spender,value:T.O$.from(f.value).toString(),nonce:T.O$.from(f.nonce).toString(),deadline:T.O$.from(f.deadline).toString(),r:u,s:m,v:g},i=h}else{let{signature:y}=await ap(n,e,r,a);i=y}let w="forward";a?.owner&&(w="permit");let b=JSON.stringify({request:a,signature:i,forwarderAddress:o,type:w});this.emit(eW.Signature,{status:"completed",message:a,signature:i});let C=await tG()(this.options.gasless.openzeppelin.relayerUrl,{method:"POST",body:b});if(C.ok){let W=await C.json();if(!W.result)throw Error(`Relay transaction failed: ${W.message}`);let A=JSON.parse(W.result);return A.txHash}throw Error(`relay transaction failed with status: ${C.status} (${C.statusText})`)}}function aE(t){return t.toLowerCase()===ew||t.toLowerCase()===C.d}function aT(t){return aE(t)?ew:t}async function aS(t,e,r){let a=await a_(t,r);return B.parseUnits(tR.A.parse(e),a.decimals)}async function a_(t,e){if(aE(e)){let r=await t.getNetwork(),a=eC(r.chainId);return{name:a.name,symbol:a.symbol,decimals:a.decimals}}{let i=new F.CH(e,tZ,t),[n,s,o]=await Promise.all([i.name(),i.symbol(),i.decimals()]);return{name:n,symbol:s,decimals:o}}}async function aP(t,e,r){let a=await a_(t,e);return{...a,value:T.O$.from(r),displayValue:B.formatUnits(r,a.decimals)}}async function ax(t,e,r,a){if(aE(r))a.value=e;else{let i=t.getSigner(),n=t.getProvider(),s=new ak(i||n,r,Y,t.options),o=await t.getSignerAddress(),c=t.readContract.address,l=await s.readContract.allowance(o,c);return l.lt(e)&&await s.sendTransaction("approve",[c,e]),a}}async function aB(t,e,r,a,i){let n=t.getSigner(),s=t.getProvider(),o=new ak(n||s,e,Y,t.options),c=await t.getSignerAddress(),l=t.readContract.address,d=await o.readContract.allowance(c,l),p=T.O$.from(r).mul(T.O$.from(a)).div(B.parseUnits("1",i));d.lt(p)&&await o.sendTransaction("approve",[l,d.add(p)])}async function aD(t,e,r){let a=t.getProvider(),i=new ak(a,e,Y,{}),n=await t.getSignerAddress(),s=t.readContract.address,o=await i.readContract.allowance(n,s);return o.gte(r)}async function aF(t,e,r,a,i,n,s,o,c){let l=aG(r.maxClaimablePerWallet,i),d=[v.hexZeroPad([0],32)],p=r.price,f=r.currencyAddress;try{if(!r.merkleRootHash.toString().startsWith(C.d)){let h=await aI(t,r.merkleRootHash.toString(),await a(),n.getProvider(),s,c);if(h)d=h.proof,l="unlimited"===h.maxClaimable?O.Bz:B.parseUnits(h.maxClaimable,i),p=void 0===h.price||"unlimited"===h.price?O.Bz:await aS(n.getProvider(),h.price,h.currencyAddress||C.d),f=h.currencyAddress||C.d;else if(c===aZ.V1)throw Error("No claim found for this address")}}catch(u){if(u?.message==="No claim found for this address")throw u;console.warn("failed to check claim condition merkle root hash, continuing anyways",u)}let m=await n.getCallOverrides()||{},g=p.toString()!==O.Bz.toString()?p:r.price,y=f!==C.d?f:r.currencyAddress;return g.gt(0)&&(aE(y)?m.value=T.O$.from(g).mul(e).div(B.parseUnits("1",i)):o&&await aB(n,y,g,e,i)),{overrides:m,proofs:d,maxClaimable:l,price:g,currencyAddress:y,priceInProof:p,currencyAddressInProof:f}}async function aO(t,e,r){if(!e)return null;let a=e[t];if(a){let i=await r.downloadJSON(a);if(i.isShardedMerkleTree&&i.merkleRoot===t){let n=await aJ.fromUri(a,r);return n?.getAllEntries()||null}{let s=await eJ.parseAsync(i);if(t===s.merkleRoot)return s.claims.map(t=>({address:t.address,maxClaimable:t.maxClaimable,price:t.price,currencyAddress:t.currencyAddress}))}}return null}async function aI(t,e,r,a,i,n){if(!r)return null;let s=r[e];if(s){let o=await i.downloadJSON(s);if(o.isShardedMerkleTree&&o.merkleRoot===e){let c=await aJ.fromShardedMerkleTreeInfo(o,i);return await c.getProof(t,a,n)}let l=await eJ.parseAsync(o);if(e===l.merkleRoot)return l.claims.find(e=>e.address.toLowerCase()===t.toLowerCase())||null}return null}async function aR(t,e,r){if(t>=r.length)throw Error(`Index out of bounds - got index: ${t} with ${r.length} conditions`);let a=r[t].currencyMetadata.decimals,i=r[t].price,n=B.formatUnits(i,a),s=await eK.parseAsync({...r[t],price:n,...e}),o=await eX.parseAsync({...s,price:i});return r.map((e,r)=>{let i;i=r===t?o:e;let n=B.formatUnits(i.price,a);return{...i,price:n}})}async function aN(t,e,r,a,i){let n=[],s=await Promise.all(t.map(async t=>{if(t.snapshot&&t.snapshot.length>0){let s=await aY(t.snapshot,e,r,a,i);n.push(s),t.merkleRootHash=s.merkleRoot}else t.merkleRootHash=v.hexZeroPad([0],32);return t}));return{inputsWithSnapshots:s,snapshotInfos:n}}async function aL(t,e,r,a,i){let{inputsWithSnapshots:n,snapshotInfos:s}=await aN(t,e,r,a,i),o=await eQ.parseAsync(n),c=(await Promise.all(o.map(t=>aM(t,e,r,a)))).sort((t,e)=>(function(t,e){let r=T.O$.from(t),a=T.O$.from(e);return r.eq(a)?0:r.gt(a)?1:-1})(t.startTimestamp,e.startTimestamp));return{snapshotInfos:s,sortedConditions:c}}async function aM(t,e,r,a){let i;let n=t.currencyAddress===C.d?ew:t.currencyAddress,s=aG(t.maxClaimableSupply,e),o=aG(t.maxClaimablePerWallet,e);return t.metadata&&(i="string"==typeof t.metadata?t.metadata:await a.upload(t.metadata)),{startTimestamp:t.startTime,maxClaimableSupply:s,supplyClaimed:0,maxClaimablePerWallet:o,pricePerToken:await aS(r,t.price,n),currency:n,merkleRoot:t.merkleRootHash.toString(),waitTimeInSecondsBetweenClaims:t.waitInSeconds||0,metadata:i}}function az(t){return{startTimestamp:t.startTimestamp,maxClaimableSupply:t.maxClaimableSupply,supplyClaimed:t.supplyClaimed,merkleRoot:t.merkleRoot,pricePerToken:t.pricePerToken,currency:t.currency,quantityLimitPerTransaction:t.maxClaimablePerWallet,waitTimeInSecondsBetweenClaims:t.waitTimeInSecondsBetweenClaims||0}}function a$(t){return{startTimestamp:t.startTimestamp,maxClaimableSupply:t.maxClaimableSupply,supplyClaimed:t.supplyClaimed,merkleRoot:t.merkleRoot,pricePerToken:t.pricePerToken,currency:t.currency,quantityLimitPerWallet:t.maxClaimablePerWallet,metadata:t.metadata||""}}function aU(t){return{startTimestamp:t.startTimestamp,maxClaimableSupply:t.maxClaimableSupply,supplyClaimed:t.supplyClaimed,merkleRoot:t.merkleRoot.toString(),pricePerToken:t.pricePerToken,currency:t.currency,maxClaimablePerWallet:t.quantityLimitPerTransaction,waitTimeInSecondsBetweenClaims:t.waitTimeInSecondsBetweenClaims}}function aV(t){return{startTimestamp:t.startTimestamp,maxClaimableSupply:t.maxClaimableSupply,supplyClaimed:t.supplyClaimed,merkleRoot:t.merkleRoot.toString(),pricePerToken:t.pricePerToken,currency:t.currency,maxClaimablePerWallet:t.quantityLimitPerWallet,waitTimeInSecondsBetweenClaims:0,metadata:t.metadata}}async function aq(t,e,r,a,i,n){let s;let o=await aP(r,t.currency,t.pricePerToken),c=aj(t.maxClaimableSupply,e),l=aj(t.maxClaimablePerWallet,e),d=aj(T.O$.from(t.maxClaimableSupply).sub(t.supplyClaimed),e),p=aj(t.supplyClaimed,e);return t.metadata&&(s=await i.downloadJSON(t.metadata)),eX.parseAsync({startTime:t.startTimestamp,maxClaimableSupply:c,maxClaimablePerWallet:l,currentMintSupply:p,availableSupply:d,waitInSeconds:t.waitTimeInSecondsBetweenClaims?.toString(),price:T.O$.from(t.pricePerToken),currency:t.currency,currencyAddress:t.currency,currencyMetadata:o,merkleRootHash:t.merkleRoot,snapshot:n?await aO(t.merkleRoot,a,i):void 0,metadata:s})}function aj(t,e){return t.toString()===O.Bz.toString()?"unlimited":B.formatUnits(t,e)}function aG(t,e){return"unlimited"===t?O.Bz:B.parseUnits(t,e)}async function aH(t,e,r,a,i){let n={},s=a||ew,o=await aS(t.getProvider(),e,s),c=o.mul(r);return c.gt(0)&&(s===ew?n={value:c}:s!==ew&&i&&await aB(t,s,c,r,0)),n}let aZ=((g={})[g.V1=1]="V1",g[g.V2=2]="V2",g);class aJ{constructor(t,e,r,a,i){(0,tR._)(this,"shardNybbles",void 0),(0,tR._)(this,"shards",void 0),(0,tR._)(this,"trees",void 0),(0,tR._)(this,"storage",void 0),(0,tR._)(this,"baseUri",void 0),(0,tR._)(this,"originalEntriesUri",void 0),(0,tR._)(this,"tokenDecimals",void 0),this.storage=t,this.shardNybbles=a,this.baseUri=e,this.originalEntriesUri=r,this.tokenDecimals=i,this.shards={},this.trees={}}static async fromUri(t,e){try{let r=await e.downloadJSON(t);if(r.isShardedMerkleTree)return aJ.fromShardedMerkleTreeInfo(r,e)}catch(a){return}}static async fromShardedMerkleTreeInfo(t,e){return new aJ(e,t.baseUri,t.originalEntriesUri,t.shardNybbles,t.tokenDecimals)}static hashEntry(t,e,r,a){switch(a){case aZ.V1:return I.keccak256(["address","uint256"],[t.address,aG(t.maxClaimable,e)]);case aZ.V2:return I.keccak256(["address","uint256","uint256","address"],[t.address,aG(t.maxClaimable,e),aG(t.price||"unlimited",r),t.currencyAddress||C.d])}}static async fetchAndCacheDecimals(t,e,r){if(!r)return 18;let a=t[r];if(void 0===a){let i=await a_(e,r);a=i.decimals,t[r]=a}return a}static async buildAndUpload(t,e,r,a,i){let n=arguments.length>5&&void 0!==arguments[5]?arguments[5]:2,s=await eH.parseAsync(t),o={};for(let c of s){let l=c.address.slice(2,2+n).toLowerCase();void 0===o[l]&&(o[l]=[]),o[l].push(c)}let d={},p=await Promise.all(Object.entries(o).map(async t=>{let[a,n]=t;return[a,new tJ.MerkleTree(await Promise.all(n.map(async t=>{let a=await aJ.fetchAndCacheDecimals(d,r,t.currencyAddress);return aJ.hashEntry(t,e,a,i)})),R.keccak256,{sort:!0}).getHexRoot()]})),f=Object.fromEntries(p),h=new tJ.MerkleTree(Object.values(f),R.keccak256,{sort:!0}),u=[];for(let[m,g]of Object.entries(o)){let y={proofs:h.getProof(f[m]).map(t=>"0x"+t.data.toString("hex")),entries:g};u.push({data:JSON.stringify(y),name:`${m}.json`})}let w=await a.uploadBatch(u),b=w[0].slice(0,w[0].lastIndexOf("/")),C=await a.upload(s),v={merkleRoot:h.getHexRoot(),baseUri:b,originalEntriesUri:C,shardNybbles:n,tokenDecimals:e,isShardedMerkleTree:!0},W=await a.upload(v);return{shardedMerkleInfo:v,uri:W}}async getProof(t,e,r){let a=t.slice(2,2+this.shardNybbles).toLowerCase(),i=this.shards[a],n={};if(void 0===i)try{i=this.shards[a]=await this.storage.downloadJSON(`${this.baseUri}/${a}.json`);let s=await Promise.all(i.entries.map(async t=>{let a=await aJ.fetchAndCacheDecimals(n,e,t.currencyAddress);return aJ.hashEntry(t,this.tokenDecimals,a,r)}));this.trees[a]=new tJ.MerkleTree(s,R.keccak256,{sort:!0})}catch(o){return null}let c=i.entries.find(e=>e.address.toLowerCase()===t.toLowerCase());if(!c)return null;let l=await aJ.fetchAndCacheDecimals(n,e,c.currencyAddress),d=aJ.hashEntry(c,this.tokenDecimals,l,r),p=this.trees[a].getProof(d).map(t=>"0x"+t.data.toString("hex"));return eZ.parseAsync({...c,proof:p.concat(i.proofs)})}async getAllEntries(){try{return await this.storage.downloadJSON(this.originalEntriesUri)}catch(t){return console.warn("Could not fetch original snapshot entries",t),[]}}}async function aY(t,e,r,a,i){let n=await eH.parseAsync(t),s=n.map(t=>t.address),o=new Set(s).size<s.length;if(o)throw new r2;let c=await aJ.buildAndUpload(n,e,r,a,i);return{merkleRoot:c.shardedMerkleInfo.merkleRoot,snapshotUri:c.uri}}let aK={admin:"",transfer:"TRANSFER_ROLE",minter:"MINTER_ROLE",pauser:"PAUSER_ROLE",lister:"LISTER_ROLE",asset:"ASSET_ROLE",unwrap:"UNWRAP_ROLE",factory:"FACTORY_ROLE"},aQ=Object.keys(aK);function aX(t){return"admin"===t?v.hexZeroPad([0],32):N.id(aK[t])}class a0{constructor(t){(0,tR._)(this,"contractWrapper",void 0),this.contractWrapper=t}encode(t,e){return this.contractWrapper.readContract.interface.encodeFunctionData(t,e)}decode(t,e){return this.contractWrapper.readContract.interface.decodeFunctionData(t,e)}}function a1(t){async function e(){let e=await t(...arguments);return e.execute()}return e.prepare=t,e}function a2(t){async function e(){let e=await t(...arguments);return e.execute()}return e.prepare=t,e}async function a5(t,e,r,a){return a&&"biconomy"in a?a6(t,e,r,a):a8(t,e,r,a)}async function a6(t,e,r,a){(0,tH.Z)(a&&"biconomy"in a,"calling biconomySendFunction without biconomy"),(0,tH.Z)(e&&r,"signer and provider must be set");let i=new F.CH(eh(t.chainId,"biconomyForwarder"),ao,r),n=await ad(i,"getNonce",[t.from,0]),s={from:t.from,to:t.to,token:C.d,txGas:t.gasLimit.toNumber(),tokenGasPrice:"0",batchId:0,batchNonce:n.toNumber(),deadline:Math.floor(Date.now()/1e3+(a&&"biconomy"in a&&a.biconomy?.deadlineSeconds||3600)),data:t.data},o=v.arrayify(I.keccak256(["address","address","address","uint256","uint256","uint256","uint256","uint256","bytes32"],[s.from,s.to,s.token,s.txGas,s.tokenGasPrice,s.batchId,s.batchNonce,s.deadline,R.keccak256(s.data)])),c=await e.signMessage(o),l=await tG()("https://api.biconomy.io/api/v2/meta-tx/native",{method:"POST",body:JSON.stringify({from:t.from,apiId:a.biconomy.apiId,params:[s,c],to:t.to,gasLimit:t.gasLimit.toHexString()}),headers:{"x-api-key":a.biconomy.apiKey,"Content-Type":"application/json;charset=utf-8"}});if(l.ok){let d=await l.json();if(!d.txHash)throw Error(`relay transaction failed: ${d.log}`);return d.txHash}throw Error(`relay transaction failed with status: ${l.status} (${l.statusText})`)}async function a8(t,e,r,a){let i,n,s,o;(0,tH.Z)(a&&"openzeppelin"in a,"calling openzeppelin gasless transaction without openzeppelin config in the SDK options"),(0,tH.Z)(e,"provider is not set"),(0,tH.Z)(r,"provider is not set");let c=a.openzeppelin.relayerForwarderAddress||(a.openzeppelin.useEOAForwarder?ep[t.chainId].openzeppelinForwarderEOA:ep[t.chainId].openzeppelinForwarder),l=new F.CH(c,tV,r),d=await ad(l,"getNonce",[t.from]);if(a.experimentalChainlessSupport?(i={name:"GSNv2 Forwarder",version:"0.0.1",verifyingContract:c},n={ForwardRequest:as},s={from:t.from,to:t.to,value:T.O$.from(0).toString(),gas:T.O$.from(t.gasLimit).toString(),nonce:T.O$.from(d).toString(),data:t.data,chainid:T.O$.from(t.chainId).toString()}):(i={name:"GSNv2 Forwarder",version:"0.0.1",chainId:t.chainId,verifyingContract:c},n={ForwardRequest:an},s={from:t.from,to:t.to,value:T.O$.from(0).toString(),gas:T.O$.from(t.gasLimit).toString(),nonce:T.O$.from(d).toString(),data:t.data}),"approve"===t.functionName&&2===t.functionArgs.length){let p=t.functionArgs[0],f=t.functionArgs[1],{message:h,signature:u}=await ab(e,t.to,t.from,p,f),{r:m,s:g,v:y}=v.splitSignature(u);s={to:t.to,owner:h.owner,spender:h.spender,value:T.O$.from(h.value).toString(),nonce:T.O$.from(h.nonce).toString(),deadline:T.O$.from(h.deadline).toString(),r:m,s:g,v:y},o=u}else{let{signature:w}=await ap(e,i,n,s);o=w}let b="forward";s?.owner&&(b="permit");let C=JSON.stringify({request:s,signature:o,forwarderAddress:c,type:b}),W=await tG()(a.openzeppelin.relayerUrl,{method:"POST",body:C});if(W.ok){let A=await W.json();if(!A.result)throw Error(`Relay transaction failed: ${A.message}`);let k=JSON.parse(A.result);return k.txHash}throw Error(`relay transaction failed with status: ${W.status} (${W.statusText})`)}let a3=[{inputs:[],name:"getAllPlugins",outputs:[{components:[{internalType:"bytes4",name:"functionSelector",type:"bytes4"},{internalType:"string",name:"functionSignature",type:"string"},{internalType:"address",name:"pluginAddress",type:"address"}],internalType:"struct IPluginMap.Plugin[]",name:"registered",type:"tuple[]"}],stateMutability:"view",type:"function"}],a4=[{inputs:[],name:"getAllExtensions",outputs:[{components:[{components:[{internalType:"string",name:"name",type:"string"},{internalType:"string",name:"metadataURI",type:"string"},{internalType:"address",name:"implementation",type:"address"}],internalType:"struct IExtension.ExtensionMetadata",name:"metadata",type:"tuple"},{components:[{internalType:"bytes4",name:"functionSelector",type:"bytes4"},{internalType:"string",name:"functionSignature",type:"string"}],internalType:"struct IExtension.ExtensionFunction[]",name:"functions",type:"tuple[]"}],internalType:"struct IExtension.Extension[]",name:"allExtensions",type:"tuple[]"}],stateMutability:"view",type:"function"}],a7={name:"Royalty",namespace:"royalty",docLinks:{sdk:"sdk.contractroyalty",contracts:"royalty"},abis:[tO],features:{}},a9={name:"PrimarySale",namespace:"sales",docLinks:{sdk:"sdk.contractprimarysale",contracts:"primarysale"},abis:[tF],features:{}},it={name:"PlatformFee",namespace:"platformFee",docLinks:{sdk:"sdk.platformfee",contracts:"platformfee"},abis:[tD],features:{}},ie={name:"PermissionsEnumerable",namespace:"roles",docLinks:{sdk:"sdk.contractroles",contracts:"permissionsenumerable"},abis:[tB],features:{}},ir={name:"Permissions",namespace:"roles",docLinks:{sdk:"sdk.contractroles",contracts:"permissions"},abis:[tx],features:{[ie.name]:ie}},ia={name:"ContractMetadata",namespace:"metadata",docLinks:{sdk:"sdk.contractmetadata",contracts:"contractmetadata"},abis:[tE],features:{}},ii={name:"AppURI",namespace:"appURI",docLinks:{sdk:"sdk.appURI",contracts:""},abis:[tk],features:{}},is={name:"Ownable",namespace:"owner",docLinks:{sdk:"sdk.owner",contracts:"ownable"},abis:[tI],features:{}},io={name:"Gasless",namespace:"gasless",docLinks:{sdk:"sdk.gaslesstransaction",contracts:""},abis:[tA],features:{}},ic={name:"PackVRF",namespace:"pack.vrf",docLinks:{sdk:"sdk.packvrf",contracts:""},abis:[tP],features:{}},il={name:"PluginRouter",namespace:"plugin.router",docLinks:{sdk:"sdk.pluginrouter",contracts:""},abis:[a3],features:{}},id={name:"ExtensionRouter",namespace:"extension.router",docLinks:{sdk:"",contracts:""},abis:[a4],features:{}},ip={name:"DirectListings",namespace:"direct.listings",docLinks:{sdk:"",contracts:""},abis:[tT],features:{}},ih={name:"EnglishAuctions",namespace:"english.auctions",docLinks:{sdk:"",contracts:""},abis:[tS],features:{}},iu={name:"Offers",namespace:"offers",docLinks:{sdk:"",contracts:""},abis:[t_],features:{}},im={name:"ERC20ClaimConditionsV1",namespace:"token.drop.claim",docLinks:{sdk:"sdk.erc20dclaimable",contracts:"erc20claimconditions"},abis:[Y,J],features:{}},ig={name:"ERC20ClaimConditionsV2",namespace:"token.drop.claim",docLinks:{sdk:"sdk.erc20dclaimable",contracts:"erc20claimconditions"},abis:[Y,Z],features:{}},iy={name:"ERC20ClaimPhasesV2",namespace:"token.drop.claim",docLinks:{sdk:"sdk.erc20dclaimable",contracts:"erc20claimphases"},abis:[Y,G],features:{}},iw={name:"ERC20ClaimPhasesV1",namespace:"token.drop.claim",docLinks:{sdk:"sdk.erc20dclaimable",contracts:"erc20claimphases"},abis:[H],features:{}},ib={name:"ERC20Burnable",namespace:"token.burn",docLinks:{sdk:"sdk.erc20burnable",contracts:"erc20burnable"},abis:[Y,j],features:{}},iC={name:"ERC20SignatureMintable",namespace:"token.signature",docLinks:{sdk:"sdk.erc20signaturemintable",contracts:"erc20signaturemint"},abis:[Y,tt],features:{}},iv={name:"ERC20BatchMintable",namespace:"token.mint.batch",docLinks:{sdk:"sdk.erc20batchmintable",contracts:"erc20batchmintable"},abis:[Y,Q,X],features:{}},iW={name:"ERC20Mintable",namespace:"token.mint",docLinks:{sdk:"sdk.erc20mintable",contracts:"erc20mintable"},abis:[Y,Q],features:{[iv.name]:iv}},iA={name:"ERC20Permit",namespace:"token.permit",docLinks:{sdk:"sdk.erc20permit",contracts:"erc20permit"},abis:[Y,K],features:{}},ik={name:"ERC20",namespace:"token",docLinks:{sdk:"sdk.erc20",contracts:"erc20"},abis:[Y],features:{[ib.name]:ib,[iW.name]:iW,[im.name]:im,[ig.name]:ig,[iw.name]:iw,[iy.name]:iy,[iC.name]:iC,[iA.name]:iA}},iE={name:"ERC721Burnable",namespace:"nft.burn",docLinks:{sdk:"sdk.erc721burnable",contracts:"erc721burnable"},abis:[tn,te],features:{}},iT={name:"ERC721Revealable",namespace:"nft.drop.revealer",docLinks:{sdk:"sdk.delayedreveal",contracts:"erc721revealable"},abis:[tn,tc,ta],features:{}},iS={name:"ERC721TieredDrop",namespace:"nft.tieredDrop",docLinks:{sdk:"sdk.erc721tiereddrop",contracts:""},abis:[tn,tf],features:{}},i_={name:"ERC721ClaimConditionsV1",namespace:"nft.drop.claim",docLinks:{sdk:"sdk.erc721claimable",contracts:"erc721claimconditions"},abis:[tn,J],features:{}},iP={name:"ERC721ClaimConditionsV2",namespace:"nft.drop.claim",docLinks:{sdk:"sdk.erc721claimable",contracts:"erc721claimconditions"},abis:[tn,Z],features:{}},ix={name:"ERC721ClaimPhasesV1",namespace:"nft.drop.claim",docLinks:{sdk:"sdk.erc721claimable",contracts:"erc721claimphases"},abis:[ti],features:{}},iB={name:"ERC721ClaimPhasesV2",namespace:"nft.drop.claim",docLinks:{sdk:"sdk.erc721claimable",contracts:"erc721claimphases"},abis:[tn,G],features:{}},iD={name:"ERC721ClaimCustom",namespace:"nft.drop.claim",docLinks:{sdk:"sdk.erc721claimable",contracts:"erc721claimcustom"},abis:[tn,tr],features:{}},iF={name:"ERC721LazyMintable",namespace:"nft.drop",docLinks:{sdk:"sdk.erc721lazymintable",contracts:"lazymint"},abis:[tn,tc],features:{[iT.name]:iT}},iO={name:"ERC721BatchMintable",namespace:"nft.mint.batch",docLinks:{sdk:"sdk.erc721batchmintable",contracts:"erc721batchmintable"},abis:[tn,tl,X],features:{}},iI={name:"ERC721Mintable",namespace:"nft.mint",docLinks:{sdk:"sdk.erc721mintable",contracts:"erc721mintable"},abis:[tn,tl],features:{[iO.name]:iO}},iR={name:"ERC721SignatureMintV2",namespace:"nft.signature",docLinks:{sdk:"sdk.erc721signaturemint",contracts:"erc721signaturemint"},abis:[tn,td],features:{}},iN={name:"ERC721SignatureMintV1",namespace:"nft.signature",docLinks:{sdk:"sdk.erc721signaturemint",contracts:"erc721signaturemint"},abis:[tp],features:{}},iL={name:"ERC721Enumerable",namespace:"nft.query.owned",docLinks:{sdk:"sdk.erc721enumerable",contracts:"erc721enumerable"},abis:[tn,ts],features:{}},iM={name:"ERC721Supply",namespace:"nft.query",docLinks:{sdk:"sdk.erc721supply",contracts:"erc721supply"},abis:[tn,to],features:{[iL.name]:iL}},iz={name:"ERC721",namespace:"nft",docLinks:{sdk:"sdk.erc721",contracts:"erc721"},abis:[tn],features:{[iE.name]:iE,[iM.name]:iM,[iI.name]:iI,[iF.name]:iF,[iN.name]:iN,[iR.name]:iR,[iS.name]:iS,[iD.name]:iD,[i_.name]:i_,[iP.name]:iP,[ix.name]:ix,[iB.name]:iB}},i$={name:"ERC1155Burnable",namespace:"edition.burn",docLinks:{sdk:"sdk.erc1155burnable",contracts:"erc1155burnable"},abis:[tb,th],features:{}},iU={name:"ERC1155ClaimConditionsV1",namespace:"edition.drop.claim",docLinks:{sdk:"sdk.erc1155claimable",contracts:"erc1155dropsinglephase"},abis:[tb,tw],features:{}},iV={name:"ERC1155ClaimConditionsV2",namespace:"edition.drop.claim",docLinks:{sdk:"sdk.erc1155claimable",contracts:"erc1155claimconditions"},abis:[tb,ty],features:{}},iq={name:"ERC1155ClaimPhasesV2",namespace:"edition.drop.claim",docLinks:{sdk:"sdk.erc1155claimable",contracts:"erc1155claimphases"},abis:[tb,tm],features:{}},ij={name:"ERC1155ClaimPhasesV1",namespace:"edition.drop.claim",docLinks:{sdk:"sdk.erc1155claimable",contracts:"erc1155claimphases"},abis:[tg],features:{}},iG={name:"ERC1155ClaimCustom",namespace:"edition.drop.claim",docLinks:{sdk:"sdk.erc1155claimable",contracts:"erc1155claimcustom"},abis:[tb,tu],features:{}},iH={name:"ERC1155Revealable",namespace:"edition.drop.revealer",docLinks:{sdk:"sdk.drop.delayedreveal",contracts:"erc1155revealable"},abis:[tb,tc,ta],features:{}},iZ={name:"ERC1155LazyMintableV2",namespace:"edition.drop",docLinks:{sdk:"sdk.erc1155droppable",contracts:"lazymint"},abis:[tb,tc],features:{[iH.name]:iH}},iJ={name:"ERC1155LazyMintableV1",namespace:"edition.drop",docLinks:{sdk:"sdk.erc1155droppable",contracts:"lazymint"},abis:[tg],features:{[ij.name]:ij}},iY={name:"ERC1155SignatureMintable",namespace:"edition.signature",docLinks:{sdk:"sdk.erc1155signaturemintable",contracts:"erc1155signaturemint"},abis:[tb,tW],features:{}},iK={name:"ERC1155BatchMintable",namespace:"edition.mint.batch",docLinks:{sdk:"sdk.erc1155batchmintable",contracts:"erc1155batchmintable"},abis:[tb,tv,X],features:{}},iQ={name:"ERC1155Mintable",namespace:"edition.mint",docLinks:{sdk:"sdk.erc1155mintable",contracts:"erc1155mintable"},abis:[tb,tv],features:{[iK.name]:iK}},iX={name:"ERC1155Enumerable",namespace:"edition.query",docLinks:{sdk:"sdk.erc1155",contracts:"erc1155enumerable"},abis:[tb,tC],features:{}},i0={name:"ERC1155",namespace:"edition",docLinks:{sdk:"sdk.erc1155enumerable",contracts:"erc1155"},abis:[tb],features:{[i$.name]:i$,[iX.name]:iX,[iQ.name]:iQ,[iJ.name]:iJ,[iZ.name]:iZ,[iH.name]:iH,[iY.name]:iY,[iG.name]:iG,[iU.name]:iU,[iV.name]:iV,[iq.name]:iq}},i1={[ik.name]:ik,[iz.name]:iz,[i0.name]:i0,[a7.name]:a7,[it.name]:it,[a9.name]:a9,[ir.name]:ir,[ia.name]:ia,[ii.name]:ii,[is.name]:is,[io.name]:io,[ic.name]:ic,[il.name]:il,[id.name]:id,[ip.name]:ip,[ih.name]:ih,[iu.name]:iu};try{i=new TextDecoder}catch(i2){}let i5=0,i6={},i8={},i3=0,i4=0,i7=[],i9=[],nt={useRecords:!1,mapsAsObjects:!0},ne=!1;class nr{constructor(t){if(t&&((t.keyMap||t._keyMap)&&!t.useRecords&&(t.useRecords=!1,t.mapsAsObjects=!0),!1===t.useRecords&&void 0===t.mapsAsObjects&&(t.mapsAsObjects=!0),t.getStructures&&(t.getShared=t.getStructures),t.getShared&&!t.structures&&((t.structures=[]).uninitialized=!0),t.keyMap))for(let[e,r]of(this.mapKey=new Map,Object.entries(t.keyMap)))this.mapKey.set(r,e);Object.assign(this,t)}decodeKey(t){return this.keyMap&&this.mapKey.get(t)||t}decode(t,e){if(n)return nE(()=>(nT(),this?this.decode(t,e):nr.prototype.decode.call(nt,t,e)));s=e>-1?e:t.length,i5=0,i4=0,c=null,l=null,n=t;try{f=t.dataView||(t.dataView=new DataView(t.buffer,t.byteOffset,t.byteLength))}catch(r){if(n=null,t instanceof Uint8Array)throw r;throw Error("Source must be a Uint8Array or Buffer but was a "+(t&&"object"==typeof t?t.constructor.name:typeof t))}return this instanceof nr?(i8=this,p=this.sharedValues&&(this.pack?Array(this.maxPrivatePackedValues||16).concat(this.sharedValues):this.sharedValues),this.structures?o=this.structures:(!o||o.length>0)&&(o=[])):(i8=nt,(!o||o.length>0)&&(o=[]),p=null),function(){try{let t=na();if(l){if(i5>=l.postBundlePosition){let e=Error("Unexpected bundle position");throw e.incomplete=!0,e}i5=l.postBundlePosition,l=null}if(i5==s)o=null,n=null,d&&(d=null);else if(i5>s){let r=Error("Unexpected end of CBOR data");throw r.incomplete=!0,r}else if(!ne)throw Error("Data read, but end of buffer not reached");return t}catch(a){throw nT(),(a instanceof RangeError||a.message.startsWith("Unexpected end of buffer"))&&(a.incomplete=!0),a}}()}}function na(){let t=n[i5++],e=t>>5;if((t&=31)>23)switch(t){case 24:t=n[i5++];break;case 25:if(7==e)return function(){let t=n[i5++],e=n[i5++],r=(127&t)>>2;if(31===r)return e||3&t?NaN:128&t?-1/0:1/0;if(0===r){let a=((3&t)<<8|e)/16777216;return 128&t?-a:a}return nf[3]=128&t|(r>>1)+56,nf[2]=(7&t)<<5|e>>3,nf[1]=e<<5,nf[0]=0,np[0]}();t=f.getUint16(i5),i5+=2;break;case 26:if(7==e){let r=f.getFloat32(i5);if(i8.useFloat32>2){let a=nS[(127&n[i5])<<1|n[i5+1]>>7];return i5+=4,(a*r+(r>0?.5:-.5)>>0)/a}return i5+=4,r}t=f.getUint32(i5),i5+=4;break;case 27:if(7==e){let i=f.getFloat64(i5);return i5+=8,i}if(e>1){if(f.getUint32(i5)>0)throw Error("JavaScript does not support arrays, maps, or strings with length over 4294967295");t=f.getUint32(i5+4)}else i8.int64AsNumber?(t=4294967296*f.getUint32(i5),t+=f.getUint32(i5+4)):t=f.getBigUint64(i5);i5+=8;break;case 31:switch(e){case 2:case 3:throw Error("Indefinite length not supported for byte or text strings");case 4:let d=[],u,m=0;for(;(u=na())!=i6;)d[m++]=u;return 4==e?d:3==e?d.join(""):et.concat(d);case 5:let g;if(i8.mapsAsObjects){let y={};if(i8.keyMap)for(;(g=na())!=i6;)y[ns(i8.decodeKey(g))]=na();else for(;(g=na())!=i6;)y[ns(g)]=na();return y}{h&&(i8.mapsAsObjects=!0,h=!1);let w=new Map;if(i8.keyMap)for(;(g=na())!=i6;)w.set(i8.decodeKey(g),na());else for(;(g=na())!=i6;)w.set(g,na());return w}case 7:return i6;default:throw Error("Invalid major type for indefinite length "+e)}default:throw Error("Unknown token "+t)}switch(e){case 0:return t;case 1:return~t;case 2:var b;return b=t,i8.copyBuffers?Uint8Array.prototype.slice.call(n,i5,i5+=b):n.subarray(i5,i5+=b);case 3:if(i4>=i5)return c.slice(i5-i3,(i5+=t)-i3);if(0==i4&&s<140&&t<32){let C=t<16?nd(t):function(t){let e=i5,r=Array(t);for(let a=0;a<t;a++){let i=n[i5++];if((128&i)>0){i5=e;return}r[a]=i}return nl.apply(String,r)}(t);if(null!=C)return C}return no(t);case 4:let v=Array(t);for(let W=0;W<t;W++)v[W]=na();return v;case 5:if(i8.mapsAsObjects){let A={};if(i8.keyMap)for(let k=0;k<t;k++)A[ns(i8.decodeKey(na()))]=na();else for(let E=0;E<t;E++)A[ns(na())]=na();return A}{h&&(i8.mapsAsObjects=!0,h=!1);let T=new Map;if(i8.keyMap)for(let S=0;S<t;S++)T.set(i8.decodeKey(na()),na());else for(let _=0;_<t;_++)T.set(na(),na());return T}case 6:if(t>=57337){let P=o[8191&t];if(P)return P.read||(P.read=nn(P)),P.read();if(t<65536){if(57343==t)return nu(na());if(57342==t){let x=nA(),B=na();for(let D=2;D<x;D++)nu([B++,na()]);return na()}if(57337==t)return function(){let t=nA(),e=i5+na();for(let r=2;r<t;r++){let a=nA();i5+=a}let i=i5;return i5=e,(l=[nc(nA()),nc(nA())]).position0=0,l.position1=0,l.postBundlePosition=i5,i5=i,na()}();if(i8.getShared&&(nk(),P=o[8191&t]))return P.read||(P.read=nn(P)),P.read()}}let F=i7[t];if(F){if(F.handlesRead)return F(na);return F(na())}{let O=na();for(let I=0;I<i9.length;I++){let R=i9[I](t,O);if(void 0!==R)return R}return new nh(O,t)}case 7:switch(t){case 20:return!1;case 21:return!0;case 22:return null;case 23:return;default:let N=(p||nw())[t];if(void 0!==N)return N;throw Error("Unknown token "+t)}default:if(isNaN(t)){let L=Error("Unexpected end of CBOR data");throw L.incomplete=!0,L}throw Error("Unknown CBOR token "+t)}}let ni=/^[a-zA-Z_$][a-zA-Z\d_$]*$/;function nn(t){return t.slowReads=0,function(){let t=n[i5++];if((t&=31)>23)switch(t){case 24:t=n[i5++];break;case 25:t=f.getUint16(i5),i5+=2;break;case 26:t=f.getUint32(i5),i5+=4;break;default:throw Error("Expected array header, but got "+n[i5-1])}let e=this.compiledReader;for(;e;){if(e.propertyCount===t)return e(na);e=e.next}if(this.slowReads++>=3){let r=this.length==t?this:this.slice(0,t);return e=i8.keyMap?Function("r","return {"+r.map(t=>i8.decodeKey(t)).map(t=>ni.test(t)?ns(t)+":r()":"["+JSON.stringify(t)+"]:r()").join(",")+"}"):Function("r","return {"+r.map(t=>ni.test(t)?ns(t)+":r()":"["+JSON.stringify(t)+"]:r()").join(",")+"}"),this.compiledReader&&(e.next=this.compiledReader),e.propertyCount=t,this.compiledReader=e,e(na)}let a={};if(i8.keyMap)for(let i=0;i<t;i++)a[ns(i8.decodeKey(this[i]))]=na();else for(let s=0;s<t;s++)a[ns(this[s])]=na();return a}}function ns(t){return"__proto__"===t?"__proto_":t}let no=nc;function nc(t){let e;if(t<16&&(e=nd(t)))return e;if(t>64&&i)return i.decode(n.subarray(i5,i5+=t));let r=i5+t,a=[];for(e="";i5<r;){let s=n[i5++];if((128&s)==0)a.push(s);else if((224&s)==192){let o=63&n[i5++];a.push((31&s)<<6|o)}else if((240&s)==224){let c=63&n[i5++],l=63&n[i5++];a.push((31&s)<<12|c<<6|l)}else if((248&s)==240){let d=63&n[i5++],p=63&n[i5++],f=63&n[i5++],h=(7&s)<<18|d<<12|p<<6|f;h>65535&&(h-=65536,a.push(h>>>10&1023|55296),h=56320|1023&h),a.push(h)}else a.push(s);a.length>=4096&&(e+=nl.apply(String,a),a.length=0)}return a.length>0&&(e+=nl.apply(String,a)),e}let nl=String.fromCharCode;function nd(t){if(t<4){if(t<2){if(0===t)return"";{let e=n[i5++];if((128&e)>1){i5-=1;return}return nl(e)}}{let r=n[i5++],a=n[i5++];if((128&r)>0||(128&a)>0){i5-=2;return}if(t<3)return nl(r,a);let i=n[i5++];if((128&i)>0){i5-=3;return}return nl(r,a,i)}}{let s=n[i5++],o=n[i5++],c=n[i5++],l=n[i5++];if((128&s)>0||(128&o)>0||(128&c)>0||(128&l)>0){i5-=4;return}if(t<6){if(4===t)return nl(s,o,c,l);{let d=n[i5++];if((128&d)>0){i5-=5;return}return nl(s,o,c,l,d)}}if(t<8){let p=n[i5++],f=n[i5++];if((128&p)>0||(128&f)>0){i5-=6;return}if(t<7)return nl(s,o,c,l,p,f);let h=n[i5++];if((128&h)>0){i5-=7;return}return nl(s,o,c,l,p,f,h)}{let u=n[i5++],m=n[i5++],g=n[i5++],y=n[i5++];if((128&u)>0||(128&m)>0||(128&g)>0||(128&y)>0){i5-=8;return}if(t<10){if(8===t)return nl(s,o,c,l,u,m,g,y);{let w=n[i5++];if((128&w)>0){i5-=9;return}return nl(s,o,c,l,u,m,g,y,w)}}if(t<12){let b=n[i5++],C=n[i5++];if((128&b)>0||(128&C)>0){i5-=10;return}if(t<11)return nl(s,o,c,l,u,m,g,y,b,C);let v=n[i5++];if((128&v)>0){i5-=11;return}return nl(s,o,c,l,u,m,g,y,b,C,v)}{let W=n[i5++],A=n[i5++],k=n[i5++],E=n[i5++];if((128&W)>0||(128&A)>0||(128&k)>0||(128&E)>0){i5-=12;return}if(t<14){if(12===t)return nl(s,o,c,l,u,m,g,y,W,A,k,E);{let T=n[i5++];if((128&T)>0){i5-=13;return}return nl(s,o,c,l,u,m,g,y,W,A,k,E,T)}}{let S=n[i5++],_=n[i5++];if((128&S)>0||(128&_)>0){i5-=14;return}if(t<15)return nl(s,o,c,l,u,m,g,y,W,A,k,E,S,_);let P=n[i5++];if((128&P)>0){i5-=15;return}return nl(s,o,c,l,u,m,g,y,W,A,k,E,S,_,P)}}}}}let np=new Float32Array(1),nf=new Uint8Array(np.buffer,0,4);class nh{constructor(t,e){this.value=t,this.tag=e}}i7[0]=t=>new Date(t),i7[1]=t=>new Date(Math.round(1e3*t)),i7[2]=t=>{let e=BigInt(0);for(let r=0,a=t.byteLength;r<a;r++)e=BigInt(t[r])+e<<BigInt(8);return e},i7[3]=t=>BigInt(-1)-i7[2](t),i7[4]=t=>Number(t[1]+"e"+t[0]),i7[5]=t=>t[1]*Math.exp(t[0]*Math.log(2));let nu=t=>{let e=t[0]-57344,r=t[1],a=o[e];a&&a.isShared&&((o.restoreStructures||(o.restoreStructures=[]))[e]=a),o[e]=r,r.read=nn(r);let i={};if(i8.keyMap)for(let n=2,s=t.length;n<s;n++)i[ns(i8.decodeKey(r[n-2]))]=t[n];else for(let c=2,l=t.length;c<l;c++)i[ns(r[c-2])]=t[c];return i};i7[105]=nu,i7[14]=t=>l?l[0].slice(l.position0,l.position0+=t):new nh(t,14),i7[15]=t=>l?l[1].slice(l.position1,l.position1+=t):new nh(t,15);let nm={Error,RegExp};i7[27]=t=>(nm[t[0]]||Error)(t[1],t[2]);let ng=t=>{if(132!=n[i5++])throw Error("Packed values structure must be followed by a 4 element array");let e=t();return(p=p?e.concat(p.slice(e.length)):e).prefixes=t(),p.suffixes=t(),t()};function ny(t,e){return"string"==typeof t?t+e:t instanceof Array?t.concat(e):Object.assign({},t,e)}function nw(){if(!p){if(i8.getShared)nk();else throw Error("No packed values available")}return p}ng.handlesRead=!0,i7[51]=ng,i7[6]=t=>{if(!p){if(!i8.getShared)return new nh(t,6);nk()}if("number"==typeof t)return p[16+(t>=0?2*t:-2*t-1)];throw Error("No support for non-integer packed references yet")},i7[25]=t=>stringRefs[t],i7[256]=t=>{stringRefs=[];try{return t()}finally{stringRefs=null}},i7[256].handlesRead=!0,i7[28]=t=>{let e;d||((d=new Map).id=0);let r=d.id++;e=n[i5]>>5==4?[]:{};let a={target:e};d.set(r,a);let i=t();return a.used?Object.assign(e,i):(a.target=i,i)},i7[28].handlesRead=!0,i7[29]=t=>{let e=d.get(t);return e.used=!0,e.target},i7[258]=t=>new Set(t),(i7[259]=t=>(i8.mapsAsObjects&&(i8.mapsAsObjects=!1,h=!0),t())).handlesRead=!0,i9.push((t,e)=>t>=225&&t<=255?ny(nw().prefixes[t-224],e):t>=28704&&t<=32767?ny(nw().prefixes[t-28672],e):t>=1879052288&&t<=2147483647?ny(nw().prefixes[t-1879048192],e):t>=216&&t<=223?ny(e,nw().suffixes[t-216]):t>=27647&&t<=28671?ny(e,nw().suffixes[t-27639]):t>=1811940352&&t<=1879048191?ny(e,nw().suffixes[t-1811939328]):1399353956==t?{packedValues:p,structures:o.slice(0),version:e}:55799==t?e:void 0);let nb=1==new Uint8Array(new Uint16Array([1]).buffer)[0],nC=[Uint8Array],nv=[64];for(let nW=0;nW<nC.length;nW++)!function(t,e){let r="get"+t.name.slice(0,-5);"function"!=typeof t&&(t=null);let a=t.BYTES_PER_ELEMENT;for(let i=0;i<2;i++){if(!i&&1==a)continue;let n=2==a?1:4==a?2:3;i7[i?e:e-4]=1==a||i==nb?r=>{if(!t)throw Error("Could not find typed array for code "+e);return new t(Uint8Array.prototype.slice.call(r,0).buffer)}:a=>{if(!t)throw Error("Could not find typed array for code "+e);let s=new DataView(a.buffer,a.byteOffset,a.byteLength),o=a.length>>n,c=new t(o),l=s[r];for(let d=0;d<o;d++)c[d]=l.call(s,d<<n,i);return c}}}(nC[nW],nv[nW]);function nA(){let t=31&n[i5++];if(t>23)switch(t){case 24:t=n[i5++];break;case 25:t=f.getUint16(i5),i5+=2;break;case 26:t=f.getUint32(i5),i5+=4}return t}function nk(){if(i8.getShared){let t=nE(()=>(n=null,i8.getShared()))||{},e=t.structures||[];i8.sharedVersion=t.version,p=i8.sharedValues=t.packedValues,!0===o?i8.structures=o=e:o.splice.apply(o,[0,e.length].concat(e))}}function nE(t){let e=s,r=i5,a=i3,i=i4,p=c,h=d,u=l,m=new Uint8Array(n.slice(0,s)),g=o,y=i8,w=ne,b=t();return s=e,i5=r,i3=a,i4=i,c=p,d=h,l=u,n=m,ne=w,o=g,i8=y,f=new DataView(n.buffer,n.byteOffset,n.byteLength),b}function nT(){n=null,d=null,o=null}let nS=Array(147);for(let n_=0;n_<256;n_++)nS[n_]=Number("1e"+Math.floor(45.15-.30103*n_));let nP=new nr({useRecords:!1}),nx=nP.decode;async function nB(t,e){let r=await nM(t,e);return nO(r.abi)}async function nD(t,e){let r=await nM(t,e);return nI(r.abi,r.metadata)}function nF(t,e,r){return e?.output?.userdoc?.[r]?.[Object.keys(e?.output?.userdoc[r]||{}).find(e=>e.includes(t||"unknown"))||""]?.notice||e?.output?.devdoc?.[r]?.[Object.keys(e?.output?.devdoc[r]||{}).find(e=>e.includes(t||"unknown"))||""]?.details}function nO(t){let e=cd.parse(t||[]);for(let r of e)if("constructor"===r.type)return r.inputs||[];return[]}function nI(t,e){let r=(t||[]).filter(t=>"function"===t.type),a=[];for(let i of r){let n=nF(i.name,e,"methods"),s=i.inputs?.map(t=>`${t.name||"key"}: ${nR(t)}`)?.join(", ")||"",o=s?`, ${s}`:"",c=i.outputs?.map(t=>nR(t,!0))?.join(", "),l=c?`: Promise<${c}>`:": Promise<TransactionResult>",d=`contract.call("${i.name}"${o})${l}`;a.push({inputs:i.inputs||[],outputs:i.outputs||[],name:i.name||"unknown",signature:d,stateMutability:i.stateMutability||"",comment:n})}return a}function nR(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],r=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=t.type,i=!1;return a.endsWith("[]")&&(i=!0,a=a.slice(0,-2)),a.startsWith("bytes")&&(a="BytesLike"),(a.startsWith("uint")||a.startsWith("int"))&&(a=e?"BigNumber":"BigNumberish"),a.startsWith("bool")&&(a="boolean"),"address"===a&&(a="string"),"tuple"===a&&t.components&&(a=`{ ${t.components.map(t=>nR(t,!1,!0)).join(", ")} }`),i&&(a+="[]"),r&&(a=`${t.name}: ${a}`),a}async function nN(t,e){let r;try{r=await e.getCode(t)}catch(a){throw Error(`Failed to get bytecode for address ${t}: ${a}`)}if("0x"===r){let i=await e.getNetwork();throw Error(`Contract at ${t} does not exist on chain '${i.name}' (chainId: ${i.chainId})`)}try{let n=function(t){if(t.startsWith("0x363d3d373d3d3d363d73")){let e=t.slice(22,62);return`0x${e}`}if(t.startsWith("0x36603057343d5230")){let r=t.slice(122,162);return`0x${r}`}if(t.startsWith("0x3d3d3d3d363d3d37363d73")){let a=t.slice(24,64);return`0x${a}`}if(t.startsWith("0x366000600037611000600036600073")){let i=t.slice(32,72);return`0x${i}`}}(r);if(n)return await nN(n,e)}catch(s){}try{let o=await e.getStorageAt(t,T.O$.from("0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc")),c=`0x${o.slice(-40)}`;if((0,t$.isAddress)(c)&&c!==C.d)return await nN(c,e)}catch(l){}return await function(t){let e=function(t){var e;if((t=t.toString(16)).startsWith("0x")||(t=`0x${t}`),!(("string"==typeof(e=t)||"number"==typeof e)&&/^(-)?0x[0-9a-f]*$/i.test(e.toString())))throw Error(`Given value "${t}" is not a valid hex string.`);t=t.replace(/^0x/i,"");let r=[];for(let a=0;a<t.length;a+=2)r.push(parseInt(t.slice(a,a+2),16));return r}(t),r=256*e[e.length-2]+e[e.length-1],a=Uint8Array.from(e.slice(e.length-2-r,-2)),i=nx(a);if("ipfs"in i&&i.ipfs)try{return`ipfs://${tz().encode(i.ipfs)}`}catch(n){console.warn("feature-detection ipfs cbor failed",n)}}(r)}async function nL(t,e){return cp.parse(JSON.parse(await (await e.download(t)).text()))}async function nM(t,e){let r=await nL(t,e),a=await (await e.download(r.bytecodeUri)).text(),i=await o3(r.metadataUri,e);return cA.parse({...r,...i,bytecode:a})}async function nz(t,e){let r=await (await e.download(t)).text();return cy.parse(JSON.parse(r))}function n$(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:i1,r={};for(let a in e){let i=e[a],n=function(t,e){let r=nI(t),a=e.flatMap(t=>nI(t)),i=r.filter(t=>{let e=a.find(e=>e.name===t.name&&e.inputs.length===t.inputs.length&&e.inputs.every((e,r)=>"tuple"===e.type||"tuple[]"===e.type?e.type===t.inputs[r].type&&e.components?.every((e,a)=>e.type===t.inputs[r].components?.[a]?.type):e.type===t.inputs[r].type));return void 0!==e});return i.length===a.length}(t,i.abis),s=n$(t,i.features);r[a]={...i,features:s,enabled:n}}return r}function nU(t){let e=[];return!function t(e,r){if(e)for(let a in e){let i=e[a];i.enabled&&r.push(i),t(i.features,r)}}(n$(t),e),e.map(t=>t.name)}function nV(t,e){let r=cd.parse(t||[]),a=n$(r);return function t(e,r){let a=Object.keys(e);if(!a.includes(r)){let i=!1;for(let n of a){let s=e[n];if(i=t(s.features,r))break}return i}let o=e[r];return o.enabled}(a,e)}function nq(t,e){if(!t)throw new r4(e);return t}function nj(t,e){return nV(cd.parse(t.abi),e)}function nG(t,e){return t in e.readContract.functions}let nH="0x60606040526040805190810160405280600d81526020017f57726170706564204574686572000000000000000000000000000000000000008152506000908051906020019061004f9291906100c8565b506040805190810160405280600481526020017f57455448000000000000000000000000000000000000000000000000000000008152506001908051906020019061009b9291906100c8565b506012600260006101000a81548160ff021916908360ff16021790555034156100c357600080fd5b61016d565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061010957805160ff1916838001178555610137565b82800160010185558215610137579182015b8281111561013657825182559160200191906001019061011b565b5b5090506101449190610148565b5090565b61016a91905b8082111561016657600081600090555060010161014e565b5090565b90565b610c348061017c6000396000f3006060604052600436106100af576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806306fdde03146100b9578063095ea7b31461014757806318160ddd146101a157806323b872dd146101ca5780632e1a7d4d14610243578063313ce5671461026657806370a082311461029557806395d89b41146102e2578063a9059cbb14610370578063d0e30db0146103ca578063dd62ed3e146103d4575b6100b7610440565b005b34156100c457600080fd5b6100cc6104dd565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561010c5780820151818401526020810190506100f1565b50505050905090810190601f1680156101395780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561015257600080fd5b610187600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803590602001909190505061057b565b604051808215151515815260200191505060405180910390f35b34156101ac57600080fd5b6101b461066d565b6040518082815260200191505060405180910390f35b34156101d557600080fd5b610229600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803590602001909190505061068c565b604051808215151515815260200191505060405180910390f35b341561024e57600080fd5b61026460048080359060200190919050506109d9565b005b341561027157600080fd5b610279610b05565b604051808260ff1660ff16815260200191505060405180910390f35b34156102a057600080fd5b6102cc600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610b18565b6040518082815260200191505060405180910390f35b34156102ed57600080fd5b6102f5610b30565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561033557808201518184015260208101905061031a565b50505050905090810190601f1680156103625780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561037b57600080fd5b6103b0600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091908035906020019091905050610bce565b604051808215151515815260200191505060405180910390f35b6103d2610440565b005b34156103df57600080fd5b61042a600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610be3565b6040518082815260200191505060405180910390f35b34600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055503373ffffffffffffffffffffffffffffffffffffffff167fe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c346040518082815260200191505060405180910390a2565b60008054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156105735780601f1061054857610100808354040283529160200191610573565b820191906000526020600020905b81548152906001019060200180831161055657829003601f168201915b505050505081565b600081600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925846040518082815260200191505060405180910390a36001905092915050565b60003073ffffffffffffffffffffffffffffffffffffffff1631905090565b600081600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054101515156106dc57600080fd5b3373ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff16141580156107b457507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205414155b156108cf5781600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541015151561084457600080fd5b81600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825403925050819055505b81600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254039250508190555081600360008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a3600190509392505050565b80600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205410151515610a2757600080fd5b80600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825403925050819055503373ffffffffffffffffffffffffffffffffffffffff166108fc829081150290604051600060405180830381858888f193505050501515610ab457600080fd5b3373ffffffffffffffffffffffffffffffffffffffff167f7fcf532c15f0a6db0bd6d0e038bea71d30d808c7d98cb3bf7268a95bf5081b65826040518082815260200191505060405180910390a250565b600260009054906101000a900460ff1681565b60036020528060005260406000206000915090505481565b60018054600181600116156101000203166002900480601f016020809104026020016040519081016040528092919081815260200182805460018160011615610100020316600290048015610bc65780601f10610b9b57610100808354040283529160200191610bc6565b820191906000526020600020905b815481529060010190602001808311610ba957829003601f168201915b505050505081565b6000610bdb33848461068c565b905092915050565b60046020528160005260406000206020528060005260406000206000915091505054815600a165627a7a72305820deb4c2ccab3c2fdca32ab3f46728389c2fe2c165d5fafa07661e4e004f6c344a0029",nZ=["eip-155","protected","invalid chain id for signer","chain id none","chain_id mismatch","recovered sender mismatch","transaction hash mismatch","chainid no support"],nJ=[["account","not found"],["wrong","chainid"]],nY={5001:{name:"Mantle Testnet",gasPrice:1},71402:{name:"Godwoken Mainnet",gasPrice:4e13}};function nK(t){let e=nZ.findIndex(e=>t.includes(e)),r=nJ.findIndex(e=>{let r=!0;return e.forEach(e=>{r&&=t.includes(e)}),r});return -1!==e||-1!==r}let nQ="0xdd99b75f095d0c4d5112aCe938e4e6ed962fb024",nX={v:27,r:"0x2222222222222222222222222222222222222222222222222222222222222222",s:"0x2222222222222222222222222222222222222222222222222222222222222222"},n0="0x4e59b44847b379578588920cA78FbF26c0B4956C",n1=[{inputs:[{components:[{internalType:"address",name:"predictedAddress",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],internalType:"struct IDeployer.Transaction[]",name:"transactions",type:"tuple[]"}],stateMutability:"payable",type:"constructor"}],n2={},n5={},n6={};async function n8(t,e){let r=await e.getCode(t);return"0x"!==r&&"0x0"!==r}async function n3(t){try{await t.sendTransaction("0xf8a58085174876e800830186a08080b853604580600e600039806000f350fe7fffffffffffffffafffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf31ba02222222222222222222222222222222222222222222222222222222222222222a02222222222222222222222222222222222222222222222222222222222222222")}catch(a){let e=a.toString().toLowerCase(),r=JSON.stringify(a).toLowerCase();if(nK(e)||nK(r))return!0}return!1}async function n4(t){let e=await n8(n0,t);if(e)return n0;let r=await n3(t),a=(await t.getNetwork()).chainId,i=r?a:0,n=nY[a]?sl(i,nY[a].gasPrice):sl(i);return n.deployment}function n7(t){let e=N.id(t),r=`tw.${e}`,a=N.id(r);return a}function n9(t,e){let r=n7(t),a=I.pack(["bytes32","bytes","bytes"],[r,t,e]);return a}function st(t,e,r){let a=n7(t),i=I.pack(["bytes","bytes"],[t,e]),n=I.pack(["bytes1","address","bytes32","bytes32"],["0xff",r,a,I.keccak256(["bytes"],[i])]),s=I.keccak256(["bytes"],[n]);return`0x${s.slice(26)}`}async function se(t,e,r){return r||(r=await n4(t)),(await so("infra",t,e,r,{contractName:"Forwarder"})).transaction.predictedAddress}async function sr(t,e,r){return r||(r=await n4(t)),(await so("infra",t,e,r,{contractName:"TWCloneFactory"})).transaction.predictedAddress}async function sa(t,e){(0,tH.Z)(t.provider,"No provider");let r=await n8(n0,t.provider);if(r)return n0;let a=await n3(t.provider),i=(await t.provider.getNetwork()).chainId,n=a?i:0;console.debug(`ChainId ${i} enforces EIP155: ${a}`);let s=nY[i]?sl(n,nY[i].gasPrice):sl(n),o=await n8(s.deployment,t.provider);if(!o){let c=nY[i]?T.O$.from(nY[i].gasPrice).mul(1e5):B.parseEther(tR.A.parse("0.01"));(await t.provider.getBalance(s.signer)).lt(c)&&await t.sendTransaction({to:s.signer,value:c});try{console.debug(`deploying CREATE2 factory at: ${s.deployment}`),e?.notifier?.("deploying","create2Factory"),await t.provider.sendTransaction(s.transaction),e?.notifier?.("deployed","create2Factory")}catch(l){throw Error(`Couldn't deploy CREATE2 factory: ${JSON.stringify(l)}`)}}return s.deployment}async function si(t,e,r){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:7e6;(0,tH.Z)(t.provider,"Provider required");let i=await n8(e.predictedAddress,t.provider);if(!i){console.debug(`deploying contract via create2 factory at: ${e.predictedAddress}`);let n={to:e.to,data:e.data};try{await t.estimateGas(n)}catch(s){console.debug("error estimating gas while deploying prebuilt: ",s),n.gasLimit=T.O$.from(a)}r?.notifier?.("deploying","preset"),await (await t.sendTransaction(n)).wait(),r?.notifier?.("deployed","preset")}}async function sn(t,e,r,a){n2={};let i=a||await n4(r),n={},s=[],{compilerMetadata:o}=await sp(t,e),c=await sm(t,e);if(c.length>0){let l=await Promise.all(c.map(async t=>{let a=await so("plugin",r,e,i,{metadata:t});return a})),d=[];c.forEach((t,e)=>{let r=function(t,e){let r=new $.vU(e),a=[];for(let i of Object.values(r.functions)){let n=r.getFunction(i.name);n.name.includes("_")||a.push({functionSelector:r.getSighash(n),functionSignature:n.name+function t(e){return"("+e.map(e=>"tuple"===e.type?t(e.components):e.type).join(",")+")"}(n.inputs),pluginAddress:t})}return a}(l[e].transaction.predictedAddress,t.abi);d.push(...r)});let p=await so("plugin",r,e,i,{contractName:"PluginMap",constructorParams:{_pluginsToAdd:{value:d}}});n._pluginMap={value:p.transaction.predictedAddress},s.push(...l,p)}let f=await so("implementation",r,e,i,{metadata:o,constructorParams:n}),h=await so("infra",r,e,i,{contractName:"TWCloneFactory"});return s.push(h),s.push(...Object.values(n2)),s.push(f),s}async function ss(t,e,r){let a=sf(e);if(0===a.length)return;r?.notifier?.("deploying","infra");let i=await Promise.all(a.map(e=>{let r=new F.lV(n1,"0x60806040526040516107f33803806107f383398101604081905261002291610359565b805160005b818110156100c157828181518110610041576100416104c9565b6020026020010151600001516001600160a01b03163b600014156100af576100ad838281518110610074576100746104c9565b602002602001015160200151848381518110610092576100926104c9565b6020026020010151604001516100c960201b6100091760201c565b505b806100b9816104df565b915050610027565b505050610557565b606061011183836040518060400160405280601e81526020017f416464726573733a206c6f772d6c6576656c2063616c6c206661696c6564000081525061011860201b60201c565b9392505050565b6060610127848460008561012f565b949350505050565b6060824710156101955760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b60648201526084015b60405180910390fd5b6001600160a01b0385163b6101ec5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000604482015260640161018c565b600080866001600160a01b031685876040516102089190610508565b60006040518083038185875af1925050503d8060008114610245576040519150601f19603f3d011682016040523d82523d6000602084013e61024a565b606091505b50909250905061025b828286610266565b979650505050505050565b60608315610275575081610111565b8251156102855782518084602001fd5b8160405162461bcd60e51b815260040161018c9190610524565b634e487b7160e01b600052604160045260246000fd5b604051606081016001600160401b03811182821017156102d7576102d761029f565b60405290565b604051601f8201601f191681016001600160401b03811182821017156103055761030561029f565b604052919050565b80516001600160a01b038116811461032457600080fd5b919050565b60005b8381101561034457818101518382015260200161032c565b83811115610353576000848401525b50505050565b6000602080838503121561036c57600080fd5b82516001600160401b038082111561038357600080fd5b818501915085601f83011261039757600080fd5b8151818111156103a9576103a961029f565b8060051b6103b88582016102dd565b91825283810185019185810190898411156103d257600080fd5b86860192505b838310156104bc578251858111156103f05760008081fd5b86016060601f19828d0381018213156104095760008081fd5b6104116102b5565b61041c8b850161030d565b8152604061042b81860161030d565b828d01529284015192898411156104425760008081fd5b83850194508e603f86011261045957600093508384fd5b8b85015193508984111561046f5761046f61029f565b61047f8c84601f870116016102dd565b92508383528e818587010111156104965760008081fd5b6104a5848d8501838801610329565b8101919091528452505091860191908601906103d8565b9998505050505050505050565b634e487b7160e01b600052603260045260246000fd5b600060001982141561050157634e487b7160e01b600052601160045260246000fd5b5060010190565b6000825161051a818460208701610329565b9190910192915050565b6020815260008251806020840152610543816040850160208701610329565b601f01601f19169190910160400192915050565b61028d806105666000396000f3fe6080604052600080fd5b606061004b83836040518060400160405280601e81526020017f416464726573733a206c6f772d6c6576656c2063616c6c206661696c65640000815250610052565b9392505050565b60606100618484600085610069565b949350505050565b6060824710156100cf5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b60648201526084015b60405180910390fd5b6001600160a01b0385163b6101265760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016100c6565b600080866001600160a01b031685876040516101429190610208565b60006040518083038185875af1925050503d806000811461017f576040519150601f19603f3d011682016040523d82523d6000602084013e610184565b606091505b509150915061019482828661019f565b979650505050505050565b606083156101ae57508161004b565b8251156101be5782518084602001fd5b8160405162461bcd60e51b81526004016100c69190610224565b60005b838110156101f35781810151838201526020016101db565b83811115610202576000848401525b50505050565b6000825161021a8184602087016101d8565b9190910192915050565b60208152600082518060208401526102438160408501602087016101d8565b601f01601f1916919091016040019291505056fea26469706673582212200b524eb8ceaafe6c603273ee859fddbc2d6f1b7860c3d853dcf6f129f9d9371364736f6c634300080c0033").connect(t).deploy(e);return r}));await Promise.all(i.map(t=>t.deployed())),r?.notifier?.("deployed","infra")}async function so(t,e,r,a,i){let n=i&&i.contractName,s=i&&i.metadata;if((0,tH.Z)(n||s,"Require contract name or metadata"),n&&n2[n])return n2[n];if("WETH9"===n){let o=st(nH,[],a),c=await n8(o,e),l="";return c||(l=n9(nH,[])),{name:n,type:t,transaction:{predictedAddress:o,to:a,data:l}}}if(!s){(0,tH.Z)(n,"Require contract name");let d=await sd(n);s=(await sp(d,r)).compilerMetadata}let p=await sc(s,e,r,a,i?.constructorParams),f=st(s.bytecode,p,a),h=await n8(f,e),u="";return h||(u=n9(s.bytecode,p)),{name:n,type:t,transaction:{predictedAddress:f,to:a,data:u}}}async function sc(t,e,r,a,i){let n=nO(t.abi),s=n.map(t=>"tuple[]"===t.type?M._R.from(t):t.type),o=await Promise.all(n.map(async n=>{if(i&&i[n.name])return i[n.name].type&&(0,tH.Z)(i[n.name].type===n.type,`Provided type ${i[n.name].type} doesn't match the actual type ${n.type} from Abi`),i[n.name].value;if(n.name&&n.name.includes("nativeTokenWrapper")){let s=(await e.getNetwork()).chainId,o=eC(s).wrapped.address;if(o===C.d){let c=await so("infra",e,r,a,{contractName:"WETH9"});n2.WETH9||(n2.WETH9=c),o=c.transaction.predictedAddress}return o}if(n.name&&n.name.includes("trustedForwarder")){if(t.analytics?.contract_name&&"Pack"===t.analytics.contract_name){let l=await so("infra",e,r,a,{contractName:"ForwarderEOAOnly"});return n2.ForwarderEOAOnly||(n2.ForwarderEOAOnly=l),l.transaction.predictedAddress}let d=await so("infra",e,r,a,{contractName:"Forwarder"});return n2.Forwarder||(n2.Forwarder=d),d.transaction.predictedAddress}throw Error("Can't resolve constructor arguments")})),c=z.$.encode(s,o);return c}function sl(t,e){let r=v.joinSignature(nX),a=function(t,e){let r=v.arrayify(R.keccak256(L.serialize(t))),a=L.recoverAddress(r,e),i=L.serialize(t,e);return{signer:a,transaction:i}}({gasPrice:e||100*1e9,gasLimit:1e5,nonce:0,data:"0x604580600e600039806000f350fe7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf3",chainId:t},r),i=E.getContractAddress({from:a.signer,nonce:0});return{...a,deployment:i}}async function sd(t){if(n6[t])return n6[t];let e=await new oK("polygon").getPublisher().getVersion(nQ,t);if(!e)throw Error(`No published contract found for ${t} at version by '${nQ}'`);let r=e.metadataUri;return n6[t]=r,r}async function sp(t,e){let r;if(n5[t])return n5[t];let a=await nM(t,e);try{r=await nz(t,e)}catch(i){}let n={compilerMetadata:a,extendedMetadata:r};return n5[t]=n,n}function sf(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5e6;if(0===(t=t.filter(t=>t.data.length>0)).length)return[];let r=[],a=0,i=[];return t.forEach(t=>{var n;let s;let o=(n=t.data,s=Math.floor(64*(s=v.arrayify(n).map(t=>0===t?4:16).reduce((t,e)=>t+e)+200*n.length/2+6*Math.ceil(n.length/64)+32e3+21e3)/63));a+o>e?0===i.length?r.push([t]):(r.push(i),a=o,i=[t]):(a+=o,i.push(t))}),i.length>0&&r.push(i),r}async function sh(t,e,r,a,i){let n=[];try{let s=nV(cd.parse(e),"PluginRouter"),o=nV(cd.parse(e),"ExtensionRouter");if(o){let c=new ak(r,t,a4,a),l=await c.call("getAllExtensions"),d=l.map(t=>t.metadata.implementation);n=await su(d,r,i)}else if(s){let p=new ak(r,t,a3,a),f=await p.call("getAllPlugins"),h=f.map(t=>t.pluginAddress),u=Array.from(new Set(h));n=await su(u,r,i)}}catch(m){}return n.length>0?function(t){let e=t.map(t=>cd.parse(t)).flat(),r=function(t,e){if(0===t.length||1===t.length||!e)return t;for(let r=0;r<t.length;r++)for(let a=r+1;a<t.length;a++)e(t[r],t[a])&&t.splice(a,1);return t}(e,(t,e)=>t.name===e.name&&t.type===e.type&&t.inputs.length===e.inputs.length),a=r.filter(t=>"constructor"!==t.type);return cd.parse(a)}([e,...n]):e}async function su(t,e,r){return(await Promise.all(t.map(t=>o6(t,e,r).catch(e=>(console.error(`Failed to fetch plug-in for ${t}`,e),{abi:[]}))))).map(t=>t.abi)}async function sm(t,e){let r=[],{compilerMetadata:a,extendedMetadata:i}=await sp(t,e),n=nV(cd.parse(a.abi),"PluginRouter");if(n&&i&&i.factoryDeploymentData?.implementationAddresses){let s=Object.entries(i.factoryDeploymentData.implementationAddresses);try{let o=s.find(t=>{let[,e]=t;return""!==e}),[c,l]=o||[];if(c&&l){let d=rY(parseInt(c),{}),p=new ak(d,l,a3,{}),f=await p.call("getAllPlugins"),h=f.map(t=>t.pluginAddress),u=Array.from(new Set(h)),m=(await Promise.all(u.map(async t=>{let r=o6(t,d,e);return r}))).map(t=>t.name),g=await Promise.all(m.map(t=>sd(t)));r=(await Promise.all(g.map(async t=>sp(t,e)))).map(t=>t.compilerMetadata)}}catch{}}return r}class sg{constructor(t){(0,tR._)(this,"args",void 0),(0,tR._)(this,"overrides",void 0),(0,tR._)(this,"provider",void 0),(0,tR._)(this,"signer",void 0),(0,tR._)(this,"storage",void 0),(0,tR._)(this,"gasMultiple",void 0),this.args=t.args,this.overrides=t.overrides||{},this.provider=t.provider,this.signer=t.signer,this.storage=t.storage||new tq.EA,this.signer.provider||(this.signer=this.signer.connect(this.provider))}getArgs(){return this.args}getOverrides(){return this.overrides}getValue(){return this.overrides.value||0}setArgs(t){return this.args=t,this}setOverrides(t){return this.overrides=t,this}updateOverrides(t){return this.overrides={...this.overrides,...t},this}setValue(t){return this.updateOverrides({value:t}),this}setGasLimit(t){return this.updateOverrides({gasLimit:t}),this}setGasPrice(t){return this.updateOverrides({gasPrice:t}),this}setNonce(t){return this.updateOverrides({nonce:t}),this}setMaxFeePerGas(t){return this.updateOverrides({maxFeePerGas:t}),this}setMaxPriorityFeePerGas(t){return this.updateOverrides({maxPriorityFeePerGas:t}),this}setType(t){return this.updateOverrides({type:t}),this}setAccessList(t){return this.updateOverrides({accessList:t}),this}setCustomData(t){return this.updateOverrides({customData:t}),this}setCcipReadEnabled(t){return this.updateOverrides({ccipReadEnabled:t}),this}setGasLimitMultiple(t){T.O$.isBigNumber(this.overrides.gasLimit)?this.overrides.gasLimit=T.O$.from(Math.floor(T.O$.from(this.overrides.gasLimit).toNumber()*t)):this.gasMultiple=t}async estimateGasCost(){let t=await this.estimateGasLimit(),e=await this.getGasPrice(),r=t.mul(e);return{ether:B.formatEther(r),wei:r}}async getGasPrice(){let t=await this.provider.getGasPrice(),e=B.parseUnits("300","gwei"),r=t.div(100).mul(10),a=t.add(r);return a.gt(e)?e:a}async getSignerAddress(){return this.signer.getAddress()}async getGasOverrides(){return{}}getPreferredPriorityFee(t){let e=t.div(100).mul(10),r=t.add(e),a=B.parseUnits("300","gwei"),i=B.parseUnits("2.5","gwei");return r.gt(a)?a:r.lt(i)?i:r}}class sy extends sg{static fromContractWrapper(t){let e=t.contractWrapper.getSigner();if(!e)throw Error("Cannot create a transaction without a signer. Please ensure that you have a connected signer.");let r={...t,contract:t.contractWrapper.writeContract,provider:t.contractWrapper.getProvider(),signer:e,gasless:t.contractWrapper.options.gasless};return new sy(r)}static async fromContractInfo(t){let e=t.storage||new tq.EA,r=t.contractAbi;if(!r)try{let a=await o6(t.contractAddress,t.provider,e);r=a.abi}catch{throw Error(`Could resolve contract metadata for address ${t.contractAddress}. Please pass the contract ABI manually with the 'contractAbi' option.`)}let i=new F.CH(t.contractAddress,r,t.provider),n={...t,storage:e,contract:i};return new sy(n)}constructor(t){super({args:t.args,overrides:t.overrides,provider:t.provider,signer:t.signer,storage:t.storage}),(0,tR._)(this,"method",void 0),(0,tR._)(this,"contract",void 0),(0,tR._)(this,"gaslessOptions",void 0),(0,tR._)(this,"parse",void 0),this.method=t.method,this.gaslessOptions=t.gasless,this.parse=t.parse,this.contract=t.contract.connect(this.signer),this.storage=t.storage||new tq.EA}getMethod(){return this.method}getGaslessOptions(){return this.gaslessOptions}setGaslessOptions(t){return this.gaslessOptions=t,this}setParse(t){return this.parse=t,this}encode(){return this.contract.interface.encodeFunctionData(this.method,this.args)}async sign(){let t=await this.getGasOverrides(),e={...t,...this.overrides};e.gasLimit||(e.gasLimit=await this.estimateGasLimit());let r=await this.contract.populateTransaction[this.method](...this.args,e),a=await this.contract.signer.populateTransaction(r),i=await this.contract.signer.signTransaction(a);return i}async simulate(){if(!this.contract.callStatic[this.method])throw this.functionError();try{return await this.contract.callStatic[this.method](...this.args,...this.overrides.value?[{value:this.overrides.value}]:[])}catch(t){throw await this.transactionError(t)}}async estimateGasLimit(){if(!this.contract.estimateGas[this.method])throw this.functionError();try{let t=await this.contract.estimateGas[this.method](...this.args,this.overrides);if(this.gasMultiple)return T.O$.from(Math.floor(T.O$.from(t).toNumber()*this.gasMultiple));return t}catch(e){throw await this.simulate(),await this.transactionError(e)}}async send(){if(!this.contract.functions[this.method])throw this.functionError();if(this.gaslessOptions&&("openzeppelin"in this.gaslessOptions||"biconomy"in this.gaslessOptions))return this.sendGasless();let t=await this.getGasOverrides(),e={...t,...this.overrides};if(!e.gasLimit){e.gasLimit=await this.estimateGasLimit();try{let r=JSON.parse(this.contract.interface.format(t$.FormatTypes.json));(function(t){let e=nV(cd.parse(t),"PluginRouter"),r=nV(cd.parse(t),"ExtensionRouter");return r||e})(r)&&(e.gasLimit=e.gasLimit.mul(110).div(100))}catch(a){console.warn("Error raising gas limit",a)}}try{return await this.contract.functions[this.method](...this.args,e)}catch(i){throw await this.transactionError(i)}}async execute(){let t;let e=await this.send();try{t=await e.wait()}catch(r){throw await this.simulate(),await this.transactionError(r)}return this.parse?this.parse(t):{receipt:t}}async sendGasless(){let t;(0,tH.Z)(this.gaslessOptions&&("openzeppelin"in this.gaslessOptions||"biconomy"in this.gaslessOptions),"No gasless options set on this transaction!");let e=[...this.args];if("multicall"===this.method&&Array.isArray(this.args[0])&&e[0].length>0){let r=await this.getSignerAddress();e[0]=e[0].map(t=>I.pack(["bytes","address"],[t,r]))}(0,tH.Z)(this.signer,"Cannot execute gasless transaction without valid signer");let a=(await this.provider.getNetwork()).chainId,i=await (this.overrides.from||this.getSignerAddress()),n=this.contract.address,s=this.overrides?.value||0;if(T.O$.from(s).gt(0))throw Error("Cannot send native token value with gasless transaction");let o=this.contract.interface.encodeFunctionData(this.method,e),c=T.O$.from(0);try{let l=await this.contract.estimateGas[this.method](...e);c=l.mul(2)}catch(d){}c.lt(1e5)&&(c=T.O$.from(5e5)),this.overrides.gasLimit&&T.O$.from(this.overrides.gasLimit).gt(c)&&(c=T.O$.from(this.overrides.gasLimit));let p={from:i,to:n,data:o,chainId:a,gasLimit:c,functionName:this.method,functionArgs:e,callOverrides:this.overrides},f=await a5(p,this.signer,this.provider,this.gaslessOptions),h=1;for(;!t;)if(!(t=await this.provider.getTransaction(f))&&(await new Promise(t=>setTimeout(t,Math.min(1e3*h,1e4))),h++),h>20)throw Error(`Unable to retrieve transaction with hash ${f}`);return t}functionError(){return Error(`Contract "${this.contract.address}" does not have function "${this.method}"`)}async transactionError(t){let e,r;let a=this.provider,i=await a.getNetwork(),n=await (this.overrides.from||this.getSignerAddress()),s=this.contract.address,o=this.encode(),c=T.O$.from(this.overrides.value||0),l=a.connection?.url,d=this.contract.interface.getFunction(this.method),p=this.args.map(t=>JSON.stringify(t).length<=80?JSON.stringify(t):JSON.stringify(t,void 0,2)),f=p.join(", ").length<=80?p.join(", "):"\n"+p.map(t=>"  "+t.split("\n").join("\n  ")).join(",\n")+"\n",h=`${d.name}(${f})`,u=t.transactionHash||t.transaction?.hash||t.receipt?.transactionHash,m=ae(t);try{let g=await o6(this.contract.address,this.provider,this.storage);g.name&&(r=g.name),g.metadata.sources&&(e=await o4(g,this.storage))}catch(y){}return new at({reason:m,from:n,to:s,method:h,data:o,network:i,rpcUrl:l,value:c,hash:u,contractName:r,sources:e})}}class sw extends sg{constructor(t){super(t),(0,tR._)(this,"factory",void 0),(0,tR._)(this,"events",void 0),this.factory=t.factory,this.events=t.events}encode(){return v.hexlify(v.concat([this.factory.bytecode,this.factory.interface.encodeDeploy(this.args)]))}async sign(){let t=await this.populateTransaction();return this.signer.signTransaction(t)}async simulate(){let t=await this.populateTransaction();this.signer.call(t)}async estimateGasLimit(){try{let t=await this.getGasOverrides(),e={...t,...this.overrides},r=this.factory.getDeployTransaction(...this.args,e);return this.signer.estimateGas(r)}catch(a){throw await this.deployError(a)}}async send(){try{let t=await this.populateTransaction();return await this.signer.sendTransaction(t)}catch(e){throw await this.deployError(e)}}async execute(){let t=await this.send();try{await t.wait()}catch(e){throw await this.simulate(),await this.deployError(e)}let r=E.getContractAddress({from:t.from,nonce:t.nonce});return this.events&&this.events.emit("contractDeployed",{status:"completed",contractAddress:r,transactionHash:t.hash}),r}async populateTransaction(){let t=await this.getGasOverrides(),e={...t,...this.overrides};return e.gasLimit||(e.gasLimit=await this.estimateGasLimit()),this.factory.getDeployTransaction(...this.args,e)}async deployError(t){let e=this.provider,r=await e.getNetwork(),a=await (this.overrides.from||this.getSignerAddress()),i=this.encode(),n=T.O$.from(this.overrides.value||0),s=e.connection?.url,o=this.args.map(t=>JSON.stringify(t).length<=80?JSON.stringify(t):JSON.stringify(t,void 0,2)),c=o.join(", ").length<=80?o.join(", "):"\n"+o.map(t=>"  "+t.split("\n").join("\n  ")).join(",\n")+"\n",l=`deployContract(${c})`,d=t.transactionHash||t.transaction?.hash||t.receipt?.transactionHash,p=ae(t);return new at({reason:p,from:a,method:l,data:i,network:r,rpcUrl:s,value:n,hash:d})}}class sb{constructor(t,e,r){(0,tR._)(this,"featureName",ia.name),(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"schema",void 0),(0,tR._)(this,"storage",void 0),(0,tR._)(this,"set",a2(async t=>{let e=await this._parseAndUploadMetadata(t),r=this.contractWrapper;if(this.supportsContractMetadata(r))return sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setContractURI",args:[e],parse:t=>({receipt:t,data:this.get})});throw new r4(ia)})),(0,tR._)(this,"update",a2(async t=>await this.set.prepare({...await this.get(),...t}))),this.contractWrapper=t,this.schema=e,this.storage=r}parseOutputMetadata(t){return this.schema.output.parseAsync(t)}parseInputMetadata(t){return this.schema.input.parseAsync(t)}async get(){let t;if(this.supportsContractMetadata(this.contractWrapper)){let e=await this.contractWrapper.readContract.contractURI();e&&e.includes("://")&&(t=await this.storage.downloadJSON(e))}if(!t)try{let r,a,i;try{nG("name",this.contractWrapper)&&(r=await this.contractWrapper.readContract.name())}catch(n){}try{nG("symbol",this.contractWrapper)&&(a=await this.contractWrapper.readContract.symbol())}catch(s){}try{i=await o6(this.contractWrapper.readContract.address,this.contractWrapper.getProvider(),this.storage)}catch(o){}t={name:r||i?.name,symbol:a,description:i?.info.title}}catch(c){throw Error("Could not fetch contract metadata")}return this.parseOutputMetadata(t)}async _parseAndUploadMetadata(t){let e=await this.parseInputMetadata(t);return this.storage.upload(e)}supportsContractMetadata(t){return nj(t,"ContractMetadata")}}class sC{constructor(t,e){(0,tR._)(this,"featureName",ir.name),(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"roles",void 0),(0,tR._)(this,"setAll",a2(async t=>{let e=Object.keys(t);(0,tH.Z)(e.length,"you must provide at least one role to set"),(0,tH.Z)(e.every(t=>this.roles.includes(t)),"this contract does not support the given role");let r=await this.getAll(),a=[],i=e.sort(t=>"admin"===t?1:-1);for(let n=0;n<i.length;n++){let s=i[n],o=await Promise.all(t[s]?.map(async t=>await ex(t))||[]),c=await Promise.all(r[s]?.map(async t=>await ex(t))||[]),l=o.filter(t=>!c.includes(t)),d=c.filter(t=>!o.includes(t));if(l.length&&l.forEach(t=>{a.push(this.contractWrapper.readContract.interface.encodeFunctionData("grantRole",[aX(s),t]))}),d.length)for(let p=0;p<d.length;p++){let f=d[p],h=await this.getRevokeRoleFunctionName(f);a.push(this.contractWrapper.readContract.interface.encodeFunctionData(h,[aX(s),f]))}}return sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[a]})})),(0,tR._)(this,"grant",a2(async(t,e)=>{(0,tH.Z)(this.roles.includes(t),`this contract does not support the "${t}" role`);let r=await ex(e);return sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"grantRole",args:[aX(t),r]})})),(0,tR._)(this,"revoke",a2(async(t,e)=>{(0,tH.Z)(this.roles.includes(t),`this contract does not support the "${t}" role`);let r=await ex(e),a=await this.getRevokeRoleFunctionName(r);return sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:a,args:[aX(t),r]})})),this.contractWrapper=t,this.roles=e}async getAll(){(0,tH.Z)(this.roles.length,"this contract has no support for roles");let t={};for(let e of this.roles)t[e]=await this.get(e);return t}async get(t){(0,tH.Z)(this.roles.includes(t),`this contract does not support the "${t}" role`);let e=this.contractWrapper;if(nG("getRoleMemberCount",e)&&nG("getRoleMember",e)){let r=aX(t),a=(await e.readContract.getRoleMemberCount(r)).toNumber();return await Promise.all(Array.from(Array(a).keys()).map(t=>e.readContract.getRoleMember(r,t)))}throw Error("Contract does not support enumerating roles. Please implement IPermissionsEnumerable to unlock this functionality.")}async verify(t,e){await Promise.all(t.map(async t=>{let r=await this.get(t),a=await ex(e);if(!r.map(t=>t.toLowerCase()).includes(a.toLowerCase()))throw new r1(a,t)}))}async getRevokeRoleFunctionName(t){let e=await ex(t),r=await this.contractWrapper.getSignerAddress();return r.toLowerCase()===e.toLowerCase()?"renounceRole":"revokeRole"}}class sv{constructor(t,e){(0,tR._)(this,"featureName",a7.name),(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"metadata",void 0),(0,tR._)(this,"setDefaultRoyaltyInfo",a2(async t=>{let e=await this.metadata.get(),r=await this.metadata.parseInputMetadata({...e,...t}),a=await this.metadata._parseAndUploadMetadata(r);if(nG("setContractURI",this.contractWrapper)){let i=[this.contractWrapper.readContract.interface.encodeFunctionData("setDefaultRoyaltyInfo",[r.fee_recipient,r.seller_fee_basis_points]),this.contractWrapper.readContract.interface.encodeFunctionData("setContractURI",[a])];return sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[i],parse:t=>({receipt:t,data:()=>this.getDefaultRoyaltyInfo()})})}throw Error("Updating royalties requires implementing ContractMetadata in your contract to support marketplaces like OpenSea.")})),(0,tR._)(this,"setTokenRoyaltyInfo",a2(async(t,e)=>{let r=ro.parse(e);return sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setRoyaltyInfoForToken",args:[t,r.fee_recipient,r.seller_fee_basis_points],parse:t=>({receipt:t,data:()=>this.getDefaultRoyaltyInfo()})})})),this.contractWrapper=t,this.metadata=e}async getDefaultRoyaltyInfo(){let[t,e]=await this.contractWrapper.readContract.getDefaultRoyaltyInfo();return ro.parseAsync({fee_recipient:t,seller_fee_basis_points:e})}async getTokenRoyaltyInfo(t){let[e,r]=await this.contractWrapper.readContract.getRoyaltyInfoForToken(t);return ro.parseAsync({fee_recipient:e,seller_fee_basis_points:r})}}class sW{constructor(t){(0,tR._)(this,"featureName",a9.name),(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"setRecipient",a2(async t=>sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setPrimarySaleRecipient",args:[t]}))),this.contractWrapper=t}async getRecipient(){return await this.contractWrapper.readContract.primarySaleRecipient()}}let sA={name:"Failed to load NFT metadata"};async function sk(t,e,r){let a;let i=e.replace("{id}",v.hexZeroPad(T.O$.from(t).toHexString(),32).slice(2));try{a=await r.downloadJSON(i)}catch(o){let n=e.replace("{id}",T.O$.from(t).toString());try{a=await r.downloadJSON(n)}catch(s){console.warn(`failed to get token metadata: ${JSON.stringify({tokenId:t.toString(),tokenUri:e})} -- falling back to default metadata`),a=sA}}return tR.C.parse({...a,id:T.O$.from(t).toString(),uri:e})}async function sE(t,e,r,a){let i;let n=new F.CH(t,tX,e),s=await n.supportsInterface(eg),o=await n.supportsInterface(ey);if(s){let c=new F.CH(t,t0,e);i=await c.tokenURI(r)}else if(o){let l=new F.CH(t,t1,e);i=await l.uri(r)}else throw Error("Contract must implement ERC 1155 or ERC 721.");return i?sk(r,i,a):tR.C.parse({...sA,id:T.O$.from(r).toString(),uri:""})}async function sT(t,e){return"string"==typeof t?t:await e.upload(tR.b.parse(t))}async function sS(t,e,r,a){if(void 0===t.find(t=>"string"!=typeof t))return t;if(void 0===t.find(t=>"object"!=typeof t)){let i=await e.uploadBatch(t.map(t=>tR.b.parse(t)),{rewriteFileNames:{fileStartNumber:r||0},onProgress:a?.onProgress});return i}throw Error("NFT metadatas must all be of the same type (all URI or all NFTMetadataInput)")}function s_(t){let e=t[0].substring(0,t[0].lastIndexOf("/"));for(let r=0;r<t.length;r++){let a=t[r].substring(0,t[r].lastIndexOf("/"));if(e!==a)throw Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${e}' but got '${a}'`)}return e.replace(/\/$/,"")+"/"}class sP{constructor(t,e,r,a){(0,tR._)(this,"featureName",void 0),(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"storage",void 0),(0,tR._)(this,"nextTokenIdToMintFn",void 0),(0,tR._)(this,"createDelayedRevealBatch",a2(async(t,e,r,a)=>{let i;if(!r)throw Error("Password is required");let n=await this.storage.uploadBatch([tR.b.parse(t)],{rewriteFileNames:{fileStartNumber:0}}),s=s_(n),o=await this.nextTokenIdToMintFn(),c=await this.storage.uploadBatch(e.map(t=>tR.b.parse(t)),{onProgress:a?.onProgress,rewriteFileNames:{fileStartNumber:o.toNumber()}}),l=s_(c),d=await this.contractWrapper.readContract.getBaseURICount(),p=await this.hashDelayRevealPassword(d,r),f=await this.contractWrapper.readContract.encryptDecrypt(S.Y0(l),p),h=await this.isLegacyContract();if(h)i=f;else{let u=await this.contractWrapper.getChainID(),m=I.keccak256(["bytes","bytes","uint256"],[S.Y0(l),p,u]);i=z.$.encode(["bytes","bytes32"],[f,m])}return sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[c.length,s.endsWith("/")?s:`${s}/`,i],parse:t=>{let e=this.contractWrapper.parseLogs("TokensLazyMinted",t?.logs),r=e[0].args.startTokenId,a=e[0].args.endTokenId,i=[];for(let n=r;n.lte(a);n=n.add(1))i.push({id:n,receipt:t});return i}})})),(0,tR._)(this,"reveal",a2(async(t,e)=>{if(!e)throw Error("Password is required");let r=await this.hashDelayRevealPassword(t,e);try{let a=await this.contractWrapper.callStatic().reveal(t,r);if(!a.includes("://")||!a.endsWith("/"))throw Error("invalid password")}catch(i){throw Error("invalid password")}return sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"reveal",args:[t,r]})})),this.featureName=r,this.nextTokenIdToMintFn=a,this.contractWrapper=t,this.storage=e}async getBatchesToReveal(){let t=await this.contractWrapper.readContract.getBaseURICount();if(t.isZero())return[];let e=Array.from(Array(t.toNumber()).keys()),r=await Promise.all(e.map(t=>{if(nG("getBatchIdAtIndex",this.contractWrapper))return this.contractWrapper.readContract.getBatchIdAtIndex(t);if(nG("baseURIIndices",this.contractWrapper))return this.contractWrapper.readContract.baseURIIndices(t);throw Error("Contract does not have getBatchIdAtIndex or baseURIIndices.")})),a=r.slice(0,r.length-1),i=await Promise.all(Array.from([0,...a]).map(t=>this.getNftMetadata(t.toString()))),n=await this.isLegacyContract(),s=await Promise.all(Array.from([...r]).map(t=>n?this.getLegacyEncryptedData(t):this.contractWrapper.readContract.encryptedData(t))),o=s.map(t=>{if(!(v.hexDataLength(t)>0))return t;{if(n)return t;let e=z.$.decode(["bytes","bytes32"],t);return e[0]}});return i.map((t,e)=>({batchId:T.O$.from(e),batchUri:t.uri,placeholderMetadata:t})).filter((t,e)=>v.hexDataLength(o[e])>0)}async hashDelayRevealPassword(t,e){let r=await this.contractWrapper.getChainID(),a=this.contractWrapper.readContract.address;return I.keccak256(["string","uint256","uint256","address"],[e,r,t,a])}async getNftMetadata(t){return sE(this.contractWrapper.readContract.address,this.contractWrapper.getProvider(),t,this.storage)}async isLegacyContract(){if(nG("contractVersion",this.contractWrapper))try{let t=await this.contractWrapper.readContract.contractVersion();return t<=2}catch(e){}return!1}async getLegacyEncryptedData(t){let e=new F.CH(this.contractWrapper.readContract.address,t2,this.contractWrapper.getProvider()),r=await e.functions.encryptedBaseURI(t);return r.length>0?r[0]:"0x"}}let sx=((y={})[y.UNSET=0]="UNSET",y[y.Created=1]="Created",y[y.Completed=2]="Completed",y[y.Cancelled=3]="Cancelled",y[y.Active=4]="Active",y[y.Expired=5]="Expired",y),sB=((w={}).NotEnoughSupply="There is not enough supply to claim.",w.AddressNotAllowed="This address is not on the allowlist.",w.WaitBeforeNextClaimTransaction="Not enough time since last claim transaction. Please wait.",w.AlreadyClaimed="You have already claimed the token.",w.NotEnoughTokens="There are not enough tokens in the wallet to pay for the claim.",w.NoActiveClaimPhase="There is no active claim phase at the moment. Please check back in later.",w.NoClaimConditionSet="There is no claim condition set.",w.NoWallet="No wallet connected.",w.Unknown="No claim conditions found.",w);class sD{constructor(t,e,r){var a=this;(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"metadata",void 0),(0,tR._)(this,"storage",void 0),(0,tR._)(this,"set",a2(async function(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],r=t;if(a.isLegacySinglePhaseDrop(a.contractWrapper)||a.isNewSinglePhaseDrop(a.contractWrapper)){if(e=!0,0===t.length)r=[{startTime:new Date(0),currencyAddress:C.d,price:0,maxClaimableSupply:0,maxClaimablePerWallet:0,waitInSeconds:0,merkleRootHash:v.hexZeroPad([0],32),snapshot:[]}];else if(t.length>1)throw Error("Single phase drop contract cannot have multiple claim conditions, only one is allowed")}(a.isNewSinglePhaseDrop(a.contractWrapper)||a.isNewMultiphaseDrop(a.contractWrapper))&&r.forEach(t=>{if(t.snapshot&&t.snapshot.length>0&&(void 0===t.maxClaimablePerWallet||"unlimited"===t.maxClaimablePerWallet))throw Error("maxClaimablePerWallet must be set to a specific value when an allowlist is set.\nExample: Set it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist.\ncontract.claimConditions.set([{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])");if(t.snapshot&&t.snapshot.length>0&&"0"===t.maxClaimablePerWallet?.toString()&&0===t.snapshot.map(t=>"string"==typeof t?0:Number(t.maxClaimable?.toString()||0)).reduce((t,e)=>t+e,0))throw Error("maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim.")});let{snapshotInfos:i,sortedConditions:n}=await aL(r,await a.getTokenDecimals(),a.contractWrapper.getProvider(),a.storage,a.getSnapshotFormatVersion()),s={};i.forEach(t=>{s[t.merkleRoot]=t.snapshotUri});let o=await a.metadata.get(),c=[];if(!tK()(o.merkle,s)){let l=await a.metadata.parseInputMetadata({...o,merkle:s}),d=await a.metadata._parseAndUploadMetadata(l);if(nG("setContractURI",a.contractWrapper))c.push(a.contractWrapper.readContract.interface.encodeFunctionData("setContractURI",[d]));else throw Error("Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.")}let p=a.contractWrapper;if(a.isLegacySinglePhaseDrop(p))c.push(p.readContract.interface.encodeFunctionData("setClaimConditions",[az(n[0]),e]));else if(a.isLegacyMultiPhaseDrop(p))c.push(p.readContract.interface.encodeFunctionData("setClaimConditions",[n.map(az),e]));else if(a.isNewSinglePhaseDrop(p))c.push(p.readContract.interface.encodeFunctionData("setClaimConditions",[a$(n[0]),e]));else if(a.isNewMultiphaseDrop(p))c.push(p.readContract.interface.encodeFunctionData("setClaimConditions",[n.map(a$),e]));else throw Error("Contract does not support claim conditions");return sy.fromContractWrapper({contractWrapper:a.contractWrapper,method:"multicall",args:[c]})})),(0,tR._)(this,"update",a2(async(t,e)=>{let r=await this.getAll(),a=await aR(t,e,r);return await this.set.prepare(a)})),this.storage=r,this.contractWrapper=t,this.metadata=e}async getActive(t){let e=await this.get(),r=await this.metadata.get();return await aq(e,await this.getTokenDecimals(),this.contractWrapper.getProvider(),r.merkle||{},this.storage,t?.withAllowList||!1)}async get(t){if(this.isLegacySinglePhaseDrop(this.contractWrapper)){let e=await this.contractWrapper.readContract.claimCondition();return aU(e)}if(this.isLegacyMultiPhaseDrop(this.contractWrapper)){let r=void 0!==t?t:await this.contractWrapper.readContract.getActiveClaimConditionId(),a=await this.contractWrapper.readContract.getClaimConditionById(r);return aU(a)}if(this.isNewSinglePhaseDrop(this.contractWrapper)){let i=await this.contractWrapper.readContract.claimCondition();return aV(i)}if(this.isNewMultiphaseDrop(this.contractWrapper)){let n=void 0!==t?t:await this.contractWrapper.readContract.getActiveClaimConditionId(),s=await this.contractWrapper.readContract.getClaimConditionById(n);return aV(s)}throw Error("Contract does not support claim conditions")}async getAll(t){if(!(this.isLegacyMultiPhaseDrop(this.contractWrapper)||this.isNewMultiphaseDrop(this.contractWrapper)))return[await this.getActive(t)];{let e=await this.contractWrapper.readContract.claimCondition(),r=e.currentStartId.toNumber(),a=e.count.toNumber(),i=[];for(let n=r;n<r+a;n++)i.push(await this.get(n));let s=await this.metadata.get(),o=await this.getTokenDecimals();return Promise.all(i.map(e=>aq(e,o,this.contractWrapper.getProvider(),s.merkle,this.storage,t?.withAllowList||!1)))}}async canClaim(t,e){return e&&(e=await ex(e)),0===(await this.getClaimIneligibilityReasons(t,e)).length}async getClaimIneligibilityReasons(t,e){let r,a;let i=[],n=await this.getTokenDecimals(),s=B.parseUnits(tR.A.parse(t),n);if(void 0===e)try{e=await this.contractWrapper.getSignerAddress()}catch(o){console.warn("failed to get signer address",o)}if(!e)return[sB.NoWallet];let c=await ex(e);try{a=await this.getActive()}catch(l){if(ai(l,"!CONDITION")||ai(l,"no active mint condition"))return i.push(sB.NoClaimConditionSet),i;return console.warn("failed to get active claim condition",l),i.push(sB.Unknown),i}if("unlimited"!==a.availableSupply){let d=B.parseUnits(a.availableSupply,n);d.lt(s)&&i.push(sB.NotEnoughSupply)}let p=v.stripZeros(a.merkleRootHash),f=p.length>0,h=null;if(f){if(!(h=await this.getClaimerProofs(c))&&(this.isLegacySinglePhaseDrop(this.contractWrapper)||this.isLegacyMultiPhaseDrop(this.contractWrapper)))return i.push(sB.AddressNotAllowed),i;if(h)try{let u;let m=await this.prepareClaim(t,!1,n,c);if(this.isLegacyMultiPhaseDrop(this.contractWrapper)){if(r=await this.contractWrapper.readContract.getActiveClaimConditionId(),[u]=await this.contractWrapper.readContract.verifyClaimMerkleProof(r,c,t,m.proofs,m.maxClaimable),!u)return i.push(sB.AddressNotAllowed),i}else if(this.isLegacySinglePhaseDrop(this.contractWrapper)){if([u]=await this.contractWrapper.readContract.verifyClaimMerkleProof(c,t,{proof:m.proofs,maxQuantityInAllowlist:m.maxClaimable}),!u)return i.push(sB.AddressNotAllowed),i}else if(this.isNewSinglePhaseDrop(this.contractWrapper)){if(await this.contractWrapper.readContract.verifyClaim(c,t,m.currencyAddress,m.price,{proof:m.proofs,quantityLimitPerWallet:m.maxClaimable,currency:m.currencyAddressInProof,pricePerToken:m.priceInProof}),aG(a.maxClaimablePerWallet,n).eq(0)&&m.maxClaimable===O.Bz||m.maxClaimable===T.O$.from(0))return i.push(sB.AddressNotAllowed),i}else if(this.isNewMultiphaseDrop(this.contractWrapper)&&(await this.contractWrapper.readContract.verifyClaim(r=await this.contractWrapper.readContract.getActiveClaimConditionId(),c,t,m.currencyAddress,m.price,{proof:m.proofs,quantityLimitPerWallet:m.maxClaimable,currency:m.currencyAddressInProof,pricePerToken:m.priceInProof}),aG(a.maxClaimablePerWallet,n).eq(0)&&m.maxClaimable===O.Bz||m.maxClaimable===T.O$.from(0)))return i.push(sB.AddressNotAllowed),i}catch(g){return console.warn("Merkle proof verification failed:","reason"in g?g.reason:g),i.push(sB.AddressNotAllowed),i}}if(this.isNewSinglePhaseDrop(this.contractWrapper)||this.isNewMultiphaseDrop(this.contractWrapper)){let y=await this.getClaimerProofs(c),w=T.O$.from(0),b=aG(a.maxClaimablePerWallet,n);if(this.isNewSinglePhaseDrop(this.contractWrapper)&&(w=await this.contractWrapper.readContract.getSupplyClaimedByWallet(c)),this.isNewMultiphaseDrop(this.contractWrapper)){let C=await this.contractWrapper.readContract.getActiveClaimConditionId();w=await this.contractWrapper.readContract.getSupplyClaimedByWallet(C,c)}if(y&&(b=aG(y.maxClaimable,n)),(!f||f&&!h)&&(b.lte(w)||b.eq(0)))return i.push(sB.AddressNotAllowed),i}if(this.isLegacySinglePhaseDrop(this.contractWrapper)||this.isLegacyMultiPhaseDrop(this.contractWrapper)){let[W,A]=[T.O$.from(0),T.O$.from(0)];this.isLegacyMultiPhaseDrop(this.contractWrapper)?(r=await this.contractWrapper.readContract.getActiveClaimConditionId(),[W,A]=await this.contractWrapper.readContract.getClaimTimestamp(r,c)):this.isLegacySinglePhaseDrop(this.contractWrapper)&&([W,A]=await this.contractWrapper.readContract.getClaimTimestamp(c));let k=T.O$.from(Date.now()).div(1e3);W.gt(0)&&k.lt(A)&&(A.eq(O.Bz)?i.push(sB.AlreadyClaimed):i.push(sB.WaitBeforeNextClaimTransaction))}if(a.price.gt(0)&&av()){let E=a.price.mul(T.O$.from(t)),S=this.contractWrapper.getProvider();if(aE(a.currencyAddress)){let _=await S.getBalance(c);_.lt(E)&&i.push(sB.NotEnoughTokens)}else{let P=new ak(S,a.currencyAddress,Y,{}),x=await P.readContract.balanceOf(c);x.lt(E)&&i.push(sB.NotEnoughTokens)}}return i}async getClaimerProofs(t,e){let r=await this.get(e),a=r.merkleRoot,i=v.stripZeros(a);if(!(i.length>0))return null;{let n=await this.metadata.get(),s=await ex(t);return await aI(s,a.toString(),n.merkle,this.contractWrapper.getProvider(),this.storage,this.getSnapshotFormatVersion())}}async getTokenDecimals(){return nj(this.contractWrapper,"ERC20")?this.contractWrapper.readContract.decimals():Promise.resolve(0)}async prepareClaim(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3?arguments[3]:void 0,i=a||await this.contractWrapper.getSignerAddress();return aF(i,t,await this.getActive(),async()=>(await this.metadata.get()).merkle,r,this.contractWrapper,this.storage,e,this.getSnapshotFormatVersion())}async getClaimArguments(t,e,r){let a=await ex(t);return this.isLegacyMultiPhaseDrop(this.contractWrapper)?[a,e,r.currencyAddress,r.price,r.proofs,r.maxClaimable]:this.isLegacySinglePhaseDrop(this.contractWrapper)?[a,e,r.currencyAddress,r.price,{proof:r.proofs,maxQuantityInAllowlist:r.maxClaimable},S.Y0("")]:[a,e,r.currencyAddress,r.price,{proof:r.proofs,quantityLimitPerWallet:r.maxClaimable,pricePerToken:r.priceInProof,currency:r.currencyAddressInProof},S.Y0("")]}async getClaimTransaction(t,e,r){if(r?.pricePerToken)throw Error("Price per token is be set via claim conditions by calling `contract.erc721.claimConditions.set()`");let a=await this.prepareClaim(e,r?.checkERC20Allowance===void 0||r.checkERC20Allowance,await this.getTokenDecimals());return sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"claim",args:await this.getClaimArguments(t,e,a),overrides:a.overrides})}isNewSinglePhaseDrop(t){return nj(t,"ERC721ClaimConditionsV2")||nj(t,"ERC20ClaimConditionsV2")}isNewMultiphaseDrop(t){return nj(t,"ERC721ClaimPhasesV2")||nj(t,"ERC20ClaimPhasesV2")}isLegacySinglePhaseDrop(t){return nj(t,"ERC721ClaimConditionsV1")||nj(t,"ERC20ClaimConditionsV1")}isLegacyMultiPhaseDrop(t){return nj(t,"ERC721ClaimPhasesV1")||nj(t,"ERC20ClaimPhasesV1")}getSnapshotFormatVersion(){return this.isLegacyMultiPhaseDrop(this.contractWrapper)||this.isLegacySinglePhaseDrop(this.contractWrapper)?aZ.V1:aZ.V2}}class sF{constructor(t,e,r){var a=this;(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"metadata",void 0),(0,tR._)(this,"storage",void 0),(0,tR._)(this,"set",a2(async function(t,e){let r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return a.setBatch.prepare([{tokenId:t,claimConditions:e}],r)})),(0,tR._)(this,"setBatch",a2(async function(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],r={},i=await Promise.all(t.map(async t=>{let{tokenId:i,claimConditions:n}=t,s=n;if(a.isLegacySinglePhaseDrop(a.contractWrapper)){if(e=!0,0===n.length)s=[{startTime:new Date(0),currencyAddress:C.d,price:0,maxClaimableSupply:0,maxClaimablePerWallet:0,waitInSeconds:0,merkleRootHash:v.hexZeroPad([0],32),snapshot:[]}];else if(n.length>1)throw Error("Single phase drop contract cannot have multiple claim conditions, only one is allowed")}(a.isNewSinglePhaseDrop(a.contractWrapper)||a.isNewMultiphaseDrop(a.contractWrapper))&&s.forEach(t=>{if(t.snapshot&&t.snapshot.length>0&&(void 0===t.maxClaimablePerWallet||"unlimited"===t.maxClaimablePerWallet))throw Error("maxClaimablePerWallet must be set to a specific value when an allowlist is set.\nSet it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist.\n\nex:\ncontract.claimConditions.set(tokenId, [{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])");if(t.snapshot&&t.snapshot.length>0&&"0"===t.maxClaimablePerWallet?.toString()&&0===t.snapshot.map(t=>"string"==typeof t?0:Number(t.maxClaimable?.toString()||0)).reduce((t,e)=>t+e,0))throw Error("maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim.")});let{snapshotInfos:o,sortedConditions:c}=await aL(s,0,a.contractWrapper.getProvider(),a.storage,a.getSnapshotFormatVersion());return o.forEach(t=>{r[t.merkleRoot]=t.snapshotUri}),{tokenId:i,sortedConditions:c}})),n=await a.metadata.get(),s=[];for(let o of Object.keys(n.merkle||{}))r[o]=n.merkle[o];if(!tK()(n.merkle,r)){let c=await a.metadata.parseInputMetadata({...n,merkle:r}),l=await a.metadata._parseAndUploadMetadata(c);if(nG("setContractURI",a.contractWrapper))s.push(a.contractWrapper.readContract.interface.encodeFunctionData("setContractURI",[l]));else throw Error("Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.")}return i.forEach(t=>{let{tokenId:r,sortedConditions:i}=t;if(a.isLegacySinglePhaseDrop(a.contractWrapper))s.push(a.contractWrapper.readContract.interface.encodeFunctionData("setClaimConditions",[r,az(i[0]),e]));else if(a.isLegacyMultiPhaseDrop(a.contractWrapper))s.push(a.contractWrapper.readContract.interface.encodeFunctionData("setClaimConditions",[r,i.map(az),e]));else if(a.isNewSinglePhaseDrop(a.contractWrapper))s.push(a.contractWrapper.readContract.interface.encodeFunctionData("setClaimConditions",[r,a$(i[0]),e]));else if(a.isNewMultiphaseDrop(a.contractWrapper))s.push(a.contractWrapper.readContract.interface.encodeFunctionData("setClaimConditions",[r,i.map(a$),e]));else throw Error("Contract does not support claim conditions")}),sy.fromContractWrapper({contractWrapper:a.contractWrapper,method:"multicall",args:[s]})})),(0,tR._)(this,"update",a2(async(t,e,r)=>{let a=await this.getAll(t),i=await aR(e,r,a);return await this.set.prepare(t,i)})),this.storage=r,this.contractWrapper=t,this.metadata=e}async getActive(t,e){let r=await this.get(t),a=await this.metadata.get();return await aq(r,0,this.contractWrapper.getProvider(),a.merkle,this.storage,e?.withAllowList||!1)}async get(t,e){if(this.isLegacySinglePhaseDrop(this.contractWrapper)){let r=await this.contractWrapper.readContract.claimCondition(t);return aU(r)}if(this.isLegacyMultiPhaseDrop(this.contractWrapper)){let a=void 0!==e?e:await this.contractWrapper.readContract.getActiveClaimConditionId(t),i=await this.contractWrapper.readContract.getClaimConditionById(t,a);return aU(i)}if(this.isNewSinglePhaseDrop(this.contractWrapper)){let n=await this.contractWrapper.readContract.claimCondition(t);return aV(n)}if(this.isNewMultiphaseDrop(this.contractWrapper)){let s=void 0!==e?e:await this.contractWrapper.readContract.getActiveClaimConditionId(t),o=await this.contractWrapper.readContract.getClaimConditionById(t,s);return aV(o)}throw Error("Contract does not support claim conditions")}async getAll(t,e){if(!(this.isLegacyMultiPhaseDrop(this.contractWrapper)||this.isNewMultiphaseDrop(this.contractWrapper)))return[await this.getActive(t,e)];{let r=await this.contractWrapper.readContract.claimCondition(t),a=r.currentStartId.toNumber(),i=r.count.toNumber(),n=[];for(let s=a;s<a+i;s++)n.push(await this.get(t,s));let o=await this.metadata.get();return Promise.all(n.map(t=>aq(t,0,this.contractWrapper.getProvider(),o.merkle,this.storage,e?.withAllowList||!1)))}}async canClaim(t,e,r){return r&&(r=await ex(r)),0===(await this.getClaimIneligibilityReasons(t,e,r)).length}async getClaimIneligibilityReasons(t,e,r){let a,i;let n=[];if(void 0===r)try{r=await this.contractWrapper.getSignerAddress()}catch(s){console.warn("failed to get signer address",s)}if(!r)return[sB.NoWallet];let o=await ex(r);try{i=await this.getActive(t)}catch(c){if(ai(c,"!CONDITION")||ai(c,"no active mint condition"))return n.push(sB.NoClaimConditionSet),n;return n.push(sB.Unknown),n}"unlimited"!==i.availableSupply&&T.O$.from(i.availableSupply).lt(e)&&n.push(sB.NotEnoughSupply);let l=v.stripZeros(i.merkleRootHash),d=l.length>0,p=null;if(d){if(!(p=await this.getClaimerProofs(t,o))&&(this.isLegacySinglePhaseDrop(this.contractWrapper)||this.isLegacyMultiPhaseDrop(this.contractWrapper)))return n.push(sB.AddressNotAllowed),n;if(p)try{let f;let h=await this.prepareClaim(t,e,!1,o);if(this.isLegacyMultiPhaseDrop(this.contractWrapper)){if(a=await this.contractWrapper.readContract.getActiveClaimConditionId(t),[f]=await this.contractWrapper.readContract.verifyClaimMerkleProof(a,o,t,e,h.proofs,h.maxClaimable),!f)return n.push(sB.AddressNotAllowed),n}else if(this.isLegacySinglePhaseDrop(this.contractWrapper)){if([f]=await this.contractWrapper.readContract.verifyClaimMerkleProof(t,o,e,{proof:h.proofs,maxQuantityInAllowlist:h.maxClaimable}),!f)return n.push(sB.AddressNotAllowed),n}else if(this.isNewSinglePhaseDrop(this.contractWrapper)){if(await this.contractWrapper.readContract.verifyClaim(t,o,e,h.currencyAddress,h.price,{proof:h.proofs,quantityLimitPerWallet:h.maxClaimable,currency:h.currencyAddressInProof,pricePerToken:h.priceInProof}),"0"===i.maxClaimablePerWallet&&h.maxClaimable===O.Bz||h.maxClaimable===T.O$.from(0))return n.push(sB.AddressNotAllowed),n}else if(this.isNewMultiphaseDrop(this.contractWrapper)&&(await this.contractWrapper.readContract.verifyClaim(a=await this.contractWrapper.readContract.getActiveClaimConditionId(t),o,t,e,h.currencyAddress,h.price,{proof:h.proofs,quantityLimitPerWallet:h.maxClaimable,currency:h.currencyAddressInProof,pricePerToken:h.priceInProof}),"0"===i.maxClaimablePerWallet&&h.maxClaimable===O.Bz||h.maxClaimable===T.O$.from(0)))return n.push(sB.AddressNotAllowed),n}catch(u){return console.warn("Merkle proof verification failed:","reason"in u?u.reason:u),n.push(sB.AddressNotAllowed),n}}if((this.isNewSinglePhaseDrop(this.contractWrapper)||this.isNewMultiphaseDrop(this.contractWrapper))&&(!d||d&&!p)&&"0"===i.maxClaimablePerWallet)return n.push(sB.AddressNotAllowed),n;let[m,g]=[T.O$.from(0),T.O$.from(0)];this.isLegacyMultiPhaseDrop(this.contractWrapper)?(a=await this.contractWrapper.readContract.getActiveClaimConditionId(t),[m,g]=await this.contractWrapper.readContract.getClaimTimestamp(t,a,o)):this.isLegacySinglePhaseDrop(this.contractWrapper)&&([m,g]=await this.contractWrapper.readContract.getClaimTimestamp(t,o));let y=T.O$.from(Date.now()).div(1e3);if(m.gt(0)&&y.lt(g)&&(g.eq(O.Bz)?n.push(sB.AlreadyClaimed):n.push(sB.WaitBeforeNextClaimTransaction)),i.price.gt(0)&&av()){let w=i.price.mul(e),b=this.contractWrapper.getProvider();if(aE(i.currencyAddress)){let C=await b.getBalance(o);C.lt(w)&&n.push(sB.NotEnoughTokens)}else{let W=new ak(b,i.currencyAddress,Y,{}),A=await W.readContract.balanceOf(o);A.lt(w)&&n.push(sB.NotEnoughTokens)}}return n}async getClaimerProofs(t,e,r){let a=await this.get(t,r),i=a.merkleRoot,n=v.stripZeros(i);if(!(n.length>0))return null;{let s=await this.metadata.get(),o=await ex(e);return await aI(o,i.toString(),s.merkle,this.contractWrapper.getProvider(),this.storage,this.getSnapshotFormatVersion())}}async prepareClaim(t,e,r,a){let i=await ex(a||await this.contractWrapper.getSignerAddress());return aF(i,e,await this.getActive(t),async()=>(await this.metadata.get()).merkle,0,this.contractWrapper,this.storage,r,this.getSnapshotFormatVersion())}async getClaimArguments(t,e,r,a){let i=await ex(e);return this.isLegacyMultiPhaseDrop(this.contractWrapper)?[i,t,r,a.currencyAddress,a.price,a.proofs,a.maxClaimable]:this.isLegacySinglePhaseDrop(this.contractWrapper)?[i,t,r,a.currencyAddress,a.price,{proof:a.proofs,maxQuantityInAllowlist:a.maxClaimable},S.Y0("")]:[i,t,r,a.currencyAddress,a.price,{proof:a.proofs,quantityLimitPerWallet:a.maxClaimable,pricePerToken:a.priceInProof,currency:a.currencyAddressInProof},S.Y0("")]}async getClaimTransaction(t,e,r,a){if(a?.pricePerToken)throw Error("Price per token should be set via claim conditions by calling `contract.erc1155.claimConditions.set()`");let i=await this.prepareClaim(e,r,a?.checkERC20Allowance||!0);return sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"claim",args:await this.getClaimArguments(e,t,r,i),overrides:i.overrides})}isNewSinglePhaseDrop(t){return nj(t,"ERC1155ClaimConditionsV2")}isNewMultiphaseDrop(t){return nj(t,"ERC1155ClaimPhasesV2")}isLegacySinglePhaseDrop(t){return nj(t,"ERC1155ClaimConditionsV1")}isLegacyMultiPhaseDrop(t){return nj(t,"ERC1155ClaimPhasesV1")}getSnapshotFormatVersion(){return this.isLegacyMultiPhaseDrop(this.contractWrapper)||this.isLegacySinglePhaseDrop(this.contractWrapper)?aZ.V1:aZ.V2}}class sO{constructor(t,e){(0,tR._)(this,"featureName",ib.name),(0,tR._)(this,"erc20",void 0),(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"tokens",a2(async t=>sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"burn",args:[await this.erc20.normalizeAmount(t)]}))),(0,tR._)(this,"from",a2(async(t,e)=>sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"burnFrom",args:[await ex(t),await this.erc20.normalizeAmount(e)]}))),this.erc20=t,this.contractWrapper=e}}class sI{constructor(t,e,r){(0,tR._)(this,"featureName",ig.name),(0,tR._)(this,"conditions",void 0),(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"erc20",void 0),(0,tR._)(this,"storage",void 0),(0,tR._)(this,"to",a2(async(t,e,r)=>{let a=await this.erc20.normalizeAmount(e);return await this.conditions.getClaimTransaction(t,a,r)})),this.erc20=t,this.contractWrapper=e,this.storage=r;let a=new sb(this.contractWrapper,cs,this.storage);this.conditions=new sD(this.contractWrapper,a,this.storage)}}class sR{constructor(t,e,r){(0,tR._)(this,"claim",void 0),(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"erc20",void 0),(0,tR._)(this,"storage",void 0),this.erc20=t,this.contractWrapper=e,this.storage=r,this.claim=new sI(this.erc20,this.contractWrapper,this.storage)}}class sN{constructor(t,e){(0,tR._)(this,"featureName",iv.name),(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"erc20",void 0),(0,tR._)(this,"to",a2(async t=>{let e=[];for(let r of t)e.push(this.contractWrapper.readContract.interface.encodeFunctionData("mintTo",[await ex(r.toAddress),await this.erc20.normalizeAmount(r.amount)]));return sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[e]})})),this.erc20=t,this.contractWrapper=e}}class sL{constructor(t,e){(0,tR._)(this,"featureName",iW.name),(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"erc20",void 0),(0,tR._)(this,"batch",void 0),(0,tR._)(this,"to",a2(async(t,e)=>await this.getMintTransaction(t,e))),this.erc20=t,this.contractWrapper=e,this.batch=this.detectErc20BatchMintable()}async getMintTransaction(t,e){return sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintTo",args:[await ex(t),await this.erc20.normalizeAmount(e)]})}detectErc20BatchMintable(){if(nj(this.contractWrapper,"ERC20BatchMintable"))return new sN(this.erc20,this.contractWrapper)}}class sM{constructor(t,e){(0,tR._)(this,"featureName",iC.name),(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"roles",void 0),(0,tR._)(this,"mint",a2(async t=>{let e=t.payload,r=t.signature,a=await this.mapPayloadToContractStruct(e),i=await this.contractWrapper.getCallOverrides();return await ax(this.contractWrapper,T.O$.from(a.price),e.currencyAddress,i),sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintWithSignature",args:[a,r],overrides:i})})),(0,tR._)(this,"mintBatch",a2(async t=>{let e=await Promise.all(t.map(async t=>{let e=await this.mapPayloadToContractStruct(t.payload),r=t.signature,a=t.payload.price;if(T.O$.from(a).gt(0))throw Error("Can only batch free mints. For mints with a price, use regular mint()");return{message:e,signature:r}})),r=e.map(t=>this.contractWrapper.readContract.interface.encodeFunctionData("mintWithSignature",[t.message,t.signature]));return sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[r]})})),this.contractWrapper=t,this.roles=e}async verify(t){let e=t.payload,r=t.signature,a=await this.mapPayloadToContractStruct(e),i=await this.contractWrapper.readContract.verify(a,r);return i[0]}async generate(t){return(await this.generateBatch([t]))[0]}async generateBatch(t){await this.roles?.verify(["minter"],await this.contractWrapper.getSignerAddress());let e=await Promise.all(t.map(t=>e1.parseAsync(t))),r=await this.contractWrapper.getChainID(),a=this.contractWrapper.getSigner();(0,tH.Z)(a,"No signer available");let i=await this.contractWrapper.readContract.name();return await Promise.all(e.map(async t=>{let e=await e2.parseAsync(t),n=await this.contractWrapper.signTypedData(a,{name:i,version:"1",chainId:r,verifyingContract:this.contractWrapper.readContract.address},{MintRequest:rt},await this.mapPayloadToContractStruct(e));return{payload:e,signature:n.toString()}}))}async mapPayloadToContractStruct(t){let e=await aS(this.contractWrapper.getProvider(),t.price,t.currencyAddress),r=B.parseUnits(t.quantity,await this.contractWrapper.readContract.decimals());return{to:t.to,primarySaleRecipient:t.primarySaleRecipient,quantity:r,price:e,currency:t.currencyAddress,validityEndTimestamp:t.mintEndTime,validityStartTimestamp:t.mintStartTime,uid:t.uid}}}class sz{get chainId(){return this._chainId}constructor(t,e,r){(0,tR._)(this,"featureName",ik.name),(0,tR._)(this,"mintable",void 0),(0,tR._)(this,"burnable",void 0),(0,tR._)(this,"droppable",void 0),(0,tR._)(this,"signatureMintable",void 0),(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"storage",void 0),(0,tR._)(this,"_chainId",void 0),(0,tR._)(this,"transfer",a2(async(t,e)=>sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"transfer",args:[await ex(t),await this.normalizeAmount(e)]}))),(0,tR._)(this,"transferFrom",a2(async(t,e,r)=>sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"transferFrom",args:[await ex(t),await ex(e),await this.normalizeAmount(r)]}))),(0,tR._)(this,"setAllowance",a2(async(t,e)=>sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approve",args:[await ex(t),await this.normalizeAmount(e)]}))),(0,tR._)(this,"transferBatch",a2(async t=>{let e=await Promise.all(t.map(async t=>{let e=await this.normalizeAmount(t.amount);return this.contractWrapper.readContract.interface.encodeFunctionData("transfer",[await ex(t.toAddress),e])}));return sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[e]})})),(0,tR._)(this,"mint",a2(async t=>this.mintTo.prepare(await this.contractWrapper.getSignerAddress(),t))),(0,tR._)(this,"mintTo",a2(async(t,e)=>nq(this.mintable,iW).to.prepare(t,e))),(0,tR._)(this,"mintBatchTo",a2(async t=>nq(this.mintable?.batch,iv).to.prepare(t))),(0,tR._)(this,"burn",a2(async t=>nq(this.burnable,ib).tokens.prepare(t))),(0,tR._)(this,"burnFrom",a2(async(t,e)=>nq(this.burnable,ib).from.prepare(t,e))),(0,tR._)(this,"claim",a2(async(t,e)=>this.claimTo.prepare(await this.contractWrapper.getSignerAddress(),t,e))),(0,tR._)(this,"claimTo",a2(async(t,e,r)=>nq(this.droppable?.claim,ig).to.prepare(t,e,r))),this.contractWrapper=t,this.storage=e,this.mintable=this.detectErc20Mintable(),this.burnable=this.detectErc20Burnable(),this.droppable=this.detectErc20Droppable(),this.signatureMintable=this.detectErc20SignatureMintable(),this._chainId=r}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.readContract.address}async get(){return await a_(this.contractWrapper.getProvider(),this.getAddress())}async balance(){return await this.balanceOf(await this.contractWrapper.getSignerAddress())}async balanceOf(t){return this.getValue(await this.contractWrapper.readContract.balanceOf(await ex(t)))}async totalSupply(){return await this.getValue(await this.contractWrapper.readContract.totalSupply())}async allowance(t){return await this.allowanceOf(await this.contractWrapper.getSignerAddress(),await ex(t))}async allowanceOf(t,e){return await this.getValue(await this.contractWrapper.readContract.allowance(await ex(t),await ex(e)))}async getMintTransaction(t,e){return nq(this.mintable,iW).getMintTransaction(t,e)}get claimConditions(){return nq(this.droppable?.claim,ig).conditions}get signature(){return nq(this.signatureMintable,iC)}async normalizeAmount(t){let e=await this.contractWrapper.readContract.decimals();return B.parseUnits(tR.A.parse(t),e)}async getValue(t){return await aP(this.contractWrapper.getProvider(),this.getAddress(),T.O$.from(t))}detectErc20Mintable(){if(nj(this.contractWrapper,"ERC20"))return new sL(this,this.contractWrapper)}detectErc20Burnable(){if(nj(this.contractWrapper,"ERC20Burnable"))return new sO(this,this.contractWrapper)}detectErc20Droppable(){if(nj(this.contractWrapper,"ERC20ClaimConditionsV1")||nj(this.contractWrapper,"ERC20ClaimConditionsV2")||nj(this.contractWrapper,"ERC20ClaimPhasesV1")||nj(this.contractWrapper,"ERC20ClaimPhasesV2"))return new sR(this,this.contractWrapper,this.storage)}detectErc20SignatureMintable(){if(nj(this.contractWrapper,"ERC20SignatureMintable"))return new sM(this.contractWrapper)}}class s${constructor(t){(0,tR._)(this,"featureName",iE.name),(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"token",a2(async t=>sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"burn",args:[t]}))),this.contractWrapper=t}}class sU{constructor(t,e,r){(0,tR._)(this,"featureName",iF.name),(0,tR._)(this,"revealer",void 0),(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"erc721",void 0),(0,tR._)(this,"storage",void 0),(0,tR._)(this,"lazyMint",a2(async(t,e)=>{let r=await this.erc721.nextTokenIdToMint(),a=await sS(t,this.storage,r.toNumber(),e),i=s_(a);return sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[a.length,i.endsWith("/")?i:`${i}/`,S.Y0("")],parse:t=>{let e=this.contractWrapper.parseLogs("TokensLazyMinted",t?.logs),r=e[0].args.startTokenId,a=e[0].args.endTokenId,i=[];for(let n=r;n.lte(a);n=n.add(1))i.push({id:n,receipt:t,data:()=>this.erc721.getTokenMetadata(n)});return i}})})),this.erc721=t,this.contractWrapper=e,this.storage=r,this.revealer=this.detectErc721Revealable()}detectErc721Revealable(){if(nj(this.contractWrapper,"ERC721Revealable"))return new sP(this.contractWrapper,this.storage,iT.name,()=>this.erc721.nextTokenIdToMint())}}class sV{constructor(t,e,r){(0,tR._)(this,"featureName",iO.name),(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"storage",void 0),(0,tR._)(this,"erc721",void 0),(0,tR._)(this,"to",a2(async(t,e)=>{let r=await sS(e,this.storage),a=await ex(t),i=await Promise.all(r.map(async t=>this.contractWrapper.readContract.interface.encodeFunctionData("mintTo",[a,t])));return sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[i],parse:t=>{let r=this.contractWrapper.parseLogs("TokensMinted",t.logs);if(0===r.length||r.length<e.length)throw Error("TokenMinted event not found, minting failed");return r.map(e=>{let r=e.args.tokenIdMinted;return{id:r,receipt:t,data:()=>this.erc721.get(r)}})}})})),this.erc721=t,this.contractWrapper=e,this.storage=r}}class sq{constructor(t,e,r){(0,tR._)(this,"featureName",iI.name),(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"storage",void 0),(0,tR._)(this,"erc721",void 0),(0,tR._)(this,"batch",void 0),(0,tR._)(this,"to",a2(async(t,e)=>{let r=await sT(e,this.storage);return sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintTo",args:[await ex(t),r],parse:t=>{let e=this.contractWrapper.parseLogs("Transfer",t?.logs);if(0===e.length)throw Error("TransferEvent event not found");let r=e[0].args.tokenId;return{id:r,receipt:t,data:()=>this.erc721.get(r)}}})})),this.erc721=t,this.contractWrapper=e,this.storage=r,this.batch=this.detectErc721BatchMintable()}async getMintTransaction(t,e){return this.to.prepare(await ex(t),e)}detectErc721BatchMintable(){if(nj(this.contractWrapper,"ERC721BatchMintable"))return new sV(this.erc721,this.contractWrapper,this.storage)}}class sj{constructor(t,e){(0,tR._)(this,"featureName",iL.name),(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"erc721",void 0),this.erc721=t,this.contractWrapper=e}async all(t){let e=await this.tokenIds(t);return await Promise.all(e.map(t=>this.erc721.get(t.toString())))}async tokenIds(t){let e=await ex(t||await this.contractWrapper.getSignerAddress()),r=await this.contractWrapper.readContract.balanceOf(e),a=Array.from(Array(r.toNumber()).keys());return await Promise.all(a.map(t=>this.contractWrapper.readContract.tokenOfOwnerByIndex(e,t)))}}class sG{constructor(t,e){(0,tR._)(this,"featureName",iM.name),(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"erc721",void 0),(0,tR._)(this,"owned",void 0),this.erc721=t,this.contractWrapper=e,this.owned=this.detectErc721Owned()}async all(t){let e=T.O$.from(t?.start||0).toNumber(),r=T.O$.from(t?.count||tR.c).toNumber(),a=await this.erc721.nextTokenIdToMint(),i=Math.min(a.toNumber(),e+r);return await Promise.all([...Array(i-e).keys()].map(t=>this.erc721.get((e+t).toString())))}async allOwners(){return Promise.all([...Array((await this.totalCount()).toNumber()).keys()].map(async t=>({tokenId:t,owner:await this.erc721.ownerOf(t).catch(()=>C.d)})))}async totalCount(){return await this.erc721.nextTokenIdToMint()}async totalCirculatingSupply(){return await this.contractWrapper.readContract.totalSupply()}detectErc721Owned(){if(nj(this.contractWrapper,"ERC721Enumerable"))return new sj(this.erc721,this.contractWrapper)}}let sH=e0.extend({tierPriority:tN.z.array(tN.z.string()),royaltyRecipient:eR.default(C.d),royaltyBps:tR.a.default(0),quantity:eD.default(1)});class sZ{constructor(t,e,r){(0,tR._)(this,"featureName",iS.name),(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"erc721",void 0),(0,tR._)(this,"storage",void 0),(0,tR._)(this,"createBatchWithTier",a2(async(t,e,r)=>{let a=await this.erc721.nextTokenIdToMint(),i=await sS(t,this.storage,a.toNumber(),r),n=s_(i);return sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[i.length,n.endsWith("/")?n:`${n}/`,e,S.Y0("")],parse:t=>{let e=this.contractWrapper.parseLogs("TokensLazyMinted",t?.logs),r=e[0].args[1],a=e[0].args[2],i=[];for(let n=r;n.lte(a);n=n.add(1))i.push({id:n,receipt:t,data:()=>this.erc721.getTokenMetadata(n)});return i}})})),(0,tR._)(this,"createDelayedRevealBatchWithTier",a2(async(t,e,r,a,i)=>{let n;if(!r)throw Error("Password is required");let s=await this.storage.uploadBatch([tR.b.parse(t)],{rewriteFileNames:{fileStartNumber:0}}),o=s_(s),c=await this.erc721.nextTokenIdToMint(),l=await this.storage.uploadBatch(e.map(t=>tR.b.parse(t)),{onProgress:i?.onProgress,rewriteFileNames:{fileStartNumber:c.toNumber()}}),d=s_(l),p=await this.contractWrapper.readContract.getBaseURICount(),f=await this.contractWrapper.getChainID(),h=I.keccak256(["string","uint256","uint256","address"],[r,f,p,this.contractWrapper.readContract.address]),u=await this.contractWrapper.readContract.encryptDecrypt(S.Y0(d),h),m=I.keccak256(["bytes","bytes","uint256"],[S.Y0(d),h,f]);return n=z.$.encode(["bytes","bytes32"],[u,m]),sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[l.length,o.endsWith("/")?o:`${o}/`,a,n],parse:t=>{let e=this.contractWrapper.parseLogs("TokensLazyMinted",t?.logs),r=e[0].args[1],a=e[0].args[2],i=[];for(let n=r;n.lte(a);n=n.add(1))i.push({id:n,receipt:t,data:()=>this.erc721.getTokenMetadata(n)});return i}})})),(0,tR._)(this,"reveal",a2(async(t,e)=>{if(!e)throw Error("Password is required");let r=await this.contractWrapper.getChainID(),a=I.keccak256(["string","uint256","uint256","address"],[e,r,t,this.contractWrapper.readContract.address]);try{let i=await this.contractWrapper.callStatic().reveal(t,a);if(!i.includes("://")||!i.endsWith("/"))throw Error("invalid password")}catch(n){throw Error("invalid password")}return sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"reveal",args:[t,a]})})),this.erc721=t,this.contractWrapper=e,this.storage=r}async getMetadataInTier(t){let e=await this.contractWrapper.readContract.getMetadataForAllTiers(),r=e.find(e=>e.tier===t);if(!r)throw Error("Tier not found in contract.");let a=await Promise.all(r.ranges.map((t,e)=>{let a=[],i=r.baseURIs[e];for(let n=t.startIdInclusive.toNumber();n<t.endIdNonInclusive.toNumber();n++){let s=`${i}/${n}`,o=this.storage.downloadJSON(s);a.push(o)}return a}).flat());return a}async getTokensInTier(t){let e=await this.contractWrapper.readContract.getTokensInTierLen();if(e.eq(0))return[];let r=await this.contractWrapper.readContract.getTokensInTier(t,0,e),a=await Promise.all(r.map(t=>{let e=[];for(let r=t.startIdInclusive.toNumber();r<t.endIdNonInclusive.toNumber();r++)e.push(this.erc721.get(r));return e}).flat());return a}async generate(t){let[e]=await this.generateBatch([t]);return e}async generateBatch(t){let e=await Promise.all(t.map(t=>sH.parseAsync(t))),r=await this.contractWrapper.getChainID(),a=this.contractWrapper.getSigner();return(0,tH.Z)(a,"No signer available"),await Promise.all(e.map(async t=>{let e=await this.contractWrapper.signTypedData(a,{name:"SignatureAction",version:"1",chainId:r,verifyingContract:this.contractWrapper.readContract.address},{GenericRequest:ri},await this.mapPayloadToContractStruct(t));return{payload:t,signature:e.toString()}}))}async verify(t){let e=await this.mapPayloadToContractStruct(t.payload),r=await this.contractWrapper.readContract.verify(e,t.signature);return r[0]}async claimWithSignature(t){let e=await this.mapPayloadToContractStruct(t.payload),r=await aS(this.contractWrapper.getProvider(),t.payload.price,t.payload.currencyAddress),a=await this.contractWrapper.getCallOverrides();await ax(this.contractWrapper,r,t.payload.currencyAddress,a);let i=await this.contractWrapper.sendTransaction("claimWithSignature",[e,t.signature],a),n=this.contractWrapper.parseLogs("TokensClaimed",i?.logs),s=n[0].args.startTokenId,o=s.add(n[0].args.quantityClaimed),c=[];for(let l=s;l.lt(o);l=l.add(1))c.push({id:l,receipt:i,data:()=>this.erc721.get(l)});return c}async mapPayloadToContractStruct(t){let e=await aS(this.contractWrapper.getProvider(),t.price,t.currencyAddress),r=z.$.encode(["string[]","address","address","uint256","address","uint256","uint256","address"],[t.tierPriority,t.to,t.royaltyRecipient,t.royaltyBps,t.primarySaleRecipient,t.quantity,e,t.currencyAddress]);return{uid:t.uid,validityStartTimestamp:t.mintStartTime,validityEndTimestamp:t.mintEndTime,data:r}}}class sJ{constructor(t,e){(0,tR._)(this,"featureName",iR.name),(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"storage",void 0),(0,tR._)(this,"mint",a2(async t=>{let e=t.payload,r=t.signature,a=await this.contractWrapper.getCallOverrides(),i=t=>{let e=this.contractWrapper.parseLogs("TokensMintedWithSignature",t.logs);if(0===e.length)throw Error("No MintWithSignature event found");let r=e[0].args.tokenIdMinted;return{id:r,receipt:t}};if(await this.isLegacyNFTContract()){let n=await this.mapLegacyPayloadToContractStruct(e),s=n.price;return await ax(this.contractWrapper,s,e.currencyAddress,a),sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintWithSignature",args:[n,r],overrides:a,parse:i})}{let o=await this.mapPayloadToContractStruct(e),c=o.pricePerToken.mul(o.quantity);return await ax(this.contractWrapper,c,e.currencyAddress,a),sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintWithSignature",args:[o,r],overrides:a,parse:i})}})),(0,tR._)(this,"mintBatch",a2(async t=>{let e=await this.isLegacyNFTContract(),r=await Promise.all(t.map(async t=>{let r;r=e?await this.mapLegacyPayloadToContractStruct(t.payload):await this.mapPayloadToContractStruct(t.payload);let a=t.signature,i=t.payload.price;if(T.O$.from(i).gt(0))throw Error("Can only batch free mints. For mints with a price, use regular mint()");return{message:r,signature:a}})),a=r.map(t=>{if(e){let r=this.contractWrapper.readContract;return r.interface.encodeFunctionData("mintWithSignature",[t.message,t.signature])}{let a=this.contractWrapper.readContract;return a.interface.encodeFunctionData("mintWithSignature",[t.message,t.signature])}});if(nG("multicall",this.contractWrapper))return sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[a],parse:t=>{let e=this.contractWrapper.parseLogs("TokensMintedWithSignature",t.logs);if(0===e.length)throw Error("No MintWithSignature event found");return e.map(e=>({id:e.args.tokenIdMinted,receipt:t}))}});throw Error("Multicall not available on this contract!")})),this.contractWrapper=t,this.storage=e}async verify(t){let e;let r=await this.isLegacyNFTContract(),a=t.payload,i=t.signature;if(r){let n=this.contractWrapper.readContract;e=await n.verify(await this.mapLegacyPayloadToContractStruct(a),i)}else{let s=this.contractWrapper.readContract;e=await s.verify(await this.mapPayloadToContractStruct(a),i)}return e[0]}async generate(t){return(await this.generateBatch([t]))[0]}async generateBatch(t){let e=await this.isLegacyNFTContract(),r=await Promise.all(t.map(t=>e7.parseAsync(t))),a=r.map(t=>t.metadata),i=await sS(a,this.storage),n=await this.contractWrapper.getChainID(),s=this.contractWrapper.getSigner();return(0,tH.Z)(s,"No signer available"),await Promise.all(r.map(async(t,r)=>{let a;let o=i[r],c=await e9.parseAsync({...t,uri:o});return a=e?await this.contractWrapper.signTypedData(s,{name:"TokenERC721",version:"1",chainId:n,verifyingContract:this.contractWrapper.readContract.address},{MintRequest:re},await this.mapLegacyPayloadToContractStruct(c)):await this.contractWrapper.signTypedData(s,{name:"SignatureMintERC721",version:"1",chainId:n,verifyingContract:await this.contractWrapper.readContract.address},{MintRequest:ra},await this.mapPayloadToContractStruct(c)),{payload:c,signature:a.toString()}}))}async mapPayloadToContractStruct(t){let e=await aS(this.contractWrapper.getProvider(),t.price,t.currencyAddress);return{to:t.to,royaltyRecipient:t.royaltyRecipient,royaltyBps:t.royaltyBps,primarySaleRecipient:t.primarySaleRecipient,uri:t.uri,quantity:t.quantity,pricePerToken:e,currency:t.currencyAddress,validityStartTimestamp:t.mintStartTime,validityEndTimestamp:t.mintEndTime,uid:t.uid}}async mapLegacyPayloadToContractStruct(t){let e=await aS(this.contractWrapper.getProvider(),t.price,t.currencyAddress);return{to:t.to,price:e,uri:t.uri,currency:t.currencyAddress,validityEndTimestamp:t.mintEndTime,validityStartTimestamp:t.mintStartTime,uid:t.uid,royaltyRecipient:t.royaltyRecipient,royaltyBps:t.royaltyBps,primarySaleRecipient:t.primarySaleRecipient}}async isLegacyNFTContract(){return nj(this.contractWrapper,"ERC721SignatureMintV1")}}class sY{constructor(t,e){(0,tR._)(this,"featureName",iD.name),(0,tR._)(this,"erc721",void 0),(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"to",a2(async(t,e,r)=>{let a=await this.getClaimTransaction(t,e,r);return a.setParse(t=>{let r=this.contractWrapper.parseLogs("TokensClaimed",t?.logs),a=r[0].args.startTokenId,i=a.add(e),n=[];for(let s=a;s.lt(i);s=s.add(1))n.push({id:s,receipt:t,data:()=>this.erc721.get(s)});return n}),a})),this.erc721=t,this.contractWrapper=e}async getClaimTransaction(t,e,r){let a={};return r&&r.pricePerToken&&(a=await aH(this.contractWrapper,r.pricePerToken,e,r.currencyAddress,r.checkERC20Allowance)),sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"claim",args:[t,e],overrides:a})}}class sK{constructor(t,e,r){(0,tR._)(this,"featureName",iP.name),(0,tR._)(this,"conditions",void 0),(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"erc721",void 0),(0,tR._)(this,"storage",void 0),(0,tR._)(this,"to",a2(async(t,e,r)=>{let a=await this.conditions.getClaimTransaction(t,e,r);return a.setParse(t=>{let r=this.contractWrapper.parseLogs("TokensClaimed",t?.logs),a=r[0].args.startTokenId,i=a.add(e),n=[];for(let s=a;s.lt(i);s=s.add(1))n.push({id:s,receipt:t,data:()=>this.erc721.get(s)});return n}),a})),this.erc721=t,this.contractWrapper=e,this.storage=r;let a=new sb(this.contractWrapper,cs,this.storage);this.conditions=new sD(this.contractWrapper,a,this.storage)}}class sQ{get chainId(){return this._chainId}constructor(t,e,r){(0,tR._)(this,"featureName",iz.name),(0,tR._)(this,"query",void 0),(0,tR._)(this,"mintable",void 0),(0,tR._)(this,"burnable",void 0),(0,tR._)(this,"lazyMintable",void 0),(0,tR._)(this,"tieredDropable",void 0),(0,tR._)(this,"signatureMintable",void 0),(0,tR._)(this,"claimWithConditions",void 0),(0,tR._)(this,"claimCustom",void 0),(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"storage",void 0),(0,tR._)(this,"_chainId",void 0),(0,tR._)(this,"transfer",a2(async(t,e)=>{let r=await this.contractWrapper.getSignerAddress();return sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"transferFrom(address,address,uint256)",args:[r,await ex(t),e]})})),(0,tR._)(this,"setApprovalForAll",a2(async(t,e)=>sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setApprovalForAll",args:[await ex(t),e]}))),(0,tR._)(this,"setApprovalForToken",a2(async(t,e)=>sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approve",args:[await ex(t),e]}))),(0,tR._)(this,"mint",a2(async t=>this.mintTo.prepare(await this.contractWrapper.getSignerAddress(),t))),(0,tR._)(this,"mintTo",a2(async(t,e)=>nq(this.mintable,iI).to.prepare(t,e))),(0,tR._)(this,"mintBatch",a2(async t=>this.mintBatchTo.prepare(await this.contractWrapper.getSignerAddress(),t))),(0,tR._)(this,"mintBatchTo",a2(async(t,e)=>nq(this.mintable?.batch,iO).to.prepare(t,e))),(0,tR._)(this,"burn",a2(async t=>nq(this.burnable,iE).token.prepare(t))),(0,tR._)(this,"lazyMint",a2(async(t,e)=>nq(this.lazyMintable,iF).lazyMint.prepare(t,e))),(0,tR._)(this,"claim",a2(async(t,e)=>this.claimTo.prepare(await this.contractWrapper.getSignerAddress(),t,e))),(0,tR._)(this,"claimTo",a2(async(t,e,r)=>{let a=this.claimWithConditions,i=this.claimCustom;if(a)return a.to.prepare(t,e,r);if(i)return i.to.prepare(t,e,r);throw new r4(iD)})),this.contractWrapper=t,this.storage=e,this.query=this.detectErc721Enumerable(),this.mintable=this.detectErc721Mintable(),this.burnable=this.detectErc721Burnable(),this.lazyMintable=this.detectErc721LazyMintable(),this.tieredDropable=this.detectErc721TieredDrop(),this.signatureMintable=this.detectErc721SignatureMintable(),this.claimWithConditions=this.detectErc721ClaimableWithConditions(),this.claimCustom=this.detectErc721Claimable(),this._chainId=r}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.readContract.address}async get(t){let[e,r]=await Promise.all([this.ownerOf(t).catch(()=>C.d),this.getTokenMetadata(t).catch(()=>({id:t.toString(),uri:"",...sA}))]);return{owner:e,metadata:r,type:"ERC721",supply:"1"}}async ownerOf(t){return await this.contractWrapper.readContract.ownerOf(t)}async balanceOf(t){return await this.contractWrapper.readContract.balanceOf(await ex(t))}async balance(){return await this.balanceOf(await this.contractWrapper.getSignerAddress())}async isApproved(t,e){return await this.contractWrapper.readContract.isApprovedForAll(await ex(t),await ex(e))}async getAll(t){return nq(this.query,iM).all(t)}async getAllOwners(){return nq(this.query,iM).allOwners()}async totalCount(){return this.nextTokenIdToMint()}async totalCirculatingSupply(){return nq(this.query,iM).totalCirculatingSupply()}async getOwned(t){if(t&&(t=await ex(t)),this.query?.owned)return this.query.owned.all(t);{let e=t||await this.contractWrapper.getSignerAddress(),r=await this.getAllOwners();return Promise.all((r||[]).filter(t=>e?.toLowerCase()===t.owner?.toLowerCase()).map(async t=>await this.get(t.tokenId)))}}async getOwnedTokenIds(t){if(t&&(t=await ex(t)),this.query?.owned)return this.query.owned.tokenIds(t);{let e=t||await this.contractWrapper.getSignerAddress(),r=await this.getAllOwners();return(r||[]).filter(t=>e?.toLowerCase()===t.owner?.toLowerCase()).map(t=>T.O$.from(t.tokenId))}}async getMintTransaction(t,e){return this.mintTo.prepare(t,e)}async getClaimTransaction(t,e,r){let a=this.claimWithConditions,i=this.claimCustom;if(a)return a.conditions.getClaimTransaction(t,e,r);if(i)return i.getClaimTransaction(t,e,r);throw new r4(iD)}async totalClaimedSupply(){let t=this.contractWrapper;if(nG("nextTokenIdToClaim",t))return t.readContract.nextTokenIdToClaim();if(nG("totalMinted",t))return t.readContract.totalMinted();throw Error("No function found on contract to get total claimed supply")}async totalUnclaimedSupply(){return(await this.nextTokenIdToMint()).sub(await this.totalClaimedSupply())}get claimConditions(){return nq(this.claimWithConditions,iP).conditions}get tieredDrop(){return nq(this.tieredDropable,iS)}get signature(){return nq(this.signatureMintable,iR)}get revealer(){return nq(this.lazyMintable?.revealer,iT)}async getTokenMetadata(t){let e=await this.contractWrapper.readContract.tokenURI(t);if(!e)throw new r0;return sk(t,e,this.storage)}async nextTokenIdToMint(){if(nG("nextTokenIdToMint",this.contractWrapper))return await this.contractWrapper.readContract.nextTokenIdToMint();if(nG("totalSupply",this.contractWrapper))return await this.contractWrapper.readContract.totalSupply();throw Error("Contract requires either `nextTokenIdToMint` or `totalSupply` function available to determine the next token ID to mint")}detectErc721Enumerable(){if(nj(this.contractWrapper,"ERC721Supply")||nG("nextTokenIdToMint",this.contractWrapper))return new sG(this,this.contractWrapper)}detectErc721Mintable(){if(nj(this.contractWrapper,"ERC721Mintable"))return new sq(this,this.contractWrapper,this.storage)}detectErc721Burnable(){if(nj(this.contractWrapper,"ERC721Burnable"))return new s$(this.contractWrapper)}detectErc721LazyMintable(){if(nj(this.contractWrapper,"ERC721LazyMintable"))return new sU(this,this.contractWrapper,this.storage)}detectErc721TieredDrop(){if(nj(this.contractWrapper,"ERC721TieredDrop"))return new sZ(this,this.contractWrapper,this.storage)}detectErc721SignatureMintable(){if(nj(this.contractWrapper,"ERC721SignatureMintV1")||nj(this.contractWrapper,"ERC721SignatureMintV2"))return new sJ(this.contractWrapper,this.storage)}detectErc721ClaimableWithConditions(){if(nj(this.contractWrapper,"ERC721ClaimConditionsV1")||nj(this.contractWrapper,"ERC721ClaimConditionsV2")||nj(this.contractWrapper,"ERC721ClaimPhasesV1")||nj(this.contractWrapper,"ERC721ClaimPhasesV2"))return new sK(this,this.contractWrapper,this.storage)}detectErc721Claimable(){if(nj(this.contractWrapper,"ERC721ClaimCustom"))return new sY(this,this.contractWrapper)}}let sX=tN.z.object({address:eR,quantity:tR.A.default(1)}),s0=tN.z.union([tN.z.array(tN.z.string()).transform(async t=>await Promise.all(t.map(t=>sX.parseAsync({address:t})))),tN.z.array(sX)]);class s1{constructor(t){(0,tR._)(this,"featureName",i$.name),(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"tokens",a2(async(t,e)=>{let r=await this.contractWrapper.getSignerAddress();return this.from.prepare(r,t,e)})),(0,tR._)(this,"from",a2(async(t,e,r)=>sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"burn",args:[await ex(t),e,r]}))),(0,tR._)(this,"batch",a2(async(t,e)=>{let r=await this.contractWrapper.getSignerAddress();return this.batchFrom.prepare(r,t,e)})),(0,tR._)(this,"batchFrom",a2(async(t,e,r)=>sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"burnBatch",args:[await ex(t),e,r]}))),this.contractWrapper=t}}class s2{constructor(t,e){(0,tR._)(this,"featureName",iX.name),(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"erc1155",void 0),this.erc1155=t,this.contractWrapper=e}async all(t){let e=T.O$.from(t?.start||0).toNumber(),r=T.O$.from(t?.count||tR.c).toNumber(),a=Math.min((await this.totalCount()).toNumber(),e+r);return await Promise.all([...Array(a-e).keys()].map(t=>this.erc1155.get((e+t).toString())))}async totalCount(){return await this.contractWrapper.readContract.nextTokenIdToMint()}async totalCirculatingSupply(t){return await this.contractWrapper.readContract.totalSupply(t)}async owned(t){let e=await ex(t||await this.contractWrapper.getSignerAddress()),r=await this.contractWrapper.readContract.nextTokenIdToMint(),a=await this.contractWrapper.readContract.balanceOfBatch(Array(r.toNumber()).fill(e),Array.from(Array(r.toNumber()).keys())),i=a.map((t,e)=>({tokenId:e,balance:t})).filter(t=>t.balance.gt(0));return await Promise.all(i.map(async t=>{let r=await this.erc1155.get(t.tokenId.toString());return{...r,owner:e,quantityOwned:t.balance.toString()}}))}}async function s5(t,e){try{let r=new F.CH(t,b,e),[a,i]=await Promise.all([S.ZN(await r.contractType()).replace(/\x00/g,""),await r.contractVersion()]);return{type:a,version:i}}catch(n){return}}class s6{constructor(t,e,r){(0,tR._)(this,"featureName",iZ.name),(0,tR._)(this,"revealer",void 0),(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"erc1155",void 0),(0,tR._)(this,"storage",void 0),(0,tR._)(this,"lazyMint",a2(async(t,e)=>{let r=await this.erc1155.nextTokenIdToMint(),a=await sS(t,this.storage,r.toNumber(),e),i=a[0].substring(0,a[0].lastIndexOf("/"));for(let n=0;n<a.length;n++){let s=a[n].substring(0,a[n].lastIndexOf("/"));if(i!==s)throw Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${i}' but got '${s}'`)}let o=t=>{let e=this.contractWrapper.parseLogs("TokensLazyMinted",t?.logs),r=e[0].args.startTokenId,a=e[0].args.endTokenId,i=[];for(let n=r;n.lte(a);n=n.add(1))i.push({id:n,receipt:t,data:()=>this.erc1155.getTokenMetadata(n)});return i},c=await s5(this.contractWrapper.readContract.address,this.contractWrapper.getProvider());return this.isLegacyEditionDropContract(this.contractWrapper,c)?sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[a.length,`${i.endsWith("/")?i:`${i}/`}`],parse:o}):sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[a.length,`${i.endsWith("/")?i:`${i}/`}`,S.Y0("")],parse:o})})),this.erc1155=t,this.contractWrapper=e,this.storage=r,this.revealer=this.detectErc1155Revealable()}detectErc1155Revealable(){if(nj(this.contractWrapper,"ERC1155Revealable"))return new sP(this.contractWrapper,this.storage,iH.name,()=>this.erc1155.nextTokenIdToMint())}isLegacyEditionDropContract(t,e){return e&&"DropERC1155"===e.type&&e.version<3||!1}}class s8{constructor(t,e,r){(0,tR._)(this,"featureName",iK.name),(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"erc1155",void 0),(0,tR._)(this,"storage",void 0),(0,tR._)(this,"to",a2(async(t,e)=>{let r=e.map(t=>t.metadata),a=e.map(t=>t.supply),i=await sS(r,this.storage),n=await ex(t),s=await Promise.all(i.map(async(t,e)=>this.contractWrapper.readContract.interface.encodeFunctionData("mintTo",[n,O.Bz,t,a[e]])));return sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[s],parse:t=>{let e=this.contractWrapper.parseLogs("TokensMinted",t.logs);if(0===e.length||e.length<r.length)throw Error("TokenMinted event not found, minting failed");return e.map(e=>{let r=e.args.tokenIdMinted;return{id:r,receipt:t,data:()=>this.erc1155.get(r)}})}})})),this.erc1155=t,this.contractWrapper=e,this.storage=r}}class s3{constructor(t,e,r){(0,tR._)(this,"featureName",iQ.name),(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"erc1155",void 0),(0,tR._)(this,"storage",void 0),(0,tR._)(this,"batch",void 0),(0,tR._)(this,"to",a2(async(t,e)=>{let r=await this.getMintTransaction(t,e);return r.setParse(t=>{let e=this.contractWrapper.parseLogs("TransferSingle",t?.logs);if(0===e.length)throw Error("TransferSingleEvent event not found");let r=e[0].args.id;return{id:r,receipt:t,data:()=>this.erc1155.get(r.toString())}}),r})),(0,tR._)(this,"additionalSupplyTo",a2(async(t,e,r)=>{let a=await this.erc1155.getTokenMetadata(e);return sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintTo",args:[await ex(t),e,a.uri,r],parse:t=>({id:T.O$.from(e),receipt:t,data:()=>this.erc1155.get(e)})})})),this.erc1155=t,this.contractWrapper=e,this.storage=r,this.batch=this.detectErc1155BatchMintable()}async getMintTransaction(t,e){let r=await sT(e.metadata,this.storage);return sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintTo",args:[await ex(t),O.Bz,r,e.supply]})}detectErc1155BatchMintable(){if(nj(this.contractWrapper,"ERC1155BatchMintable"))return new s8(this.erc1155,this.contractWrapper,this.storage)}}class s4{constructor(t,e,r){(0,tR._)(this,"featureName",iY.name),(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"storage",void 0),(0,tR._)(this,"roles",void 0),(0,tR._)(this,"mint",a2(async t=>{let e=t.payload,r=t.signature,a=await this.mapPayloadToContractStruct(e),i=await this.contractWrapper.getCallOverrides();return await ax(this.contractWrapper,a.pricePerToken.mul(a.quantity),e.currencyAddress,i),sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintWithSignature",args:[a,r],overrides:i,parse:t=>{let e=this.contractWrapper.parseLogs("TokensMintedWithSignature",t.logs);if(0===e.length)throw Error("No MintWithSignature event found");let r=e[0].args.tokenIdMinted;return{id:r,receipt:t}}})})),(0,tR._)(this,"mintBatch",a2(async t=>{let e=await Promise.all(t.map(async t=>{let e=await this.mapPayloadToContractStruct(t.payload),r=t.signature,a=t.payload.price;if(T.O$.from(a).gt(0))throw Error("Can only batch free mints. For mints with a price, use regular mint()");return{message:e,signature:r}})),r=e.map(t=>this.contractWrapper.readContract.interface.encodeFunctionData("mintWithSignature",[t.message,t.signature]));if(nG("multicall",this.contractWrapper))return sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[r],parse:t=>{let e=this.contractWrapper.parseLogs("TokensMintedWithSignature",t.logs);if(0===e.length)throw Error("No MintWithSignature event found");return e.map(e=>({id:e.args.tokenIdMinted,receipt:t}))}});throw Error("Multicall not supported on this contract!")})),this.contractWrapper=t,this.storage=e,this.roles=r}async verify(t){let e=t.payload,r=t.signature,a=await this.mapPayloadToContractStruct(e),i=await this.contractWrapper.readContract.verify(a,r);return i[0]}async generate(t){let e={...t,tokenId:O.Bz};return this.generateFromTokenId(e)}async generateFromTokenId(t){let e=await this.generateBatchFromTokenIds([t]);return e[0]}async generateBatch(t){let e=t.map(t=>({...t,tokenId:O.Bz}));return this.generateBatchFromTokenIds(e)}async generateBatchFromTokenIds(t){await this.roles?.verify(["minter"],await this.contractWrapper.getSignerAddress());let e=await Promise.all(t.map(t=>e3.parseAsync(t))),r=e.map(t=>t.metadata),a=await sS(r,this.storage),i=await this.contractWrapper.getChainID(),n=this.contractWrapper.getSigner();(0,tH.Z)(n,"No signer available");let s=await s5(this.contractWrapper.readContract.address,this.contractWrapper.getProvider()),o=s?.type==="TokenERC1155";return await Promise.all(e.map(async(t,e)=>{let r=a[e],s=await e4.parseAsync({...t,uri:r}),c=await this.contractWrapper.signTypedData(n,{name:o?"TokenERC1155":"SignatureMintERC1155",version:"1",chainId:i,verifyingContract:this.contractWrapper.readContract.address},{MintRequest:rr},await this.mapPayloadToContractStruct(s));return{payload:s,signature:c.toString()}}))}async mapPayloadToContractStruct(t){let e=await aS(this.contractWrapper.getProvider(),t.price,t.currencyAddress);return{to:t.to,tokenId:t.tokenId,uri:t.uri,quantity:t.quantity,pricePerToken:e,currency:t.currencyAddress,validityStartTimestamp:t.mintStartTime,validityEndTimestamp:t.mintEndTime,uid:t.uid,royaltyRecipient:t.royaltyRecipient,royaltyBps:t.royaltyBps,primarySaleRecipient:t.primarySaleRecipient}}}class s7{constructor(t){(0,tR._)(this,"featureName",iG.name),(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"to",a2(async(t,e,r,a)=>await this.getClaimTransaction(t,e,r,a))),this.contractWrapper=t}async getClaimTransaction(t,e,r,a){let i={};return a&&a.pricePerToken&&(i=await aH(this.contractWrapper,a.pricePerToken,r,a.currencyAddress,a.checkERC20Allowance)),sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"claim",args:[await ex(t),e,r],overrides:i})}}class s9{constructor(t,e){(0,tR._)(this,"featureName",iV.name),(0,tR._)(this,"conditions",void 0),(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"storage",void 0),(0,tR._)(this,"to",a2(async(t,e,r,a)=>await this.conditions.getClaimTransaction(t,e,r,a))),this.contractWrapper=t,this.storage=e;let r=new sb(this.contractWrapper,cs,this.storage);this.conditions=new sF(t,r,this.storage)}}class ot{get chainId(){return this._chainId}constructor(t,e,r){var a=this;(0,tR._)(this,"featureName",i0.name),(0,tR._)(this,"query",void 0),(0,tR._)(this,"mintable",void 0),(0,tR._)(this,"burnable",void 0),(0,tR._)(this,"lazyMintable",void 0),(0,tR._)(this,"signatureMintable",void 0),(0,tR._)(this,"claimWithConditions",void 0),(0,tR._)(this,"claimCustom",void 0),(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"storage",void 0),(0,tR._)(this,"_chainId",void 0),(0,tR._)(this,"transfer",a2(async function(t,e,r){let i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[0],n=await a.contractWrapper.getSignerAddress();return sy.fromContractWrapper({contractWrapper:a.contractWrapper,method:"safeTransferFrom",args:[n,await ex(t),e,r,i]})})),(0,tR._)(this,"setApprovalForAll",a2(async(t,e)=>sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setApprovalForAll",args:[t,e]}))),(0,tR._)(this,"airdrop",a2(async function(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[0],i=await a.contractWrapper.getSignerAddress(),n=await a.balanceOf(i,t),s=await s0.parseAsync(e),o=s.reduce((t,e)=>t+Number(e?.quantity||1),0);if(n.toNumber()<o)throw Error(`The caller owns ${n.toNumber()} NFTs, but wants to airdrop ${o} NFTs.`);let c=s.map(e=>{let{address:n,quantity:s}=e;return a.contractWrapper.readContract.interface.encodeFunctionData("safeTransferFrom",[i,n,t,s,r])});return sy.fromContractWrapper({contractWrapper:a.contractWrapper,method:"multicall",args:[c]})})),(0,tR._)(this,"mint",a2(async t=>this.mintTo.prepare(await this.contractWrapper.getSignerAddress(),t))),(0,tR._)(this,"mintTo",a2(async(t,e)=>nq(this.mintable,iQ).to.prepare(t,e))),(0,tR._)(this,"mintAdditionalSupply",a2(async(t,e)=>nq(this.mintable,iQ).additionalSupplyTo.prepare(await this.contractWrapper.getSignerAddress(),t,e))),(0,tR._)(this,"mintAdditionalSupplyTo",a2(async(t,e,r)=>nq(this.mintable,iQ).additionalSupplyTo.prepare(t,e,r))),(0,tR._)(this,"mintBatch",a2(async t=>this.mintBatchTo.prepare(await this.contractWrapper.getSignerAddress(),t))),(0,tR._)(this,"mintBatchTo",a2(async(t,e)=>nq(this.mintable?.batch,iK).to.prepare(t,e))),(0,tR._)(this,"burn",a2(async(t,e)=>nq(this.burnable,i$).tokens.prepare(t,e))),(0,tR._)(this,"burnFrom",a2(async(t,e,r)=>nq(this.burnable,i$).from.prepare(t,e,r))),(0,tR._)(this,"burnBatch",a2(async(t,e)=>nq(this.burnable,i$).batch.prepare(t,e))),(0,tR._)(this,"burnBatchFrom",a2(async(t,e,r)=>nq(this.burnable,i$).batchFrom.prepare(t,e,r))),(0,tR._)(this,"lazyMint",a2(async(t,e)=>nq(this.lazyMintable,iZ).lazyMint.prepare(t,e))),(0,tR._)(this,"claim",a2(async(t,e,r)=>this.claimTo.prepare(await this.contractWrapper.getSignerAddress(),t,e,r))),(0,tR._)(this,"claimTo",a2(async(t,e,r,a)=>{let i=this.claimWithConditions,n=this.claimCustom;if(i)return i.to.prepare(t,e,r,a);if(n)return n.to.prepare(t,e,r,a);throw new r4(iG)})),this.contractWrapper=t,this.storage=e,this.query=this.detectErc1155Enumerable(),this.mintable=this.detectErc1155Mintable(),this.burnable=this.detectErc1155Burnable(),this.lazyMintable=this.detectErc1155LazyMintable(),this.signatureMintable=this.detectErc1155SignatureMintable(),this.claimCustom=this.detectErc1155Claimable(),this.claimWithConditions=this.detectErc1155ClaimableWithConditions(),this._chainId=r}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.readContract.address}async get(t){let[e,r]=await Promise.all([this.contractWrapper.readContract.totalSupply(t).catch(()=>T.O$.from(0)),this.getTokenMetadata(t).catch(()=>({id:t.toString(),uri:"",...sA}))]);return{owner:C.d,metadata:r,type:"ERC1155",supply:e.toString()}}async totalSupply(t){return await this.contractWrapper.readContract.totalSupply(t)}async balanceOf(t,e){return await this.contractWrapper.readContract.balanceOf(await ex(t),e)}async balance(t){return await this.balanceOf(await this.contractWrapper.getSignerAddress(),t)}async isApproved(t,e){return await this.contractWrapper.readContract.isApprovedForAll(await ex(t),await ex(e))}async nextTokenIdToMint(){if(nG("nextTokenIdToMint",this.contractWrapper))return await this.contractWrapper.readContract.nextTokenIdToMint();throw Error("Contract requires the `nextTokenIdToMint` function available to determine the next token ID to mint")}async getAll(t){return nq(this.query,iX).all(t)}async totalCount(){return nq(this.query,iX).totalCount()}async totalCirculatingSupply(t){return nq(this.query,iX).totalCirculatingSupply(t)}async getOwned(t){return t&&(t=await ex(t)),nq(this.query,iX).owned(t)}async getMintTransaction(t,e){return nq(this.mintable,iQ).getMintTransaction(t,e)}async getClaimTransaction(t,e,r,a){let i=this.claimWithConditions,n=this.claimCustom;if(i)return i.conditions.getClaimTransaction(t,e,r,a);if(n)return n.getClaimTransaction(t,e,r,a);throw new r4(iG)}get claimConditions(){return nq(this.claimWithConditions,iV).conditions}get signature(){return nq(this.signatureMintable,iY)}get revealer(){return nq(this.lazyMintable?.revealer,iH)}async getTokenMetadata(t){let e=await this.contractWrapper.readContract.uri(t);if(!e)throw new r0;return sk(t,e,this.storage)}detectErc1155Enumerable(){if(nj(this.contractWrapper,"ERC1155Enumerable"))return new s2(this,this.contractWrapper)}detectErc1155Mintable(){if(nj(this.contractWrapper,"ERC1155Mintable"))return new s3(this,this.contractWrapper,this.storage)}detectErc1155Burnable(){if(nj(this.contractWrapper,"ERC1155Burnable"))return new s1(this.contractWrapper)}detectErc1155LazyMintable(){if(nj(this.contractWrapper,"ERC1155LazyMintableV1")||nj(this.contractWrapper,"ERC1155LazyMintableV2"))return new s6(this,this.contractWrapper,this.storage)}detectErc1155SignatureMintable(){if(nj(this.contractWrapper,"ERC1155SignatureMintable"))return new s4(this.contractWrapper,this.storage)}detectErc1155Claimable(){if(nj(this.contractWrapper,"ERC1155ClaimCustom"))return new s7(this.contractWrapper)}detectErc1155ClaimableWithConditions(){if(nj(this.contractWrapper,"ERC1155ClaimConditionsV1")||nj(this.contractWrapper,"ERC1155ClaimConditionsV2")||nj(this.contractWrapper,"ERC1155ClaimPhasesV1")||nj(this.contractWrapper,"ERC1155ClaimPhasesV2"))return new s9(this.contractWrapper,this.storage)}}async function oe(t,e,r,a,i){try{let n=new F.CH(r,tX,t),s=await n.supportsInterface(eg),o=await n.supportsInterface(ey);if(s){let c;let l=new F.CH(r,tn,t),d=await l.isApprovedForAll(i,e);if(d)return!0;try{c=await l.getApproved(a)}catch(p){}return c?.toLowerCase()===e.toLowerCase()}if(!o)return console.error("Contract does not implement ERC 1155 or ERC 721."),!1;{let f=new F.CH(r,tb,t);return await f.isApprovedForAll(i,e)}}catch(h){return console.error("Failed to check if token is approved",h),!1}}async function or(t,e,r,a,i){let n=new ak(t.getSignerOrProvider(),r,tX,t.options),s=await n.readContract.supportsInterface(eg),o=await n.readContract.supportsInterface(ey);if(s){let c=new ak(t.getSignerOrProvider(),r,tn,t.options),l=await c.readContract.isApprovedForAll(i,e);if(!l){let d=(await c.readContract.getApproved(a)).toLowerCase()===e.toLowerCase();d||await c.sendTransaction("setApprovalForAll",[e,!0])}}else if(o){let p=new ak(t.getSignerOrProvider(),r,tb,t.options),f=await p.readContract.isApprovedForAll(i,e);f||await p.sendTransaction("setApprovalForAll",[e,!0])}else throw Error("Contract must implement ERC 1155 or ERC 721.")}function oa(t){(0,tH.Z)(void 0!==t.assetContractAddress&&null!==t.assetContractAddress,"Asset contract address is required"),(0,tH.Z)(void 0!==t.buyoutPricePerToken&&null!==t.buyoutPricePerToken,"Buyout price is required"),(0,tH.Z)(void 0!==t.listingDurationInSeconds&&null!==t.listingDurationInSeconds,"Listing duration is required"),(0,tH.Z)(void 0!==t.startTimestamp&&null!==t.startTimestamp,"Start time is required"),(0,tH.Z)(void 0!==t.tokenId&&null!==t.tokenId,"Token ID is required"),(0,tH.Z)(void 0!==t.quantity&&null!==t.quantity,"Quantity is required"),"NewAuctionListing"===t.type&&(0,tH.Z)(void 0!==t.reservePricePerToken&&null!==t.reservePricePerToken,"Reserve price is required")}async function oi(t,e,r){return{quantity:r.quantityDesired,pricePerToken:r.pricePerToken,currencyContractAddress:r.currency,buyerAddress:r.offeror,quantityDesired:r.quantityWanted,currencyValue:await aP(t,r.currency,r.quantityWanted.mul(r.pricePerToken)),listingId:e}}function on(t,e,r){if(r=T.O$.from(r),t=T.O$.from(t),e=T.O$.from(e),t.eq(T.O$.from(0)))return!1;let a=e.sub(t).mul(tR.M).div(t);return a.gte(r)}async function os(t,e,r){let a=[];for(;e-t>tR.c;)a.push(r(t,t+tR.c-1)),t+=tR.c;return a.push(r(t,e-1)),await Promise.all(a)}let oo=tN.z.object({assetContractAddress:eR,tokenId:eF,quantity:eF.default(1),currencyContractAddress:eR.default(ew),pricePerToken:tR.A,startTimestamp:eN.default(new Date),endTimestamp:eM,isReservedListing:tN.z.boolean().default(!1)});class oc{constructor(t){(0,tR._)(this,"contractWrapper",void 0),this.contractWrapper=t}addTransactionListener(t){this.contractWrapper.addListener(eW.Transaction,t)}removeTransactionListener(t){this.contractWrapper.off(eW.Transaction,t)}addEventListener(t,e){let r=this.contractWrapper.readContract.interface.getEvent(t),a=this.contractWrapper.readContract.address,i={address:a,topics:[this.contractWrapper.readContract.interface.getEventTopic(r)]},n=t=>{let r=this.contractWrapper.readContract.interface.parseLog(t);e(this.toContractEvent(r.eventFragment,r.args,t))};return this.contractWrapper.getProvider().on(i,n),()=>{this.contractWrapper.getProvider().off(i,n)}}listenToAllEvents(t){let e=this.contractWrapper.readContract.address,r={address:e},a=e=>{try{let r=this.contractWrapper.readContract.interface.parseLog(e);t(this.toContractEvent(r.eventFragment,r.args,e))}catch(a){console.error("Could not parse event:",e,a)}};return this.contractWrapper.getProvider().on(r,a),()=>{this.contractWrapper.getProvider().off(r,a)}}removeEventListener(t,e){let r=this.contractWrapper.readContract.interface.getEvent(t);this.contractWrapper.readContract.off(r.name,e)}removeAllListeners(){this.contractWrapper.readContract.removeAllListeners();let t=this.contractWrapper.readContract.address;this.contractWrapper.getProvider().removeAllListeners({address:t})}async getAllEvents(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{fromBlock:0,toBlock:"latest",order:"desc"},e=await this.contractWrapper.readContract.queryFilter({},t.fromBlock,t.toBlock),r=e.sort((e,r)=>"desc"===t.order?r.blockNumber-e.blockNumber:e.blockNumber-r.blockNumber);return this.parseEvents(r)}async getEvents(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{fromBlock:0,toBlock:"latest",order:"desc"},r=this.contractWrapper.readContract.interface.getEvent(t),a=this.contractWrapper.readContract.interface.getEvent(t),i=e.filters?a.inputs.map(t=>e.filters[t.name]):[],n=this.contractWrapper.readContract.filters[r.name](...i),s=await this.contractWrapper.readContract.queryFilter(n,e.fromBlock,e.toBlock),o=s.sort((t,r)=>"desc"===e.order?r.blockNumber-t.blockNumber:t.blockNumber-r.blockNumber);return this.parseEvents(o)}parseEvents(t){return t.map(t=>{let e=Object.fromEntries(Object.entries(t).filter(t=>"function"!=typeof t[1]&&"args"!==t[0]));if(t.args){let r=Object.entries(t.args),a=r.slice(r.length/2,r.length),i={};for(let[n,s]of a)i[n]=s;return{eventName:t.event||"",data:i,transaction:e}}return{eventName:t.event||"",data:{},transaction:e}})}toContractEvent(t,e,r){let a=Object.fromEntries(Object.entries(r).filter(t=>"function"!=typeof t[1]&&"args"!==t[0])),i={};return t.inputs.forEach((t,r)=>{if(Array.isArray(e[r])){let a=t.components;if(a){let n=e[r];if("tuple[]"===t.type){let s=[];for(let o=0;o<n.length;o++){let c=n[o],l={};for(let d=0;d<a.length;d++){let p=a[d].name;l[p]=c[d]}s.push(l)}i[t.name]=s}else{let f={};for(let h=0;h<a.length;h++){let u=a[h].name;f[u]=n[h]}i[t.name]=f}}}else i[t.name]=e[r]}),{eventName:t.name,data:i,transaction:a}}}class ol{constructor(t){(0,tR._)(this,"contractWrapper",void 0),this.contractWrapper=t}overrideNextTransaction(t){this.contractWrapper.withTransactionOverride(t)}}class od{constructor(t){(0,tR._)(this,"contractWrapper",void 0),this.contractWrapper=t}async gasCostOf(t,e){let r=await this.contractWrapper.getPreferredGasPrice(),a=await this.contractWrapper.estimateGas(t,e);return B.formatEther(a.mul(r))}async gasLimitOf(t,e){return this.contractWrapper.estimateGas(t,e)}async currentGasPriceInGwei(){let t=await this.contractWrapper.getProvider().getGasPrice();return B.formatUnits(t,"gwei")}}class op{constructor(t,e){(0,tR._)(this,"featureName",ip.name),(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"storage",void 0),(0,tR._)(this,"events",void 0),(0,tR._)(this,"interceptor",void 0),(0,tR._)(this,"encoder",void 0),(0,tR._)(this,"estimator",void 0),(0,tR._)(this,"createListing",a2(async t=>{let e=await oo.parseAsync(t);await or(this.contractWrapper,this.getAddress(),e.assetContractAddress,e.tokenId,await this.contractWrapper.getSignerAddress());let r=await aS(this.contractWrapper.getProvider(),e.pricePerToken,e.currencyContractAddress),a=await this.contractWrapper.getProvider().getBlock("latest"),i=a.timestamp;return e.startTimestamp.lt(i)&&(e.startTimestamp=T.O$.from(i)),sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"createListing",args:[{assetContract:e.assetContractAddress,tokenId:e.tokenId,quantity:e.quantity,currency:aT(e.currencyContractAddress),pricePerToken:r,startTimestamp:e.startTimestamp,endTimestamp:e.endTimestamp,reserved:e.isReservedListing}],parse:t=>{let e=this.contractWrapper.parseLogs("NewListing",t?.logs);return{id:e[0].args.listingId,receipt:t}}})})),(0,tR._)(this,"createListingsBatch",a2(async t=>{let e=await Promise.all(t.map(async t=>{let e=await this.createListing.prepare(t);return e.encode()}));return sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[e],parse:t=>{let e=this.contractWrapper.parseLogs("NewListing",t?.logs);return e.map(e=>({id:e.args.listingId,receipt:t}))}})})),(0,tR._)(this,"updateListing",a2(async(t,e)=>{let r=await oo.parseAsync(e);await or(this.contractWrapper,this.getAddress(),r.assetContractAddress,r.tokenId,await this.contractWrapper.getSignerAddress());let a=await aS(this.contractWrapper.getProvider(),r.pricePerToken,r.currencyContractAddress);return sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"updateListing",args:[t,{assetContract:r.assetContractAddress,tokenId:r.tokenId,quantity:r.quantity,currency:aT(r.currencyContractAddress),pricePerToken:a,startTimestamp:r.startTimestamp,endTimestamp:r.endTimestamp,reserved:r.isReservedListing}],parse:t=>{let e=this.contractWrapper.parseLogs("UpdatedListing",t?.logs);return{id:e[0].args.listingId,receipt:t}}})})),(0,tR._)(this,"cancelListing",a2(async t=>sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"cancelListing",args:[t]}))),(0,tR._)(this,"buyFromListing",a2(async(t,e,r)=>{r&&(r=await ex(r));let a=await this.validateListing(T.O$.from(t)),{valid:i,error:n}=await this.isStillValidListing(a,e);if(!i)throw Error(`Listing ${t} is no longer valid. ${n}`);let s=r||await this.contractWrapper.getSignerAddress(),o=T.O$.from(e),c=T.O$.from(a.pricePerToken).mul(o),l=await this.contractWrapper.getCallOverrides()||{};return await ax(this.contractWrapper,c,a.currencyContractAddress,l),sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"buyFromListing",args:[t,s,o,a.currencyContractAddress,c],overrides:l})})),(0,tR._)(this,"approveBuyerForReservedListing",a2(async(t,e)=>{let r=await this.isBuyerApprovedForListing(t,e);if(!r)return sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approveBuyerForListing",args:[t,e,!0]});throw Error(`Buyer ${e} already approved for listing ${t}.`)})),(0,tR._)(this,"revokeBuyerApprovalForReservedListing",a2(async(t,e)=>{let r=await this.isBuyerApprovedForListing(t,e);if(r)return sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approveBuyerForListing",args:[t,e,!1]});throw Error(`Buyer ${e} not approved for listing ${t}.`)})),(0,tR._)(this,"approveCurrencyForListing",a2(async(t,e,r)=>{let a=await this.validateListing(T.O$.from(t)),i=await ex(e);i===a.currencyContractAddress&&(0,tH.Z)(r===a.pricePerToken,"Approving listing currency with a different price.");let n=await this.contractWrapper.readContract.currencyPriceForListing(t,i);return(0,tH.Z)(r===n,"Currency already approved with this price."),sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approveCurrencyForListing",args:[t,i,r]})})),(0,tR._)(this,"revokeCurrencyApprovalForListing",a2(async(t,e)=>{let r=await this.validateListing(T.O$.from(t)),a=await ex(e);if(a===r.currencyContractAddress)throw Error("Can't revoke approval for main listing currency.");let i=await this.contractWrapper.readContract.currencyPriceForListing(t,a);return(0,tH.Z)(!i.isZero(),"Currency not approved."),sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approveCurrencyForListing",args:[t,a,T.O$.from(0)]})})),this.contractWrapper=t,this.storage=e,this.events=new oc(this.contractWrapper),this.encoder=new a0(this.contractWrapper),this.interceptor=new ol(this.contractWrapper),this.estimator=new od(this.contractWrapper)}getAddress(){return this.contractWrapper.readContract.address}async getTotalCount(){return await this.contractWrapper.readContract.totalListings()}async getAll(t){let e=await this.getTotalCount(),r=T.O$.from(t?.start||0).toNumber(),a=e.toNumber();if(0===a)throw Error("No listings exist on the contract.");let i=[];i=(await os(r,a,this.contractWrapper.readContract.getAllListings)).flat();let n=await this.applyFilter(i,t);return await Promise.all(n.map(t=>this.mapListing(t)))}async getAllValid(t){let e=await this.getTotalCount(),r=T.O$.from(t?.start||0).toNumber(),a=e.toNumber();if(0===a)throw Error("No listings exist on the contract.");let i=[];i=(await os(r,a,this.contractWrapper.readContract.getAllValidListings)).flat();let n=await this.applyFilter(i,t);return await Promise.all(n.map(t=>this.mapListing(t)))}async getListing(t){let e=await this.contractWrapper.readContract.getListing(t);return await this.mapListing(e)}async isBuyerApprovedForListing(t,e){let r=await this.validateListing(T.O$.from(t));if(!r.isReservedListing)throw Error(`Listing ${t} is not a reserved listing.`);return await this.contractWrapper.readContract.isBuyerApprovedForListing(t,await ex(e))}async isCurrencyApprovedForListing(t,e){return await this.validateListing(T.O$.from(t)),await this.contractWrapper.readContract.isCurrencyApprovedForListing(t,await ex(e))}async currencyPriceForListing(t,e){let r=await this.validateListing(T.O$.from(t)),a=await ex(e);if(a===r.currencyContractAddress)return r.pricePerToken;let i=await this.isCurrencyApprovedForListing(t,a);if(!i)throw Error(`Currency ${a} is not approved for Listing ${t}.`);return await this.contractWrapper.readContract.currencyPriceForListing(t,a)}async validateListing(t){try{return await this.getListing(t)}catch(e){throw console.error(`Error getting the listing with id ${t}`),e}}async mapListing(t){let e=sx.UNSET,r=await this.contractWrapper.getProvider().getBlock("latest"),a=r.timestamp;switch(t.status){case 1:e=T.O$.from(t.startTimestamp).gt(a)?sx.Created:T.O$.from(t.endTimestamp).lt(a)?sx.Expired:sx.Active;break;case 2:e=sx.Completed;break;case 3:e=sx.Cancelled}return{assetContractAddress:t.assetContract,currencyContractAddress:t.currency,pricePerToken:t.pricePerToken.toString(),currencyValuePerToken:await aP(this.contractWrapper.getProvider(),t.currency,t.pricePerToken),id:t.listingId.toString(),tokenId:t.tokenId.toString(),quantity:t.quantity.toString(),startTimeInSeconds:T.O$.from(t.startTimestamp).toNumber(),asset:await sE(t.assetContract,this.contractWrapper.getProvider(),t.tokenId,this.storage),endTimeInSeconds:T.O$.from(t.endTimestamp).toNumber(),creatorAddress:t.listingCreator,isReservedListing:t.reserved,status:e}}async isStillValidListing(t,e){let r=await oe(this.contractWrapper.getProvider(),this.getAddress(),t.assetContractAddress,t.tokenId,t.creatorAddress);if(!r)return{valid:!1,error:`Token '${t.tokenId}' from contract '${t.assetContractAddress}' is not approved for transfer`};let a=this.contractWrapper.getProvider(),i=new F.CH(t.assetContractAddress,tX,a),n=await i.supportsInterface(eg),s=await i.supportsInterface(ey);if(n){let o;let c=new F.CH(t.assetContractAddress,tn,a);try{o=await c.ownerOf(t.tokenId)}catch(l){}let d=o?.toLowerCase()===t.creatorAddress.toLowerCase();return{valid:d,error:d?void 0:`Seller is not the owner of Token '${t.tokenId}' from contract '${t.assetContractAddress} anymore'`}}if(!s)return{valid:!1,error:"Contract does not implement ERC 1155 or ERC 721."};{let p=new F.CH(t.assetContractAddress,tb,a),f=await p.balanceOf(t.creatorAddress,t.tokenId),h=f.gte(e||t.quantity);return{valid:h,error:h?void 0:`Seller does not have enough balance of Token '${t.tokenId}' from contract '${t.assetContractAddress} to fulfill the listing`}}}async applyFilter(t,e){let r=[...t];if(e){if(e.seller){let a=await ex(e.seller);r=r.filter(t=>t.listingCreator.toString().toLowerCase()===a?.toString().toLowerCase())}if(e.tokenContract){let i=await ex(e.tokenContract);r=r.filter(t=>t.assetContract.toString().toLowerCase()===i?.toString().toLowerCase())}void 0!==e.tokenId&&(r=r.filter(t=>t.tokenId.toString()===e?.tokenId?.toString()))}return e?.count&&e.count<r.length?r.slice(0,e.count):r}}let of=tN.z.object({assetContractAddress:eR,tokenId:eF,quantity:eF.default(1),currencyContractAddress:eR.default(ew),minimumBidAmount:tR.A,buyoutBidAmount:tR.A,timeBufferInSeconds:eF.default(900),bidBufferBps:eF.default(500),startTimestamp:eN.default(new Date),endTimestamp:eM});class oh{constructor(t,e){(0,tR._)(this,"featureName",ih.name),(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"storage",void 0),(0,tR._)(this,"events",void 0),(0,tR._)(this,"interceptor",void 0),(0,tR._)(this,"encoder",void 0),(0,tR._)(this,"estimator",void 0),(0,tR._)(this,"createAuction",a2(async t=>{let e=of.parse(t);await or(this.contractWrapper,this.getAddress(),e.assetContractAddress,e.tokenId,await this.contractWrapper.getSignerAddress());let r=await aS(this.contractWrapper.getProvider(),e.buyoutBidAmount,e.currencyContractAddress),a=await aS(this.contractWrapper.getProvider(),e.minimumBidAmount,e.currencyContractAddress),i=await this.contractWrapper.getProvider().getBlock("latest"),n=i.timestamp;return e.startTimestamp.lt(n)&&(e.startTimestamp=T.O$.from(n)),sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"createAuction",args:[{assetContract:e.assetContractAddress,tokenId:e.tokenId,quantity:e.quantity,currency:aT(e.currencyContractAddress),minimumBidAmount:a,buyoutBidAmount:r,timeBufferInSeconds:e.timeBufferInSeconds,bidBufferBps:e.bidBufferBps,startTimestamp:e.startTimestamp,endTimestamp:e.endTimestamp}],parse:t=>{let e=this.contractWrapper.parseLogs("NewAuction",t.logs)[0];return{id:e.args.auctionId,receipt:t}}})})),(0,tR._)(this,"createAuctionsBatch",a2(async t=>{let e=await Promise.all(t.map(async t=>{let e=await this.createAuction.prepare(t);return e.encode()}));return sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[e],parse:t=>{let e=this.contractWrapper.parseLogs("NewAuction",t?.logs);return e.map(e=>({id:e.args.auctionId,receipt:t}))}})})),(0,tR._)(this,"buyoutAuction",a2(async t=>{let e=await this.validateAuction(T.O$.from(t)),r=await a_(this.contractWrapper.getProvider(),e.currencyContractAddress);return this.makeBid.prepare(t,B.formatUnits(e.buyoutBidAmount,r.decimals))})),(0,tR._)(this,"makeBid",a2(async(t,e)=>{let r=await this.validateAuction(T.O$.from(t)),a=await aS(this.contractWrapper.getProvider(),e,r.currencyContractAddress);if(a.eq(T.O$.from(0)))throw Error("Cannot make a bid with 0 value");if(T.O$.from(r.buyoutBidAmount).gt(0)&&a.gt(r.buyoutBidAmount))throw Error("Bid amount must be less than or equal to buyoutBidAmount");let i=await this.getWinningBid(t);if(i){let n=await this.isWinningBid(t,a);(0,tH.Z)(n,"Bid price is too low based on the current winning bid and the bid buffer")}else{let s=T.O$.from(r.minimumBidAmount);(0,tH.Z)(a.gte(s),"Bid price is too low based on minimum bid amount")}let o=await this.contractWrapper.getCallOverrides()||{};return await ax(this.contractWrapper,a,r.currencyContractAddress,o),sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"bidInAuction",args:[t,a],overrides:o})})),(0,tR._)(this,"cancelAuction",a2(async t=>{let e=await this.getWinningBid(t);if(e)throw Error("Bids already made.");return sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"cancelAuction",args:[t]})})),(0,tR._)(this,"closeAuctionForBidder",a2(async(t,e)=>{e||(e=await this.contractWrapper.getSignerAddress());let r=await this.validateAuction(T.O$.from(t));try{return sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"collectAuctionTokens",args:[T.O$.from(t)]})}catch(a){if(a.message.includes("Marketplace: auction still active."))throw new r3(t.toString(),r.endTimeInSeconds.toString());throw a}})),(0,tR._)(this,"closeAuctionForSeller",a2(async t=>{let e=await this.validateAuction(T.O$.from(t));try{return sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"collectAuctionPayout",args:[T.O$.from(t)]})}catch(r){if(r.message.includes("Marketplace: auction still active."))throw new r3(t.toString(),e.endTimeInSeconds.toString());throw r}})),(0,tR._)(this,"executeSale",a2(async t=>{let e=await this.validateAuction(T.O$.from(t));try{let r=await this.getWinningBid(t);(0,tH.Z)(r,"No winning bid found");let a=this.encoder.encode("collectAuctionPayout",[t]),i=this.encoder.encode("collectAuctionTokens",[t]);return sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[[a,i]]})}catch(n){if(n.message.includes("Marketplace: auction still active."))throw new r3(t.toString(),e.endTimeInSeconds.toString());throw n}})),this.contractWrapper=t,this.storage=e,this.events=new oc(this.contractWrapper),this.encoder=new a0(this.contractWrapper),this.interceptor=new ol(this.contractWrapper),this.estimator=new od(this.contractWrapper)}getAddress(){return this.contractWrapper.readContract.address}async getTotalCount(){return await this.contractWrapper.readContract.totalAuctions()}async getAll(t){let e=await this.getTotalCount(),r=T.O$.from(t?.start||0).toNumber(),a=e.toNumber();if(0===a)throw Error("No auctions exist on the contract.");let i=[];i=(await os(r,a,this.contractWrapper.readContract.getAllAuctions)).flat();let n=await this.applyFilter(i,t);return await Promise.all(n.map(t=>this.mapAuction(t)))}async getAllValid(t){let e=await this.getTotalCount(),r=T.O$.from(t?.start||0).toNumber(),a=e.toNumber();if(0===a)throw Error("No auctions exist on the contract.");let i=[];i=(await os(r,a,this.contractWrapper.readContract.getAllValidAuctions)).flat();let n=await this.applyFilter(i,t);return await Promise.all(n.map(t=>this.mapAuction(t)))}async getAuction(t){let e=await this.contractWrapper.readContract.getAuction(t);return await this.mapAuction(e)}async getWinningBid(t){await this.validateAuction(T.O$.from(t));let e=await this.contractWrapper.readContract.getWinningBid(t);if(e._bidder!==C.d)return await this.mapBid(t.toString(),e._bidder,e._currency,e._bidAmount.toString())}async isWinningBid(t,e){return await this.contractWrapper.readContract.isNewWinningBid(t,e)}async getWinner(t){let e=await this.validateAuction(T.O$.from(t)),r=await this.contractWrapper.readContract.getWinningBid(t),a=T.O$.from(Math.floor(Date.now()/1e3)),i=T.O$.from(e.endTimeInSeconds);if(a.gt(i)&&r._bidder!==C.d)return r._bidder;let n=await this.contractWrapper.readContract.queryFilter(this.contractWrapper.readContract.filters.AuctionClosed()),s=n.find(e=>e.args.auctionId.eq(T.O$.from(t)));if(!s)throw Error(`Could not find auction with ID ${t} in closed auctions`);return s.args.winningBidder}async getBidBufferBps(t){return(await this.getAuction(t)).bidBufferBps}async getMinimumNextBid(t){let[e,r,a]=await Promise.all([this.getBidBufferBps(t),this.getWinningBid(t),await this.validateAuction(T.O$.from(t))]),i=r?T.O$.from(r.bidAmount):T.O$.from(a.minimumBidAmount),n=i.add(i.mul(e).div(1e4));return aP(this.contractWrapper.getProvider(),a.currencyContractAddress,n)}async validateAuction(t){try{return await this.getAuction(t)}catch(e){throw console.error(`Error getting the auction with id ${t}`),e}}async mapAuction(t){let e=sx.UNSET,r=await this.contractWrapper.getProvider().getBlock("latest"),a=r.timestamp;switch(t.status){case 1:e=T.O$.from(t.startTimestamp).gt(a)?sx.Created:T.O$.from(t.endTimestamp).lt(a)?sx.Expired:sx.Active;break;case 2:e=sx.Completed;break;case 3:e=sx.Cancelled}return{id:t.auctionId.toString(),creatorAddress:t.auctionCreator,assetContractAddress:t.assetContract,tokenId:t.tokenId.toString(),quantity:t.quantity.toString(),currencyContractAddress:t.currency,minimumBidAmount:t.minimumBidAmount.toString(),minimumBidCurrencyValue:await aP(this.contractWrapper.getProvider(),t.currency,t.minimumBidAmount),buyoutBidAmount:t.buyoutBidAmount.toString(),buyoutCurrencyValue:await aP(this.contractWrapper.getProvider(),t.currency,t.buyoutBidAmount),timeBufferInSeconds:T.O$.from(t.timeBufferInSeconds).toNumber(),bidBufferBps:T.O$.from(t.bidBufferBps).toNumber(),startTimeInSeconds:T.O$.from(t.startTimestamp).toNumber(),endTimeInSeconds:T.O$.from(t.endTimestamp).toNumber(),asset:await sE(t.assetContract,this.contractWrapper.getProvider(),t.tokenId,this.storage),status:e}}async mapBid(t,e,r,a){let i=await ex(e),n=await ex(r);return{auctionId:t,bidderAddress:i,currencyContractAddress:n,bidAmount:a,bidAmountCurrencyValue:await aP(this.contractWrapper.getProvider(),n,a)}}async applyFilter(t,e){let r=[...t];if(e){if(e.seller){let a=await ex(e.seller);r=r.filter(t=>t.auctionCreator.toString().toLowerCase()===a?.toString().toLowerCase())}if(e.tokenContract){let i=await ex(e.tokenContract);r=r.filter(t=>t.assetContract.toString().toLowerCase()===i?.toString().toLowerCase())}void 0!==e.tokenId&&(r=r.filter(t=>t.tokenId.toString()===e?.tokenId?.toString()))}return e?.count&&e.count<r.length?r.slice(0,e.count):r}}let ou=tN.z.object({assetContractAddress:eR,tokenId:eF,quantity:eF.default(1),currencyContractAddress:eR.default(ew),totalPrice:tR.A,endTimestamp:eM});class om{constructor(t,e){(0,tR._)(this,"featureName",iu.name),(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"storage",void 0),(0,tR._)(this,"events",void 0),(0,tR._)(this,"interceptor",void 0),(0,tR._)(this,"encoder",void 0),(0,tR._)(this,"estimator",void 0),(0,tR._)(this,"makeOffer",a2(async t=>{let e=await ou.parseAsync(t),r=await this.contractWrapper.getChainID(),a=aE(e.currencyContractAddress)?eb[r].wrapped.address:e.currencyContractAddress,i=await aS(this.contractWrapper.getProvider(),e.totalPrice,a),n=await this.contractWrapper.getCallOverrides();return await ax(this.contractWrapper,i,a,n),sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"makeOffer",args:[{assetContract:e.assetContractAddress,tokenId:e.tokenId,quantity:e.quantity,currency:a,totalPrice:i,expirationTimestamp:e.endTimestamp}],parse:t=>{let e=this.contractWrapper.parseLogs("NewOffer",t?.logs);return{id:e[0].args.offerId,receipt:t}}})})),(0,tR._)(this,"cancelOffer",a2(async t=>sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"cancelOffer",args:[t]}))),(0,tR._)(this,"acceptOffer",a2(async t=>{let e=await this.validateOffer(T.O$.from(t)),{valid:r,error:a}=await this.isStillValidOffer(e);if(!r)throw Error(`Offer ${t} is no longer valid. ${a}`);let i=await this.contractWrapper.getCallOverrides()||{};return await or(this.contractWrapper,this.getAddress(),e.assetContractAddress,e.tokenId,await this.contractWrapper.getSignerAddress()),sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"acceptOffer",args:[t],overrides:i})})),this.contractWrapper=t,this.storage=e,this.events=new oc(this.contractWrapper),this.encoder=new a0(this.contractWrapper),this.interceptor=new ol(this.contractWrapper),this.estimator=new od(this.contractWrapper)}getAddress(){return this.contractWrapper.readContract.address}async getTotalCount(){return await this.contractWrapper.readContract.totalOffers()}async getAll(t){let e=await this.getTotalCount(),r=T.O$.from(t?.start||0).toNumber(),a=e.toNumber();if(0===a)throw Error("No offers exist on the contract.");let i=[];i=(await os(r,a,this.contractWrapper.readContract.getAllOffers)).flat();let n=await this.applyFilter(i,t);return await Promise.all(n.map(t=>this.mapOffer(t)))}async getAllValid(t){let e=await this.getTotalCount(),r=T.O$.from(t?.start||0).toNumber(),a=e.toNumber();if(0===a)throw Error("No offers exist on the contract.");let i=[];i=(await os(r,a,this.contractWrapper.readContract.getAllValidOffers)).flat();let n=await this.applyFilter(i,t);return await Promise.all(n.map(t=>this.mapOffer(t)))}async getOffer(t){let e=await this.contractWrapper.readContract.getOffer(t);return await this.mapOffer(e)}async validateOffer(t){try{return await this.getOffer(t)}catch(e){throw console.error(`Error getting the offer with id ${t}`),e}}async mapOffer(t){let e=sx.UNSET,r=await this.contractWrapper.getProvider().getBlock("latest"),a=r.timestamp;switch(t.status){case 1:e=T.O$.from(t.expirationTimestamp).lt(a)?sx.Expired:sx.Active;break;case 2:e=sx.Completed;break;case 3:e=sx.Cancelled}return{id:t.offerId.toString(),offerorAddress:t.offeror,assetContractAddress:t.assetContract,currencyContractAddress:t.currency,tokenId:t.tokenId.toString(),quantity:t.quantity.toString(),totalPrice:t.totalPrice.toString(),currencyValue:await aP(this.contractWrapper.getProvider(),t.currency,t.totalPrice),asset:await sE(t.assetContract,this.contractWrapper.getProvider(),t.tokenId,this.storage),endTimeInSeconds:T.O$.from(t.expirationTimestamp).toNumber(),status:e}}async isStillValidOffer(t){let e=T.O$.from(Math.floor(Date.now()/1e3));if(e.gt(t.endTimeInSeconds))return{valid:!1,error:`Offer with ID ${t.id} has expired`};let r=await this.contractWrapper.getChainID(),a=aE(t.currencyContractAddress)?eb[r].wrapped.address:t.currencyContractAddress,i=this.contractWrapper.getProvider(),n=new ak(i,a,Y,{}),s=await n.readContract.balanceOf(t.offerorAddress);if(s.lt(t.totalPrice))return{valid:!1,error:`Offeror ${t.offerorAddress} doesn't have enough balance of token ${a}`};let o=await n.readContract.allowance(t.offerorAddress,this.getAddress());return o.lt(t.totalPrice)?{valid:!1,error:`Offeror ${t.offerorAddress} hasn't approved enough amount of token ${a}`}:{valid:!0,error:""}}async applyFilter(t,e){let r=[...t];if(e){if(e.offeror){let a=await ex(e.offeror);r=r.filter(t=>t.offeror.toString().toLowerCase()===a?.toString().toLowerCase())}if(e.tokenContract){let i=await ex(e.tokenContract);r=r.filter(t=>t.assetContract.toString().toLowerCase()===i?.toString().toLowerCase())}void 0!==e.tokenId&&(r=r.filter(t=>t.tokenId.toString()===e?.tokenId?.toString()))}return e?.count&&e.count<r.length?r.slice(0,e.count):r}}let og=rn.merge(ej).merge(rp),oy=rs.merge(ej).merge(rp),ow=og.merge(rl).merge(rc).merge(rd),ob={deploy:ow,output:oy,input:og},oC=rn.merge(ro).merge(rp),ov=rs.merge(ro).merge(rp),oW=oC.merge(rd),oA={deploy:oW,output:ov,input:oC},ok={name:"DropERC1155",contractType:"edition-drop",schema:rb,roles:["admin","minter","transfer"],initialize:async function(){for(var t=arguments.length,e=Array(t),a=0;a<t;a++)e[a]=arguments[a];let[i,n,s,o]=e,[,c]=eE(i,o),[l,d,p]=await Promise.all([await ok.getAbi(n,c,s),r.e(1148).then(r.bind(r,11148)),c.getNetwork()]);return new d.EditionDrop(i,n,s,o,l,p.chainId)},async getAbi(t,e,a){let i=await o8(t,e,a);if(i)return i;let n=await oN(t,e);return!n||n.version>2?(await r.e(44).then(r.t.bind(r,50044,19))).default:(await r.e(2876).then(r.t.bind(r,52876,19))).default}},oE={name:"TokenERC1155",contractType:"edition",schema:rV,roles:["admin","minter","transfer"],initialize:async function(){for(var t=arguments.length,e=Array(t),a=0;a<t;a++)e[a]=arguments[a];let[i,n,s,o]=e,[,c]=eE(i,o),[l,d,p]=await Promise.all([oE.getAbi(n,c,s),r.e(4401).then(r.bind(r,34401)),c.getNetwork()]);return new d.Edition(i,n,s,o,l,p.chainId)},async getAbi(t,e,a){let i=await o8(t,e,a);return i||(await r.e(2610).then(r.t.bind(r,22610,19))).default}},oT={name:"Marketplace",contractType:"marketplace",schema:rv,roles:["admin","lister","asset"],initialize:async function(){for(var t=arguments.length,e=Array(t),a=0;a<t;a++)e[a]=arguments[a];let[i,n,s,o]=e,[,c]=eE(i,o),[l,d,p]=await Promise.all([oT.getAbi(n,c,s),r.e(5352).then(r.bind(r,35352)),c.getNetwork()]);return new d.Marketplace(i,n,s,o,l,p.chainId)},async getAbi(t,e,a){let i=await o8(t,e,a);return i||(await r.e(4247).then(r.t.bind(r,94247,19))).default}},oS={name:"MarketplaceV3",contractType:"marketplace-v3",schema:rv,roles:["admin","lister","asset"],initialize:async function(){for(var t=arguments.length,e=Array(t),a=0;a<t;a++)e[a]=arguments[a];let[i,n,s,o]=e,[,c]=eE(i,o),[l,d,p]=await Promise.all([oS.getAbi(n,c,s),r.e(7602).then(r.bind(r,47602)),c.getNetwork()]);return new d.MarketplaceV3(i,n,s,o,l,p.chainId)},async getAbi(t,e,a){let i=await o8(t,e,a);if(i)return await sh(t,i,e,{},a);let n=(await r.e(3792).then(r.t.bind(r,63792,19))).default;return await sh(t,cd.parse(n||[]),e,{},a)}},o_={name:"Multiwrap",contractType:"multiwrap",schema:oA,roles:["admin","transfer","minter","unwrap","asset"],initialize:async function(){for(var t=arguments.length,e=Array(t),a=0;a<t;a++)e[a]=arguments[a];let[i,n,s,o]=e,[,c]=eE(i,o),[l,d,p]=await Promise.all([o_.getAbi(n,c,s),r.e(6848).then(r.bind(r,86848)),c.getNetwork()]);return new d.Multiwrap(i,n,s,o,l,p.chainId)},async getAbi(t,e,a){let i=await o8(t,e,a);return i||(await r.e(6164).then(r.t.bind(r,86164,19))).default}},oP={name:"TokenERC721",contractType:"nft-collection",schema:rM,roles:["admin","minter","transfer"],initialize:async function(){for(var t=arguments.length,e=Array(t),a=0;a<t;a++)e[a]=arguments[a];let[i,n,s,o]=e,[,c]=eE(i,o),[l,d,p]=await Promise.all([oP.getAbi(n,c,s),r.e(477).then(r.bind(r,40477)),c.getNetwork()]);return new d.NFTCollection(i,n,s,o,l,p.chainId)},async getAbi(t,e,a){let i=await o8(t,e,a);return i||(await r.e(8777).then(r.t.bind(r,88777,19))).default}},ox={name:"DropERC721",contractType:"nft-drop",schema:rm,roles:["admin","minter","transfer"],initialize:async function(){for(var t=arguments.length,e=Array(t),a=0;a<t;a++)e[a]=arguments[a];let[i,n,s,o]=e,[,c]=eE(i,o),[l,d,p]=await Promise.all([ox.getAbi(n,c,s),r.e(9687).then(r.bind(r,59687)),c.getNetwork()]);return new d.NFTDrop(i,n,s,o,l,p.chainId)},async getAbi(t,e,a){let i=await o8(t,e,a);if(i)return i;let n=await oN(t,e);return!n||n.version>3?(await r.e(8110).then(r.t.bind(r,88110,19))).default:(await r.e(2328).then(r.t.bind(r,42328,19))).default}},oB={name:"Pack",contractType:"pack",schema:rE,roles:["admin","minter","asset","transfer"],initialize:async function(){for(var t=arguments.length,e=Array(t),a=0;a<t;a++)e[a]=arguments[a];let[i,n,s,o]=e,[,c]=eE(i,o),[l,d,p]=await Promise.all([oB.getAbi(n,c,s),r.e(9793).then(r.bind(r,19793)),c.getNetwork()]);return new d.Pack(i,n,s,o,l,p.chainId)},async getAbi(t,e,a){let i=await o8(t,e,a);return i||cd.parse((await r.e(5236).then(r.t.bind(r,65236,19))).default||[])}},oD={name:"SignatureDrop",contractType:"signature-drop",schema:rm,roles:["admin","minter","transfer"],initialize:async function(){for(var t=arguments.length,e=Array(t),a=0;a<t;a++)e[a]=arguments[a];let[i,n,s,o]=e,[,c]=eE(i,o),[l,d,p]=await Promise.all([oD.getAbi(n,c,s),r.e(8204).then(r.bind(r,48204)),c.getNetwork()]);return new d.SignatureDrop(i,n,s,o,l,p.chainId)},async getAbi(t,e,a){let i=await o8(t,e,a);if(i)return i;let n=await oN(t,e);return!n||n.version>4?(await r.e(3199).then(r.t.bind(r,33199,19))).default:(await r.e(1119).then(r.t.bind(r,51119,19))).default}},oF={name:"Split",contractType:"split",schema:rB,roles:["admin"],initialize:async function(){for(var t=arguments.length,e=Array(t),a=0;a<t;a++)e[a]=arguments[a];let[i,n,s,o]=e,[,c]=eE(i,o),[l,d,p]=await Promise.all([oF.getAbi(n,c,s),r.e(1717).then(r.bind(r,51717)),c.getNetwork()]);return new d.Split(i,n,s,o,l,p.chainId)},async getAbi(t,e,a){let i=await o8(t,e,a);return i||(await r.e(4506).then(r.t.bind(r,64506,19))).default}},oO={name:"DropERC20",contractType:"token-drop",schema:ob,roles:["admin","transfer"],initialize:async function(){for(var t=arguments.length,e=Array(t),a=0;a<t;a++)e[a]=arguments[a];let[i,n,s,o]=e,[,c]=eE(i,o),[l,d,p]=await Promise.all([oO.getAbi(n,c,s),r.e(5303).then(r.bind(r,55303)),c.getNetwork()]);return new d.TokenDrop(i,n,s,o,l,p.chainId)},async getAbi(t,e,a){let i=await o8(t,e,a);if(i)return i;let n=await oN(t,e);return!n||n.version>2?(await r.e(7891).then(r.t.bind(r,37891,19))).default:(await r.e(3565).then(r.t.bind(r,23565,19))).default}},oI={name:"TokenERC20",contractType:"token",schema:rI,roles:["admin","minter","transfer"],initialize:async function(){for(var t=arguments.length,e=Array(t),a=0;a<t;a++)e[a]=arguments[a];let[i,n,s,o]=e,[,c]=eE(i,o),[l,d,p]=await Promise.all([oI.getAbi(n,c,s),r.e(5855).then(r.bind(r,15855)),c.getNetwork()]);return new d.Token(i,n,s,o,l,p.chainId)},async getAbi(t,e,a){let i=await o8(t,e,a);return i||(await r.e(3028).then(r.t.bind(r,83028,19))).default}},oR={name:"VoteERC20",contractType:"vote",schema:rJ,roles:[],initialize:async function(){for(var t=arguments.length,e=Array(t),a=0;a<t;a++)e[a]=arguments[a];let[i,n,s,o]=e,[,c]=eE(i,o),[l,d,p]=await Promise.all([oR.getAbi(n,c,s),r.e(6081).then(r.bind(r,96081)),c.getNetwork()]);return new d.Vote(i,n,s,o,l,p.chainId)},async getAbi(t,e,a){let i=await o8(t,e,a);return i||(await r.e(9695).then(r.t.bind(r,59695,19))).default}};async function oN(t,e){try{return await s5(t,e)}catch(r){return}}let oL={[ok.contractType]:ok,[oE.contractType]:oE,[oT.contractType]:oT,[oS.contractType]:oS,[o_.contractType]:o_,[oP.contractType]:oP,[ox.contractType]:ox,[oB.contractType]:oB,[oD.contractType]:oD,[oF.contractType]:oF,[oO.contractType]:oO,[oI.contractType]:oI,[oR.contractType]:oR},oM={[ok.contractType]:"ipfs://QmNm3wRzpKYWo1SRtJfgfxtvudp5p2nXD6EttcsQJHwTmk",[oE.contractType]:"",[oT.contractType]:"ipfs://QmbAgC8YwY36n8H2kuvSWsRisxDZ15QZw3xGZyk9aDvcv7/marketplace.html",[oS.contractType]:"ipfs://QmbAgC8YwY36n8H2kuvSWsRisxDZ15QZw3xGZyk9aDvcv7/marketplace-v3.html",[o_.contractType]:"",[oP.contractType]:"",[ox.contractType]:"ipfs://QmZptmVipc6SGFbKAyXcxGgohzTwYRXZ9LauRX5ite1xDK",[oB.contractType]:"",[oD.contractType]:"ipfs://QmZptmVipc6SGFbKAyXcxGgohzTwYRXZ9LauRX5ite1xDK",[oF.contractType]:"",[oO.contractType]:"ipfs://QmbAgC8YwY36n8H2kuvSWsRisxDZ15QZw3xGZyk9aDvcv7/erc20.html",[oI.contractType]:"",[oR.contractType]:""},oz={name:"SmartContract",contractType:"custom",schema:{},roles:aQ},o$={...oL,[oz.contractType]:oz};function oU(t){return Object.values(o$).find(e=>e.contractType===t)?.name}async function oV(t,e,r,a,i){let n;let s=await a.getChainId(),o=await a.getAddress(),c=es.find(t=>t===s);if(c)n=t===oB.contractType?[]:em(s);else{let l=await se(a.provider,i);n=[l]}switch(e.trusted_forwarders&&e.trusted_forwarders.length>0&&(n=e.trusted_forwarders),t){case ox.contractType:case oP.contractType:let d=await ox.schema.deploy.parseAsync(e);return[o,d.name,d.symbol,r,n,d.primary_sale_recipient,d.fee_recipient,d.seller_fee_basis_points,d.platform_fee_basis_points,d.platform_fee_recipient];case oD.contractType:let p=await oD.schema.deploy.parseAsync(e);return[o,p.name,p.symbol,r,n,p.primary_sale_recipient,p.fee_recipient,p.seller_fee_basis_points,p.platform_fee_basis_points,p.platform_fee_recipient];case o_.contractType:let f=await o_.schema.deploy.parseAsync(e);return[o,f.name,f.symbol,r,n,f.fee_recipient,f.seller_fee_basis_points];case ok.contractType:case oE.contractType:let h=await ok.schema.deploy.parseAsync(e);return[o,h.name,h.symbol,r,n,h.primary_sale_recipient,h.fee_recipient,h.seller_fee_basis_points,h.platform_fee_basis_points,h.platform_fee_recipient];case oO.contractType:case oI.contractType:let u=await oI.schema.deploy.parseAsync(e);return[o,u.name,u.symbol,r,n,u.primary_sale_recipient,u.platform_fee_recipient,u.platform_fee_basis_points];case oR.contractType:let m=await oR.schema.deploy.parseAsync(e);return[m.name,r,n,m.voting_token_address,m.voting_delay_in_blocks,m.voting_period_in_blocks,T.O$.from(m.proposal_token_threshold),m.voting_quorum_fraction];case oF.contractType:let g=await oF.schema.deploy.parseAsync(e);return[o,r,n,g.recipients.map(t=>t.address),g.recipients.map(t=>T.O$.from(t.sharesBps))];case oT.contractType:case oS.contractType:let y=await oT.schema.deploy.parseAsync(e);return[o,r,n,y.platform_fee_recipient,y.platform_fee_basis_points];case oB.contractType:let w=await oB.schema.deploy.parseAsync(e);return[o,w.name,w.symbol,r,n,w.fee_recipient,w.seller_fee_basis_points];default:return[]}}class oq{constructor(t,e,r){(0,tR._)(this,"featureName",ii.name),(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"metadata",void 0),(0,tR._)(this,"storage",void 0),(0,tR._)(this,"set",a2(async t=>nj(this.contractWrapper,"AppURI")?sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setAppURI",args:[t]}):await this.metadata.update.prepare({app_uri:t}))),this.contractWrapper=t,this.metadata=e,this.storage=r}async get(){return nj(this.contractWrapper,"AppURI")?await this.contractWrapper.readContract.appURI():(0,tq.ov)((await this.metadata.get()).app_uri||"",this.storage.gatewayUrls)}}class oj{constructor(t){(0,tR._)(this,"featureName",it.name),(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"set",a2(async t=>{let e=await rl.parseAsync(t);return sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setPlatformFeeInfo",args:[e.platform_fee_recipient,e.platform_fee_basis_points]})})),this.contractWrapper=t}async get(){let[t,e]=await this.contractWrapper.readContract.getPlatformFeeInfo();return rl.parseAsync({platform_fee_recipient:t,platform_fee_basis_points:e})}}class oG{constructor(t,e){(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"storage",void 0),(0,tR._)(this,"_cachedMetadata",void 0),this.contractWrapper=t,this.storage=e}async get(){return this._cachedMetadata||(this._cachedMetadata=await o6(this.contractWrapper.readContract.address,this.contractWrapper.getProvider(),this.storage)),this._cachedMetadata}async extractFunctions(){let t;try{t=await this.get()}catch(e){}return nI(cd.parse(this.contractWrapper.abi),t?.metadata)}async extractEvents(){let t;try{t=await this.get()}catch(e){}return function(t,e){let r=cd.parse(t||[]),a=r.filter(t=>"event"===t.type),i=[];for(let n of a){let s=nF(n.name,e,"events");i.push({inputs:n.inputs||[],outputs:n.outputs||[],name:n.name||"unknown",comment:s})}return i}(cd.parse(this.contractWrapper.abi),t?.metadata)}}class oH{get royalties(){return nq(this.detectRoyalties(),a7)}get roles(){return nq(this.detectRoles(),ir)}get sales(){return nq(this.detectPrimarySales(),a9)}get platformFees(){return nq(this.detectPlatformFees(),it)}get owner(){return nq(this.detectOwnable(),is)}get erc20(){return nq(this.detectErc20(),ik)}get erc721(){return nq(this.detectErc721(),iz)}get erc1155(){return nq(this.detectErc1155(),i0)}get app(){return nq(this.detectApp(),ii)}get directListings(){return nq(this.detectDirectListings(),ip)}get englishAuctions(){return nq(this.detectEnglishAuctions(),ih)}get offers(){return nq(this.detectOffers(),iu)}get chainId(){return this._chainId}constructor(t,e,r,a){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{},n=arguments.length>5?arguments[5]:void 0,s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:new ak(t,e,r,i);(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"storage",void 0),(0,tR._)(this,"events",void 0),(0,tR._)(this,"interceptor",void 0),(0,tR._)(this,"encoder",void 0),(0,tR._)(this,"estimator",void 0),(0,tR._)(this,"publishedMetadata",void 0),(0,tR._)(this,"abi",void 0),(0,tR._)(this,"metadata",void 0),(0,tR._)(this,"_chainId",void 0),this._chainId=n,this.storage=a,this.contractWrapper=s,this.abi=cd.parse(r||[]),this.events=new oc(this.contractWrapper),this.encoder=new a0(this.contractWrapper),this.interceptor=new ol(this.contractWrapper),this.estimator=new od(this.contractWrapper),this.publishedMetadata=new oG(this.contractWrapper,this.storage),this.metadata=new sb(this.contractWrapper,cs,this.storage)}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.readContract.address}prepare(t,e,r){return sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:t,args:e,overrides:r})}async call(t,e,r){return this.contractWrapper.call(t,e,r)}detectRoyalties(){if(nj(this.contractWrapper,"Royalty")){let t=new sb(this.contractWrapper,cs,this.storage);return new sv(this.contractWrapper,t)}}detectRoles(){if(nj(this.contractWrapper,"Permissions"))return new sC(this.contractWrapper,aQ)}detectPrimarySales(){if(nj(this.contractWrapper,"PrimarySale"))return new sW(this.contractWrapper)}detectPlatformFees(){if(nj(this.contractWrapper,"PlatformFee"))return new oj(this.contractWrapper)}detectErc20(){if(nj(this.contractWrapper,"ERC20"))return new sz(this.contractWrapper,this.storage,this.chainId)}detectErc721(){if(nj(this.contractWrapper,"ERC721"))return new sQ(this.contractWrapper,this.storage,this.chainId)}detectErc1155(){if(nj(this.contractWrapper,"ERC1155"))return new ot(this.contractWrapper,this.storage,this.chainId)}detectOwnable(){if(nj(this.contractWrapper,"Ownable"))return new o1(this.contractWrapper)}detectApp(){let t=new sb(this.contractWrapper,cs,this.storage);return nj(this.contractWrapper,"AppURI")?new oq(this.contractWrapper,t,this.storage):nj(this.contractWrapper,"ContractMetadata")?new oq(this.contractWrapper,t,this.storage):void 0}detectDirectListings(){if(nj(this.contractWrapper,"DirectListings"))return new op(this.contractWrapper,this.storage)}detectEnglishAuctions(){if(nj(this.contractWrapper,"EnglishAuctions"))return new oh(this.contractWrapper,this.storage)}detectOffers(){if(nj(this.contractWrapper,"Offers"))return new om(this.contractWrapper,this.storage)}}class oZ extends aW{constructor(t,e,r){super(t,e),(0,tR._)(this,"storage",void 0),(0,tR._)(this,"publisher",void 0),(0,tR._)(this,"updatePublisherProfile",a2(async t=>{let e=this.getSigner();(0,tH.Z)(e,"A signer is required");let r=await e.getAddress(),a=await this.storage.upload(t);return sy.fromContractWrapper({contractWrapper:this.publisher,method:"setPublisherProfileUri",args:[r,a]})})),(0,tR._)(this,"publish",a2(async(t,e)=>{let r=this.getSigner();(0,tH.Z)(r,"A signer is required");let a=await r.getAddress(),i=await nL(t,this.storage),n=await this.getLatest(a,i.name);if(n&&n.metadataUri){let s=await this.fetchPublishedContractInfo(n),o=s.publishedMetadata.version;if(!function(t,e){let r=ce(t),a=ce(e);if(a.major>r.major)return!0;let i=a.major===r.major;if(i&&a.minor>r.minor)return!0;let n=a.minor===r.minor;return i&&n&&a.patch>r.patch}(o,e.version))throw Error(`Version ${e.version} is not greater than ${o}`)}let c=await (await this.storage.download(i.bytecodeUri)).text(),l=c.startsWith("0x")?c:`0x${c}`,d=I.keccak256(["bytes"],[l]),p=i.name,f=cg.parse({...e,metadataUri:i.metadataUri,bytecodeUri:i.bytecodeUri,name:i.name,analytics:i.analytics,publisher:a}),h=await this.storage.upload(f);return sy.fromContractWrapper({contractWrapper:this.publisher,method:"publishContract",args:[a,p,h,i.metadataUri,d,C.d],parse:t=>{let e=this.publisher.parseLogs("ContractPublished",t.logs);if(e.length<1)throw Error("No ContractPublished event found");let r=e[0].args.publishedContract;return{receipt:t,data:async()=>this.toPublishedContract(r)}}})})),(0,tR._)(this,"unpublish",a2(async(t,e)=>{let r=await ex(t);return sy.fromContractWrapper({contractWrapper:this.publisher,method:"unpublishContract",args:[r,e]})})),this.storage=r,this.publisher=new ak(t,t9.env.contractPublisherAddress?t9.env.contractPublisherAddress:"0x664244560eBa21Bf82d7150C791bE1AbcD5B4cd7",t5,e)}updateSignerOrProvider(t){super.updateSignerOrProvider(t),this.publisher.updateSignerOrProvider(t)}async extractConstructorParams(t){return nB(t,this.storage)}async extractFunctions(t){return nD(t,this.storage)}async fetchCompilerMetadataFromPredeployURI(t){return nM(t,this.storage)}async fetchPrePublishMetadata(t,e){let r=await nM(t,this.storage),a=e?await this.getLatest(e,r.name):void 0,i=a?await this.fetchPublishedContractInfo(a):void 0;return{preDeployMetadata:r,latestPublishedContractMetadata:i}}async fetchCompilerMetadataFromAddress(t){let e=await ex(t);return o6(e,this.getProvider(),this.storage)}async fetchPublishedContractInfo(t){return{name:t.id,publishedTimestamp:t.timestamp,publishedMetadata:await this.fetchFullPublishMetadata(t.metadataUri)}}async fetchFullPublishMetadata(t){return nz(t,this.storage)}async resolvePublishMetadataFromCompilerMetadata(t){let e=await this.publisher.readContract.getPublishedUriFromCompilerUri(t);if(0===e.length)throw Error(`Could not resolve published metadata URI from ${t}`);return await Promise.all(e.filter(t=>t.length>0).map(t=>this.fetchFullPublishMetadata(t)))}async resolveContractUriFromAddress(t){let e=await ex(t),r=await nN(e,this.getProvider());return(0,tH.Z)(r,"Could not resolve contract URI from address"),r}async fetchContractSourcesFromAddress(t){let e=await ex(t),r=await this.fetchCompilerMetadataFromAddress(e);return await o4(r,this.storage)}async getPublisherProfile(t){let e=await ex(t),r=await this.publisher.readContract.getPublisherProfileUri(e);return r&&0!==r.length?cb.parse(await this.storage.downloadJSON(r)):{}}async getAll(t){let e=await ex(t),r=await this.publisher.readContract.getAllPublishedContracts(e),a=r.reduce((t,e)=>(t[e.contractId]=e,t),{});return Object.entries(a).map(t=>{let[,e]=t;return this.toPublishedContract(e)})}async getAllVersions(t,e){let r=await ex(t),a=await this.publisher.readContract.getPublishedContractVersions(r,e);if(0===a.length)throw Error("Not found");return a.map(t=>this.toPublishedContract(t))}async getVersion(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"latest",a=await ex(t);if("latest"===r)return this.getLatest(a,e);let i=await this.getAllVersions(a,e),n=await Promise.all(i.map(t=>this.fetchPublishedContractInfo(t))),s=n.find(t=>t.publishedMetadata.version===r);return(0,tH.Z)(s,"Contract version not found"),i.find(t=>t.timestamp===s.publishedTimestamp)}async getLatest(t,e){let r=await ex(t),a=await this.publisher.readContract.getPublishedContract(r,e);if(a&&a.publishMetadataUri)return this.toPublishedContract(a)}toPublishedContract(t){return cC.parse({id:t.contractId,timestamp:t.publishTimestamp,metadataUri:t.publishMetadataUri})}}class oJ{constructor(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};(0,tR._)(this,"registryLogic",void 0),(0,tR._)(this,"registryRouter",void 0),(0,tR._)(this,"storage",void 0),(0,tR._)(this,"addContract",a2(async t=>await this.addContracts.prepare([t]))),(0,tR._)(this,"addContracts",a2(async t=>{let e=await this.registryRouter.getSignerAddress(),r=[];return t.forEach(t=>{r.push(this.registryLogic.readContract.interface.encodeFunctionData("add",[e,t.address,t.chainId,t.metadataURI||""]))}),sy.fromContractWrapper({contractWrapper:this.registryRouter,method:"multicall",args:[r]})})),(0,tR._)(this,"removeContract",a2(async t=>await this.removeContracts.prepare([t]))),(0,tR._)(this,"removeContracts",a2(async t=>{let e=await this.registryRouter.getSignerAddress(),r=await Promise.all(t.map(async t=>this.registryLogic.readContract.interface.encodeFunctionData("remove",[e,await ex(t.address),t.chainId])));return sy.fromContractWrapper({contractWrapper:this.registryRouter,method:"multicall",args:[r]})})),this.storage=e,this.registryLogic=new ak(t,eu(),t6,r),this.registryRouter=new ak(t,eu(),t8,r)}async updateSigner(t){this.registryLogic.updateSignerOrProvider(t),this.registryRouter.updateSignerOrProvider(t)}async getContractMetadataURI(t,e){return await this.registryLogic.readContract.getMetadataUri(t,await ex(e))}async getContractMetadata(t,e){let r=await this.getContractMetadataURI(t,e);if(!r)throw Error(`No metadata URI found for contract ${e} on chain ${t}`);return await this.storage.downloadJSON(r)}async getContractAddresses(t){return(await this.registryLogic.readContract.getAll(await ex(t))).filter(t=>E.isAddress(t.deploymentAddress)&&t.deploymentAddress.toLowerCase()!==C.d).map(t=>({address:t.deploymentAddress,chainId:t.chainId.toNumber()}))}}class oY{constructor(t,e){(0,tR._)(this,"connection",void 0),(0,tR._)(this,"options",void 0),(0,tR._)(this,"events",new tU.Z),this.connection=new aW(t,e),this.options=e,this.events=new tU.Z}connect(t){this.connection.updateSignerOrProvider(t),this.events.emit("signerChanged",this.connection.getSigner())}async transfer(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:ew,a=await ex(t),i=await ex(r),n=this.requireWallet(),s=await aS(this.connection.getProvider(),e,r);if(!aE(i))return{receipt:await this.createErc20(i).sendTransaction("transfer",[a,s])};{let o=await n.getAddress(),c=await n.sendTransaction({from:o,to:a,value:s});return{receipt:await c.wait()}}}async balance(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:ew;this.requireWallet();let e=await ex(t),r=this.connection.getProvider();return await aP(r,e,aE(e)?await r.getBalance(await this.getAddress()):await this.createErc20(e).readContract.balanceOf(await this.getAddress()))}async getAddress(){return await this.requireWallet().getAddress()}async getChainId(){return await this.requireWallet().getChainId()}isConnected(){try{return this.requireWallet(),!0}catch(t){return!1}}async sign(t){let e=this.requireWallet();return await e.signMessage(t)}async signTypedData(t,e,r){return await ap(this.requireWallet(),t,e,r)}recoverAddress(t,e){let r=U.r(t),a=v.arrayify(r);return L.recoverAddress(a,e)}async sendRawTransaction(t){let e=this.requireWallet(),r=await e.sendTransaction(t);return{receipt:await r.wait()}}async requestFunds(t){let e=await this.getChainId();if(e===en.Localhost||e===en.Hardhat){let r=new oY(new V.Wallet("0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80",rY(e,this.options)),this.options);return r.transfer(await this.getAddress(),t)}throw Error(`Requesting funds is not supported on chain: '${e}'.`)}requireWallet(){let t=this.connection.getSigner();return(0,tH.Z)(t,"This action requires a connected wallet. Please pass a valid signer to the SDK."),t}createErc20(t){return new ak(this.connection.getSignerOrProvider(),t,Y,this.options)}}class oK extends aW{static async fromWallet(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},a=arguments.length>3?arguments[3]:void 0,i=await t.getSigner();return oK.fromSigner(i,e,r,a)}static fromSigner(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},a=arguments.length>3?arguments[3]:void 0,i=t;if(e&&!t.provider){let n=rY(e,r);i=t.connect(n)}let s=new oK(e||i,r,a);return s.updateSignerOrProvider(i),s}static fromPrivateKey(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},a=arguments.length>3?arguments[3]:void 0,i=rY(e,r),n=new V.Wallet(t,i);return new oK(n,r,a)}constructor(t){var e,r;let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},i=arguments.length>2?arguments[2]:void 0;rK(t)&&(a={...a,supportedChains:[t,...a.supportedChains||[]]}),super(t,a),(0,tR._)(this,"contractCache",new Map),(0,tR._)(this,"_publisher",void 0),(0,tR._)(this,"storageHandler",void 0),(0,tR._)(this,"deployer",void 0),(0,tR._)(this,"multiChainRegistry",void 0),(0,tR._)(this,"wallet",void 0),(0,tR._)(this,"storage",void 0),eo=(e=a?.supportedChains)&&e.length>0?e:tL.gL9;let n=(r=a,i||(r?.gatewayUrls?new tq.EA({gatewayUrls:r.gatewayUrls}):new tq.EA));this.storage=n,this.storageHandler=n,this.wallet=new oY(t,a),this.deployer=new o0(t,a,n),this.multiChainRegistry=new oJ(t,this.storageHandler,this.options),this._publisher=new oZ(t,this.options,this.storageHandler)}get auth(){throw Error(`The sdk.auth namespace has been moved to the @thirdweb-dev/auth package and is no longer available after @thirdweb-dev/sdk >= 3.7.0. 
      Please visit https://portal.thirdweb.com/auth for instructions on how to switch to using the new auth package (@thirdweb-dev/auth@3.0.0).
      
      If you still want to use the old @thirdweb-dev/auth@2.0.0 package, you can downgrade the SDK to version 3.6.0.`)}async getNFTDrop(t){return await this.getContract(t,"nft-drop")}async getSignatureDrop(t){return await this.getContract(t,"signature-drop")}async getNFTCollection(t){return await this.getContract(t,"nft-collection")}async getEditionDrop(t){return await this.getContract(t,"edition-drop")}async getEdition(t){return await this.getContract(t,"edition")}async getTokenDrop(t){return await this.getContract(t,"token-drop")}async getToken(t){return await this.getContract(t,"token")}async getVote(t){return await this.getContract(t,"vote")}async getSplit(t){return await this.getContract(t,"split")}async getMarketplace(t){return await this.getContract(t,"marketplace")}async getMarketplaceV3(t){return await this.getContract(t,"marketplace-v3")}async getPack(t){return await this.getContract(t,"pack")}async getMultiwrap(t){return await this.getContract(t,"multiwrap")}async getContract(t,e){let r;let a=await ex(t);if(this.contractCache.has(a))return this.contractCache.get(a);if(a in t3.Z)return await this.getContractFromAbi(a,t3.Z[a]);if(e&&"custom"!==e)r="string"==typeof e&&e in oL?await oL[e].initialize(this.getSignerOrProvider(),a,this.storage,this.options):await this.getContractFromAbi(a,e);else try{let i=await this.getPublisher().fetchCompilerMetadataFromAddress(a);r=await this.getContractFromAbi(a,i.abi)}catch(c){let n=await this.resolveContractType(t);if(n&&"custom"!==n){let s=await oL[n].getAbi(t,this.getProvider(),this.storage);r=await this.getContractFromAbi(t,s)}else{let o=(await this.getProvider().getNetwork()).chainId;throw Error(`No ABI found for this contract. Try importing it by visiting: https://thirdweb.com/${o}/${a}`)}}return this.contractCache.set(a,r),r}async getBuiltInContract(t,e){return await this.getContract(t,e)}async resolveContractType(t){try{let e=new F.CH(await ex(t),b,this.getProvider()),r=S.ZN(await e.contractType()).replace(/\x00/g,"");return Object.values(o$).find(t=>t.name===r)?.contractType||"custom"}catch(a){return"custom"}}async getContractList(t){let e=await (await this.deployer.getRegistry())?.getContractAddresses(await ex(t))||[],r=(await this.getProvider().getNetwork()).chainId;return await Promise.all(e.map(async t=>({address:t,chainId:r,contractType:()=>this.resolveContractType(t),metadata:async()=>(await this.getContract(t)).metadata.get(),extensions:async()=>nU((await this.getContract(t)).abi)})))}async getMultichainContractList(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:tL.gL9,r=await this.multiChainRegistry.getContractAddresses(t),a=e.reduce((t,e)=>(t[e.chainId]=e,t),{}),i={};return r.map(t=>{let{address:r,chainId:n}=t;if(!a[n])return{address:r,chainId:n,contractType:async()=>"custom",metadata:async()=>({}),extensions:async()=>[]};try{let s=i[n];return s||(s=new oK(n,{...this.options,readonlySettings:void 0,supportedChains:e}),i[n]=s),{address:r,chainId:n,contractType:()=>s.resolveContractType(r),metadata:async()=>(await s.getContract(r)).metadata.get(),extensions:async()=>nU((await s.getContract(r)).abi)}}catch(o){return{address:r,chainId:n,contractType:async()=>"custom",metadata:async()=>({}),extensions:async()=>[]}}})}updateSignerOrProvider(t){super.updateSignerOrProvider(t),this.updateContractSignerOrProvider()}updateContractSignerOrProvider(){for(let[,t]of(this.wallet.connect(this.getSignerOrProvider()),this.deployer.updateSignerOrProvider(this.getSignerOrProvider()),this._publisher.updateSignerOrProvider(this.getSignerOrProvider()),this.multiChainRegistry.updateSigner(this.getSignerOrProvider()),this.contractCache))t.onNetworkUpdated(this.getSignerOrProvider())}async getContractFromAbi(t,e){let r=await ex(t);if(this.contractCache.has(r))return this.contractCache.get(r);let[,a]=eE(this.getSignerOrProvider(),this.options),i="string"==typeof e?JSON.parse(e):e,n=new oH(this.getSignerOrProvider(),r,await sh(r,cd.parse(i),a,this.options,this.storage),this.storageHandler,this.options,(await a.getNetwork()).chainId);return this.contractCache.set(r,n),n}async getBalance(t){return aP(this.getProvider(),ew,await this.getProvider().getBalance(await ex(t)))}getPublisher(){return this._publisher}}class oQ extends ak{constructor(t,e,r,a){super(e,t,t4,a),(0,tR._)(this,"storage",void 0),(0,tR._)(this,"DEFAULT_VERSION_MAP",{[ox.contractType]:3,[oP.contractType]:1,[oD.contractType]:4,[o_.contractType]:1,[ok.contractType]:2,[oE.contractType]:1,[oO.contractType]:2,[oI.contractType]:1,[oR.contractType]:1,[oF.contractType]:1,[oT.contractType]:2,[oS.contractType]:1,[oB.contractType]:2}),(0,tR._)(this,"deploy",a2(async(t,e,r,a,i)=>{let n=oL[t],s=await n.schema.deploy.parseAsync(e),o=await this.storage.upload(s),c=await this.getImplementation(n,a)||void 0;if(!c||c===C.d)throw Error(`No implementation found for ${t}`);let l=await n.getAbi(c,this.getProvider(),this.storage),d=this.getSigner();(0,tH.Z)(d,"A signer is required to deploy contracts");let p=await oV(t,s,o,d,this.storage),f=F.CH.getInterface(l).encodeFunctionData("initialize",p),h=await this.getProvider().getBlockNumber(),u=q.s(h.toString());return sy.fromContractWrapper({contractWrapper:this,method:"deployProxyByImplementation",args:[c,f,u],parse:t=>{i&&i();let e=this.parseLogs("ProxyDeployed",t.logs);if(e.length<1)throw Error("No ProxyDeployed event found");let a=e[0].args.proxy;return r.emit("contractDeployed",{status:"completed",contractAddress:a,transactionHash:t.transactionHash}),a}})})),(0,tR._)(this,"deployProxyByImplementation",a2(async(t,e,r,a,i,n)=>{let s=F.CH.getInterface(e).encodeFunctionData(r,a),o=await this.getProvider().getBlockNumber();return sy.fromContractWrapper({contractWrapper:this,method:"deployProxyByImplementation",args:[t,s,q.s(o.toString())],parse:t=>{n&&n();let e=this.parseLogs("ProxyDeployed",t.logs);if(e.length<1)throw Error("No ProxyDeployed event found");let r=e[0].args.proxy;return i.emit("contractDeployed",{status:"completed",contractAddress:r,transactionHash:t.transactionHash}),r}})})),this.storage=r}async getDeployArguments(t,e,r){let a=t===oB.contractType?[]:await this.getDefaultTrustedForwarders();switch(e.trusted_forwarders&&e.trusted_forwarders.length>0&&(a=e.trusted_forwarders),t){case ox.contractType:case oP.contractType:let i=await ox.schema.deploy.parseAsync(e);return[await this.getSignerAddress(),i.name,i.symbol,r,a,i.primary_sale_recipient,i.fee_recipient,i.seller_fee_basis_points,i.platform_fee_basis_points,i.platform_fee_recipient];case oD.contractType:let n=await oD.schema.deploy.parseAsync(e);return[await this.getSignerAddress(),n.name,n.symbol,r,a,n.primary_sale_recipient,n.fee_recipient,n.seller_fee_basis_points,n.platform_fee_basis_points,n.platform_fee_recipient];case o_.contractType:let s=await o_.schema.deploy.parseAsync(e);return[await this.getSignerAddress(),s.name,s.symbol,r,a,s.fee_recipient,s.seller_fee_basis_points];case ok.contractType:case oE.contractType:let o=await ok.schema.deploy.parseAsync(e);return[await this.getSignerAddress(),o.name,o.symbol,r,a,o.primary_sale_recipient,o.fee_recipient,o.seller_fee_basis_points,o.platform_fee_basis_points,o.platform_fee_recipient];case oO.contractType:case oI.contractType:let c=await oI.schema.deploy.parseAsync(e);return[await this.getSignerAddress(),c.name,c.symbol,r,a,c.primary_sale_recipient,c.platform_fee_recipient,c.platform_fee_basis_points];case oR.contractType:let l=await oR.schema.deploy.parseAsync(e);return[l.name,r,a,l.voting_token_address,l.voting_delay_in_blocks,l.voting_period_in_blocks,T.O$.from(l.proposal_token_threshold),l.voting_quorum_fraction];case oF.contractType:let d=await oF.schema.deploy.parseAsync(e);return[await this.getSignerAddress(),r,a,d.recipients.map(t=>t.address),d.recipients.map(t=>T.O$.from(t.sharesBps))];case oT.contractType:let p=await oT.schema.deploy.parseAsync(e);return[await this.getSignerAddress(),r,a,p.platform_fee_recipient,p.platform_fee_basis_points];case oS.contractType:let f=await oS.schema.deploy.parseAsync(e);return[await this.getSignerAddress(),r,a,f.platform_fee_recipient,f.platform_fee_basis_points];case oB.contractType:let h=await oB.schema.deploy.parseAsync(e);return[await this.getSignerAddress(),h.name,h.symbol,r,a,h.fee_recipient,h.seller_fee_basis_points];default:return[]}}async getDefaultTrustedForwarders(){let t=await this.getChainID();return em(t)}async getImplementation(t,e){let r=q.s(t.name),a=await this.getChainID(),i=function(t,e){if(t in ef){let r=ef[t];if(e in r)return r[e]}return null}(a,t.contractType);return i&&i.length>0&&void 0===e?i:this.readContract.getImplementation(r,void 0!==e?e:this.DEFAULT_VERSION_MAP[t.contractType])}async getLatestVersion(t){let e=oU(t);if(!e)throw Error(`Invalid contract type ${t}`);let r=q.s(e);return this.readContract.currentVersion(r)}}class oX extends ak{constructor(t,e,r){super(e,t,t7,r),(0,tR._)(this,"addContract",a2(async t=>await this.addContracts.prepare([t]))),(0,tR._)(this,"addContracts",a2(async t=>{let e=await this.getSignerAddress(),r=await Promise.all(t.map(async t=>this.readContract.interface.encodeFunctionData("add",[e,await ex(t)])));return sy.fromContractWrapper({contractWrapper:this,method:"multicall",args:[r]})})),(0,tR._)(this,"removeContract",a2(async t=>await this.removeContracts.prepare([t]))),(0,tR._)(this,"removeContracts",a2(async t=>{let e=await this.getSignerAddress(),r=await Promise.all(t.map(async t=>this.readContract.interface.encodeFunctionData("remove",[e,await ex(t)])));return sy.fromContractWrapper({contractWrapper:this,method:"multicall",args:[r]})}))}async getContractAddresses(t){return(await this.readContract.getAll(await ex(t))).filter(t=>E.isAddress(t)&&t.toLowerCase()!==C.d)}}class o0 extends aW{constructor(t,e,a){var i;super(t,e),i=this,(0,tR._)(this,"_factory",void 0),(0,tR._)(this,"_registry",void 0),(0,tR._)(this,"storage",void 0),(0,tR._)(this,"events",void 0),(0,tR._)(this,"transactionListener",t=>{"submitted"===t.status&&this.events.emit("contractDeployed",{status:"submitted",transactionHash:t.transactionHash})}),(0,tR._)(this,"deployNFTCollection",a1(async t=>await this.deployBuiltInContract.prepare(oP.contractType,t))),(0,tR._)(this,"deployNFTDrop",a1(async t=>await this.deployBuiltInContract.prepare(ox.contractType,t))),(0,tR._)(this,"deploySignatureDrop",a1(async t=>await this.deployBuiltInContract.prepare(oD.contractType,t))),(0,tR._)(this,"deployMultiwrap",a1(async t=>await this.deployBuiltInContract.prepare(o_.contractType,t))),(0,tR._)(this,"deployEdition",a1(async t=>await this.deployBuiltInContract.prepare(oE.contractType,t))),(0,tR._)(this,"deployEditionDrop",a1(async t=>await this.deployBuiltInContract.prepare(ok.contractType,t))),(0,tR._)(this,"deployToken",a1(async t=>await this.deployBuiltInContract.prepare(oI.contractType,t))),(0,tR._)(this,"deployTokenDrop",a1(async t=>await this.deployBuiltInContract.prepare(oO.contractType,t))),(0,tR._)(this,"deployMarketplace",a1(async t=>await this.deployBuiltInContract.prepare(oT.contractType,t))),(0,tR._)(this,"deployMarketplaceV3",a1(async t=>await this.deployBuiltInContract.prepare(oS.contractType,t))),(0,tR._)(this,"deployPack",a1(async t=>await this.deployBuiltInContract.prepare(oB.contractType,t))),(0,tR._)(this,"deploySplit",a1(async t=>await this.deployBuiltInContract.prepare(oF.contractType,t))),(0,tR._)(this,"deployVote",a1(async t=>await this.deployBuiltInContract.prepare(oR.contractType,t))),(0,tR._)(this,"deployBuiltInContract",a1(async function(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"latest",a=i.getSigner();(0,tH.Z)(a,"A signer is required to deploy contracts");let n={app_uri:oM[t],...await oL[t].schema.deploy.parseAsync(e)};if(i.hasLocalFactory()){let s;try{s=parseInt(r),isNaN(s)&&(s=void 0)}catch(o){s=void 0}let c=await i.getFactory();if(!c)throw Error("Factory not found");return c.on(eW.Transaction,i.transactionListener),c.deploy.prepare(t,n,i.events,s,()=>{c.off(eW.Transaction,i.transactionListener)})}let l=oU(t);(0,tH.Z)(l,"Contract name not found");let d=await i.storage.upload(n),p=await oV(t,n,d,a,i.storage),f=await i.fetchPublishedContractFromPolygon("0xdd99b75f095d0c4d5112aCe938e4e6ed962fb024",l,r);return i.deployContractFromUri.prepare(f.metadataUri,p)})),(0,tR._)(this,"deployReleasedContract",a1(async function(t,e,r){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"latest",n=arguments.length>4?arguments[4]:void 0,s=await i.fetchPublishedContractFromPolygon(t,e,a);return await i.deployContractFromUri.prepare(s.metadataUri,r,n)})),(0,tR._)(this,"deployViaFactory",a2(async(t,e,r,a,i)=>{let n=await ex(t),s=await ex(e),o=this.getSigner();(0,tH.Z)(o,"signer is required");let c=new oQ(n,this.getSignerOrProvider(),this.storage,this.options);return c.on(eW.Transaction,this.transactionListener),await c.deployProxyByImplementation.prepare(s,r,a,i,this.events,()=>{c.off(eW.Transaction,this.transactionListener)})})),(0,tR._)(this,"deployProxy",a1(async(t,e,a,i)=>{let n=await ex(t),s=F.CH.getInterface(e).encodeFunctionData(a,i),{TWProxy__factory:o}=await r.e(1548).then(r.bind(r,41548));return this.deployContractWithAbi.prepare(o.abi,o.bytecode,[n,s])})),(0,tR._)(this,"deployContractFromUri",a1(async(t,e,r)=>{let a=this.getSigner();(0,tH.Z)(a,"A signer is required");let{compilerMetadata:i,extendedMetadata:n}=await sp(t,this.storage),s=r?.forceDirectDeploy||!1;if(n&&n.factoryDeploymentData&&(n.isDeployableViaProxy||n.isDeployableViaFactory)&&!s){let o=(await this.getProvider().getNetwork()).chainId;(0,tH.Z)(n.factoryDeploymentData.implementationInitializerFunction,"implementationInitializerFunction not set'");let c=(function(t,e){let r=cd.parse(t||[]);for(let a of r)if("function"===a.type&&a.name===e)return a.inputs||[];return[]})(i.abi,n.factoryDeploymentData.implementationInitializerFunction).map(t=>t.type),l=this.convertParamValues(c,e),d=n.factoryDeploymentData.implementationAddresses[o];if(d){let p=await ex(d);if((0,tH.Z)(p,`implementationAddress not found for chainId '${o}'`),n.isDeployableViaFactory){(0,tH.Z)(n.factoryDeploymentData.factoryAddresses,"isDeployableViaFactory is true so factoryAddresses is required");let f=n.factoryDeploymentData.factoryAddresses[o];(0,tH.Z)(f,`isDeployableViaFactory is true and factoryAddress not found for chainId '${o}'`);let h=await ex(f);return await this.deployViaFactory.prepare(h,p,i.abi,n.factoryDeploymentData.implementationInitializerFunction,l)}if(n.isDeployableViaProxy)return await this.deployProxy.prepare(p,i.abi,n.factoryDeploymentData.implementationInitializerFunction,l)}else{let u=await sa(a,r),m=await sn(t,this.storage,this.getProvider(),u);d=m.find(t=>"implementation"===t.type)?.transaction.predictedAddress;let g=m.filter(t=>t.transaction.data&&t.transaction.data.length>0),y=g.filter(t=>"infra"!==t.type).map(t=>t.transaction),w=g.filter(t=>"infra"===t.type).map(t=>t.transaction);await ss(a,w,r),await Promise.all(y.map(t=>si(a,t,r)));let b=await ex(d),C=await sr(this.getProvider(),this.storage,u);r?.notifier?.("deploying","proxy");let W=await this.deployViaFactory.prepare(C,b,i.abi,n.factoryDeploymentData.implementationInitializerFunction,l);return r?.notifier?.("deployed","proxy"),W}}let A=i.bytecode.startsWith("0x")?i.bytecode:`0x${i.bytecode}`;if(!v.isHexString(A))throw Error(`Contract bytecode is invalid.

${A}`);let k=nO(i.abi).map(t=>t.type),E=this.convertParamValues(k,e);return this.deployContractWithAbi.prepare(i.abi,A,E)})),(0,tR._)(this,"deployContractWithAbi",a1(async(t,e,r)=>{let a=this.getSigner(),i=this.getProvider();(0,tH.Z)(a,"Signer is required to deploy contracts");let n=new F.lV(t,e).connect(a);return new sw({args:r,provider:i,signer:a,factory:n,storage:this.storage,events:this.events})})),this.storage=a,this.events=new tU.v,this.getFactory(),this.getRegistry()}async getLatestBuiltInContractVersion(t){let e=await this.getFactory();if(!e)throw Error("Factory not found");return await e.getLatestVersion(t)}async getRegistry(){return this._registry?this._registry:this._registry=this.getProvider().getNetwork().then(async t=>{let{chainId:e}=t,r=eh(e,"twRegistry");if(r)return new oX(r,this.getSignerOrProvider(),this.options)})}async getFactory(){return this._factory?this._factory:this._factory=this.getProvider().getNetwork().then(async t=>{let{chainId:e}=t,r=eh(e,"twFactory");if(!r)return;let a=new oQ(r,this.getSignerOrProvider(),this.storage,this.options);return a})}updateSignerOrProvider(t){super.updateSignerOrProvider(t),this.updateContractSignerOrProvider()}updateContractSignerOrProvider(){this._factory?.then(t=>{t?.updateSignerOrProvider(this.getSignerOrProvider())}).catch(()=>{}),this._registry?.then(t=>{t?.updateSignerOrProvider(this.getSignerOrProvider())}).catch(()=>{})}async getTransactionsForDeploy(t,e){let r=[],a=this.getProvider();(0,tH.Z)(a,"A provider is required");let{extendedMetadata:i}=await sp(t,this.storage),n=e?.forceDirectDeploy||!1;if(i&&i.factoryDeploymentData&&(i.isDeployableViaProxy||i.isDeployableViaFactory)&&!n){let s=(await this.getProvider().getNetwork()).chainId;if(!i.factoryDeploymentData.implementationAddresses[s]){let o=await n4(this.getProvider());r.push({contractType:"create2Factory",addresses:[o]});let c=await sn(t,this.storage,this.getProvider(),o),l=c.filter(t=>t.transaction.data&&t.transaction.data.length>0),d=l.filter(t=>"infra"!==t.type).map(t=>t.transaction);d.forEach(t=>{r.push({contractType:"preset",addresses:[t.predictedAddress]})});let p=l.filter(t=>"infra"===t.type).map(t=>t.transaction),f=sf(p);f.forEach(t=>{let e=t.map(t=>t.predictedAddress);r.push({contractType:"infra",addresses:e})})}(r=(await Promise.all(r.map(async t=>{let e=(await Promise.all(t.addresses.map(async t=>{let e=await n8(t,a);return e?null:t}))).filter(Boolean);return e.length>0?t:null}))).filter(Boolean)).push({contractType:"proxy",addresses:[]})}else r.push({contractType:"custom",addresses:[]});return r}addDeployListener(t){this.events.on("contractDeployed",t)}removeDeployListener(t){this.events.off("contractDeployed",t)}removeAllDeployListeners(){this.events.removeAllListeners("contractDeployed")}async fetchPublishedContractFromPolygon(t,e,r){let a=await ex(t),i=await new oK("polygon").getPublisher().getVersion(a,e,r);if(!i)throw Error(`No published contract found for '${e}' at version '${r}' by '${a}'`);return i}hasLocalFactory(){return void 0!==t9.env.factoryAddress}convertParamValues(t,e){if(t.length!==e.length)throw Error(`Passed the wrong number of constructor arguments: ${e.length}, expected ${t.length}`);return t.map((t,r)=>"tuple"===t||t.endsWith("[]")?"string"==typeof e[r]?JSON.parse(e[r]):e[r]:"bytes32"===t?((0,tH.Z)(v.isHexString(e[r]),`Could not parse bytes32 value. Expected valid hex string but got "${e[r]}".`),v.hexZeroPad(e[r],32)):t.startsWith("bytes")?((0,tH.Z)(v.isHexString(e[r]),`Could not parse bytes value. Expected valid hex string but got "${e[r]}".`),e[r]):t.startsWith("uint")||t.startsWith("int")?T.O$.from(e[r].toString()):e[r])}}class o1{constructor(t){(0,tR._)(this,"featureName",is.name),(0,tR._)(this,"contractWrapper",void 0),(0,tR._)(this,"set",a2(async t=>{let e=await ex(t);return sy.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setOwner",args:[e]})})),this.contractWrapper=t}async get(){return this.contractWrapper.readContract.owner()}}let o2={},o5=new oK("polygon");async function o6(t,e,r){var a;let i;let n=(await e.getNetwork()).chainId,s=o2[`${t}-${n}`];if(s)return s;try{let o=await nN(t,e);if(!o)throw Error(`Could not resolve metadata for contract at ${t}`);i=await o3(o,r)}catch(d){try{let c=await o5.multiChainRegistry.getContractMetadataURI(n,t);if(!c)throw Error(`Could not resolve metadata for contract at ${t}`);i=await o3(c,r)}catch(l){throw Error(`Could not resolve metadata for contract at ${t}`)}}if(!i)throw Error(`Could not resolve metadata for contract at ${t}`);return a=i,o2[`${t}-${n}`]=a,i}async function o8(t,e,r){try{let a=await o6(t,e,r);if(a&&a.abi)return a.abi}catch(i){}}async function o3(t,e){let r=await e.downloadJSON(t);if(!r||!r.output)throw Error(`Could not resolve metadata for contract at ${t}`);let a=cd.parse(r.output.abi),i=r.settings.compilationTarget,n=Object.keys(i),s=i[n[0]],o=cv.parse({title:r.output.devdoc.title,author:r.output.devdoc.author,details:r.output.devdoc.detail,notice:r.output.userdoc.notice}),c=[...new Set(Object.entries(r.sources).map(t=>{let[,e]=t;return e.license}))];return{name:s,abi:a,metadata:r,info:o,licenses:c}}async function o4(t,e){return await Promise.all(Object.entries(t.metadata.sources).map(async t=>{let[r,a]=t,i=a.urls,n=i?i.find(t=>t.includes("ipfs")):void 0;if(!n)return{filename:r,source:a.content||"Could not find source for this contract"};{let s=n.split("ipfs/")[1],o=new Promise((t,e)=>setTimeout(()=>e("timeout"),3e3)),c=await Promise.race([(await e.download(`ipfs://${s}`)).text(),o]);return{filename:r,source:c}}}))}let o7="0|[1-9]\\d*",o9=`(${o7})\\.(${o7})\\.(${o7})`,ct=RegExp(o9);function ce(t){if(t.length>256)throw Error("version is longer than 256 characters");let e=t.trim().match(ct);if(!e||e?.length!==4)throw Error(`${t} is not a valid semantic version. Should be in the format of major.minor.patch. Ex: 0.4.1`);let r=Number(e[1]),a=Number(e[2]),i=Number(e[3]),n=[r,a,i].join(".");return{major:r,minor:a,patch:i,versionString:n}}let cr=rn.catchall(tN.z.union([eO,tN.z.unknown()])),ca=cr.merge(ro.merge(ej).merge(rp).partial()),ci=rs.merge(ro.merge(ej).merge(rp).partial()),cn=ca.merge(rl.merge(rc).merge(rd).partial()),cs={deploy:cn,output:ci,input:ca},co=tN.z.object({type:tN.z.string(),name:tN.z.string().default("")}).catchall(tN.z.any()),cc=co.extend({stateMutability:tN.z.string().optional(),components:tN.z.array(co).optional()}).catchall(tN.z.any()),cl=tN.z.object({type:tN.z.string(),name:tN.z.string().default(""),inputs:tN.z.array(cc).default([]),outputs:tN.z.array(cc).default([])}).catchall(tN.z.any()),cd=tN.z.array(cl),cp=tN.z.object({name:tN.z.string(),metadataUri:tN.z.string(),bytecodeUri:tN.z.string(),analytics:tN.z.any().optional()}).catchall(tN.z.any()),cf=tN.z.record(tN.z.string(),tN.z.string()),ch=tN.z.object({implementationAddresses:cf,implementationInitializerFunction:tN.z.string().default("initialize"),factoryAddresses:cf.optional()}),cu=tN.z.object({version:tN.z.string().refine(t=>{try{return ce(t),!0}catch(e){return!1}},t=>({message:`'${t}' is not a valid semantic version. Should be in the format of major.minor.patch. Ex: 0.4.1`})),displayName:tN.z.string().optional(),description:tN.z.string().optional(),readme:tN.z.string().optional(),license:tN.z.string().optional(),changelog:tN.z.string().optional(),tags:tN.z.array(tN.z.string()).optional(),audit:tR.F.nullable().optional(),logo:tR.F.nullable().optional(),isDeployableViaFactory:tN.z.boolean().optional(),isDeployableViaProxy:tN.z.boolean().optional(),factoryDeploymentData:ch.optional(),constructorParams:tN.z.record(tN.z.string(),tN.z.object({displayName:tN.z.string().optional(),description:tN.z.string().optional(),defaultValue:tN.z.string().optional()}).catchall(tN.z.any())).optional()}).catchall(tN.z.any()),cm=cu.extend({audit:tN.z.string().nullable().optional(),logo:tN.z.string().nullable().optional()}),cg=cp.merge(cu).extend({publisher:eR.optional()}),cy=cp.merge(cm).extend({publisher:eR.optional()}),cw=tN.z.object({name:tN.z.string().optional(),bio:tN.z.string().optional(),avatar:tR.F.nullable().optional(),website:tN.z.string().optional(),twitter:tN.z.string().optional(),telegram:tN.z.string().optional(),facebook:tN.z.string().optional(),github:tN.z.string().optional(),medium:tN.z.string().optional(),linkedin:tN.z.string().optional(),reddit:tN.z.string().optional(),discord:tN.z.string().optional()}),cb=cw.extend({avatar:tN.z.string().nullable().optional()}),cC=tN.z.object({id:tN.z.string(),timestamp:eF,metadataUri:tN.z.string()}),cv=tN.z.object({title:tN.z.string().optional(),author:tN.z.string().optional(),details:tN.z.string().optional(),notice:tN.z.string().optional()}),cW=tN.z.object({name:tN.z.string(),abi:cd,metadata:tN.z.record(tN.z.string(),tN.z.any()),info:cv,licenses:tN.z.array(tN.z.string().optional()).default([]).transform(t=>t.filter(t=>void 0!==t))}),cA=cp.merge(cW).extend({bytecode:tN.z.string()});new tq.EA,new WeakMap}}]);